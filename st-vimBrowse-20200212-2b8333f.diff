From de020f0c06440fd19a36e1b001ef9e0058f73369 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Thu, 7 Nov 2019 09:08:49 +0100
Subject: [PATCH 01/23] [PATCH:VIM]: first version

---
 Makefile       |   6 +-
 config.def.h   |  27 ++
 dynamicArray.h |  90 ++++++
 st.c           | 794 +++++++++++++++++++++++++++++++++++++++++++++----
 st.h           |  31 +-
 win.h          |   2 +
 x.c            |  51 +++-
 7 files changed, 936 insertions(+), 65 deletions(-)
 create mode 100644 dynamicArray.h

diff --git a/Makefile b/Makefile
index 470ac86..7d93347 100644
--- a/Makefile
+++ b/Makefile
@@ -21,8 +21,8 @@ config.h:
 .c.o:
 	$(CC) $(STCFLAGS) -c $<
 
-st.o: config.h st.h win.h
-x.o: arg.h config.h st.h win.h
+st.o: config.h st.h win.h dynamicArray.h
+x.o: arg.h config.h st.h win.h dynamicArray.h
 
 $(OBJ): config.h config.mk
 
@@ -35,7 +35,7 @@ clean:
 dist: clean
 	mkdir -p st-$(VERSION)
 	cp -R FAQ LEGACY TODO LICENSE Makefile README config.mk\
-		config.def.h st.info st.1 arg.h st.h win.h $(SRC)\
+		config.def.h st.info st.1 arg.h st.h win.h dynamicArray.h $(SRC)\
 		st-$(VERSION)
 	tar -cf - st-$(VERSION) | gzip > st-$(VERSION).tar.gz
 	rm -rf st-$(VERSION)
diff --git a/config.def.h b/config.def.h
index 6ebea98..1b0e501 100644
--- a/config.def.h
+++ b/config.def.h
@@ -149,6 +149,12 @@ static unsigned int mousebg = 0;
  * doesn't match the ones requested.
  */
 static unsigned int defaultattr = 11;
+/// Colors for the entities that are highlighted in normal mode.
+static unsigned int highlightBg = 160;
+static unsigned int highlightFg = 15;
+/// Colors for the line and column that is marked 'current' in normal mode.
+static unsigned int currentBg = 0;
+static unsigned int currentFg = 15;
 
 /*
  * Internal mouse shortcuts.
@@ -162,10 +168,12 @@ static MouseShortcut mshortcuts[] = {
 
 /* Internal keyboard shortcuts. */
 #define MODKEY Mod1Mask
+#define AltMask Mod1Mask
 #define TERMMOD (ControlMask|ShiftMask)
 
 static Shortcut shortcuts[] = {
 	/* mask                 keysym          function        argument */
+	{ AltMask,              XK_c,           normalMode,     {.i =  0} },
 	{ XK_ANY_MOD,           XK_Break,       sendbreak,      {.i =  0} },
 	{ ControlMask,          XK_Print,       toggleprinter,  {.i =  0} },
 	{ ShiftMask,            XK_Print,       printscreen,    {.i =  0} },
@@ -178,6 +186,8 @@ static Shortcut shortcuts[] = {
 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+	{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },
+	{ ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },
 };
 
 /*
@@ -456,3 +466,20 @@ static char ascii_printable[] =
 	" !\"#$%&'()*+,-./0123456789:;<=>?"
 	"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
 	"`abcdefghijklmnopqrstuvwxyz{|}~";
+
+
+/// word sepearors normal mode
+char wordDelimSmall[] = " \t!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
+char wordDelimLarge[] = " \t"; /// <Word sepearors normal mode (capital W)
+
+/// Shortcusts executed in normal mode (which should not already be in use)
+struct NormalModeShortcuts normalModeShortcuts [] = {
+	{ 'C', "?Building\n" },
+	{ 'c', "/Building\n" },
+	{ 'F', "?: error:\n" },
+	{ 'f', "/: error:\n" },
+	{ 'X', "?juli@machine\n" },
+	{ 'x', "/juli@machine\n" },
+};
+
+size_t const amountNormalModeShortcuts = sizeof(normalModeShortcuts) / sizeof(*normalModeShortcuts);
diff --git a/dynamicArray.h b/dynamicArray.h
new file mode 100644
index 0000000..c65fbef
--- /dev/null
+++ b/dynamicArray.h
@@ -0,0 +1,90 @@
+#include <stdint.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+/// Struct for which this file offers functionality in order to expand the array
+/// and set / get its content.
+typedef struct DynamicArray {
+	uint8_t itemSize;
+	uint32_t index;
+	uint32_t allocated;
+	char* content;
+} DynamicArray;
+
+#define EXPAND_STEP 15
+
+/// Default initializers for the dynamic array.
+#define CHAR_ARRAY  {1, 0, 0, NULL}
+#define WORD_ARRAY  {2, 0, 0, NULL}
+#define DWORD_ARRAY {4, 0, 0, NULL}
+#define QWORD_ARRAY {8, 0, 0, NULL}
+/// (Wasteful) utf-8 array, that always used 4 bytes in order to display a character,
+/// even if the space is not required.
+#define UTF8_ARRAY  DWORD_ARRAY
+
+
+inline char*
+gnext(DynamicArray *s) { return &s->content[s->index+=s->itemSize]; }
+
+inline char*
+get(DynamicArray const * s) { return &s->content[s->index]; }
+
+inline char*
+view(DynamicArray const * s, uint32_t i) {
+	return s->content + i*s->itemSize;
+}
+
+inline char *
+viewEnd(DynamicArray const *s, uint32_t i) {
+	return s->content + s->index - (i + 1) * s->itemSize;
+}
+
+inline void
+set(DynamicArray* s, char const *vals, uint8_t amount) {
+	assert(amount <= s->itemSize);
+	memcpy(s->content + s->index, vals, amount);
+}
+
+inline void
+snext(DynamicArray* s, char const *vals, uint8_t amount) {
+	set(s, vals, amount);
+	s->index+=s->itemSize;
+}
+
+inline void
+empty(DynamicArray* s) { s->index = 0; }
+
+inline bool
+isEmpty(DynamicArray* s) { return s->index == 0; }
+
+inline uint32_t
+size(DynamicArray const * s) { return s->index / s->itemSize; }
+
+inline void
+pop(DynamicArray* s) { s->index -= s->itemSize; }
+
+inline void checkSetNext(DynamicArray *s, char const *c, uint8_t amount) {
+	if (s->index + s->itemSize >= s->allocated) {
+		if ((s->content = (char *)realloc(
+						s->content, s->allocated += EXPAND_STEP * s->itemSize)) == NULL) {
+			exit(1);
+		};
+	}
+	if (amount) { snext(s, c, amount); }
+}
+
+char *checkGetNext(DynamicArray *s) {
+	if (s->index + s->itemSize >= s->allocated) {
+		if ((s->content = (char *)realloc(
+						s->content, s->allocated += EXPAND_STEP * s->itemSize)) == NULL) {
+			exit(1);
+		};
+	}
+	s->index+=s->itemSize;
+	return viewEnd(s, 0);
+}
+
+#define append(s, c) checkSetNext((s), (char const *) (c), (s)->itemSize)
+#define appendPartial(s, c, i) checkSetNext((s), (char const *) (c), (i))
diff --git a/st.c b/st.c
index ede7ae6..27bfca8 100644
--- a/st.c
+++ b/st.c
@@ -1,8 +1,10 @@
 /* See LICENSE for license details. */
+#include <assert.h>
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <math.h>
 #include <pwd.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -17,8 +19,10 @@
 #include <unistd.h>
 #include <wchar.h>
 
+
 #include "st.h"
 #include "win.h"
+#include "dynamicArray.h"
 
 #if   defined(__linux)
  #include <pty.h>
@@ -35,6 +39,8 @@
 #define ESC_ARG_SIZ   16
 #define STR_BUF_SIZ   ESC_BUF_SIZ
 #define STR_ARG_SIZ   ESC_ARG_SIZ
+//#define HISTSIZE      100
+#define HISTSIZE      2000
 
 /* macros */
 #define IS_SET(flag)		((term.mode & (flag)) != 0)
@@ -42,6 +48,9 @@
 #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
 #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
 #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
+#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
+				term.scr + HISTSIZE + 1) % HISTSIZE] : \
+				term.line[(y) - term.scr])
 
 enum term_mode {
 	MODE_WRAP        = 1 << 0,
@@ -97,16 +106,18 @@ typedef struct {
 	int mode;
 	int type;
 	int snap;
-	/*
-	 * Selection variables:
-	 * nb – normalized coordinates of the beginning of the selection
-	 * ne – normalized coordinates of the end of the selection
-	 * ob – original coordinates of the beginning of the selection
-	 * oe – original coordinates of the end of the selection
-	 */
+	/// Selection variables:
+	/// ob – original coordinates of the beginning of the selection
+	/// oe – original coordinates of the end of the selection
+	struct {
+		int x, y, scroll;
+	} ob, oe;
+	/// Selection variables; currently displayed chunk.
+	/// nb – normalized coordinates of the beginning of the selection
+	/// ne – normalized coordinates of the end of the selection
 	struct {
 		int x, y;
-	} nb, ne, ob, oe;
+	} nb, ne;
 
 	int alt;
 } Selection;
@@ -117,6 +128,9 @@ typedef struct {
 	int col;      /* nb col */
 	Line *line;   /* screen */
 	Line *alt;    /* alternate screen */
+	Line hist[HISTSIZE]; /* history buffer */
+	int histi;    /* history index */
+	int scr;      /* scroll back */
 	int *dirty;   /* dirtyness of lines */
 	TCursor c;    /* cursor */
 	int ocx;      /* old cursor col */
@@ -152,6 +166,50 @@ typedef struct {
 	int narg;              /* nb of args */
 } STREscape;
 
+/// Position (x, y , and current scroll in the y dimension).
+typedef struct Position {
+	uint32_t x;
+	uint32_t y;
+	uint32_t yScr;
+} Position;
+
+/// The entire normal mode state, consisting of an operation
+/// and a motion.
+struct NormalModeState {
+	Position initialPosition;
+	// Operation:
+	struct OperationState {
+		enum Operation {
+			noop,
+			visual,
+			visualLine,
+			yank
+		} op;
+		Position startPosition;
+	} command;
+	// Motions:
+	struct MotionState {
+		uint32_t amount;
+		enum Search {
+			none,
+			forward,
+			backward,
+		} search;
+		Position searchPosition;
+		bool finished;
+	} motion;
+} stateNormalMode;
+
+
+DynamicArray searchString =  UTF8_ARRAY;
+DynamicArray commandHist0 =  UTF8_ARRAY;
+DynamicArray commandHist1 =  UTF8_ARRAY;
+DynamicArray highlights   = QWORD_ARRAY;
+/// History command toggle
+bool toggle = false;
+#define currentCommand toggle ? &commandHist0 : &commandHist1
+#define lastCommand    toggle ? &commandHist1 : &commandHist0
+
 static void execsh(char *, char **);
 static void stty(char **);
 static void sigchld(int);
@@ -184,8 +242,8 @@ static void tnewline(int);
 static void tputtab(int);
 static void tputc(Rune);
 static void treset(void);
-static void tscrollup(int, int);
-static void tscrolldown(int, int);
+static void tscrollup(int, int, int);
+static void tscrolldown(int, int, int);
 static void tsetattr(int *, int);
 static void tsetchar(Rune, Glyph *, int, int);
 static void tsetdirt(int, int);
@@ -231,6 +289,12 @@ static uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
 static Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
 static Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
 
+void applyPosition(Position const *pos) {
+	term.c.x = pos->x;
+	term.c.y = pos->y;
+	term.scr = pos->yScr;
+}
+
 ssize_t
 xwrite(int fd, const char *s, size_t len)
 {
@@ -409,17 +473,22 @@ tlinelen(int y)
 {
 	int i = term.col;
 
-	if (term.line[y][i - 1].mode & ATTR_WRAP)
+	if (TLINE(y)[i - 1].mode & ATTR_WRAP)
 		return i;
 
-	while (i > 0 && term.line[y][i - 1].u == ' ')
+	while (i > 0 && TLINE(y)[i - 1].u == ' ')
 		--i;
 
 	return i;
 }
 
 void
-selstart(int col, int row, int snap)
+xselstart(int col, int row, int snap) {
+	selstart(col, row, term.scr, snap);
+}
+
+void
+selstart(int col, int row, int scroll, int snap)
 {
 	selclear();
 	sel.mode = SEL_EMPTY;
@@ -428,6 +497,7 @@ selstart(int col, int row, int snap)
 	sel.snap = snap;
 	sel.oe.x = sel.ob.x = col;
 	sel.oe.y = sel.ob.y = row;
+	sel.oe.scroll = sel.ob.scroll = scroll;
 	selnormalize();
 
 	if (sel.snap != 0)
@@ -436,10 +506,13 @@ selstart(int col, int row, int snap)
 }
 
 void
-selextend(int col, int row, int type, int done)
-{
-	int oldey, oldex, oldsby, oldsey, oldtype;
+xselextend(int col, int row, int type, int done) {
+	selextend(col, row, term.scr, type, done);
+}
 
+void
+selextend(int col, int row, int scroll, int type, int done)
+{
 	if (sel.mode == SEL_IDLE)
 		return;
 	if (done && sel.mode == SEL_EMPTY) {
@@ -447,18 +520,22 @@ selextend(int col, int row, int type, int done)
 		return;
 	}
 
-	oldey = sel.oe.y;
-	oldex = sel.oe.x;
-	oldsby = sel.nb.y;
-	oldsey = sel.ne.y;
-	oldtype = sel.type;
+	int const oldey = sel.oe.y;
+	int const oldex = sel.oe.x;
+	int const oldscroll = sel.oe.scroll;
+	int const oldsby = sel.nb.y;
+	int const oldsey = sel.ne.y;
+	int const oldtype = sel.type;
 
 	sel.oe.x = col;
 	sel.oe.y = row;
+	sel.oe.scroll = scroll;
+
 	selnormalize();
 	sel.type = type;
 
-	if (oldey != sel.oe.y || oldex != sel.oe.x || oldtype != sel.type || sel.mode == SEL_EMPTY)
+	if (oldey != sel.oe.y || oldex != sel.oe.x || oldscroll != sel.oe.scroll
+			|| oldtype != sel.type || sel.mode == SEL_EMPTY)
 		tsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey));
 
 	sel.mode = done ? SEL_IDLE : SEL_READY;
@@ -467,17 +544,21 @@ selextend(int col, int row, int type, int done)
 void
 selnormalize(void)
 {
-	int i;
-
-	if (sel.type == SEL_REGULAR && sel.ob.y != sel.oe.y) {
-		sel.nb.x = sel.ob.y < sel.oe.y ? sel.ob.x : sel.oe.x;
-		sel.ne.x = sel.ob.y < sel.oe.y ? sel.oe.x : sel.ob.x;
+	sel.nb.y = INTERVAL(sel.ob.y + term.scr - sel.ob.scroll, 0, term.bot);
+	sel.ne.y = INTERVAL(sel.oe.y + term.scr - sel.oe.scroll, 0, term.bot);
+	if (sel.type == SEL_REGULAR && sel.nb.y != sel.ne.y) {
+		sel.nb.x = sel.nb.y < sel.ne.y ? sel.ob.x : sel.oe.x;
+		sel.ne.x = sel.nb.y < sel.ne.y ? sel.oe.x : sel.ob.x;
 	} else {
 		sel.nb.x = MIN(sel.ob.x, sel.oe.x);
 		sel.ne.x = MAX(sel.ob.x, sel.oe.x);
 	}
-	sel.nb.y = MIN(sel.ob.y, sel.oe.y);
-	sel.ne.y = MAX(sel.ob.y, sel.oe.y);
+
+	if (sel.nb.y > sel.ne.y) {
+		int32_t const tmp = sel.nb.y;
+		sel.nb.y = sel.ne.y;
+		sel.ne.y = tmp;
+	}
 
 	selsnap(&sel.nb.x, &sel.nb.y, -1);
 	selsnap(&sel.ne.x, &sel.ne.y, +1);
@@ -485,7 +566,7 @@ selnormalize(void)
 	/* expand selection over line breaks */
 	if (sel.type == SEL_RECTANGULAR)
 		return;
-	i = tlinelen(sel.nb.y);
+	int i = tlinelen(sel.nb.y);
 	if (i < sel.nb.x)
 		sel.nb.x = i;
 	if (tlinelen(sel.ne.y) <= sel.ne.x)
@@ -521,7 +602,7 @@ selsnap(int *x, int *y, int direction)
 		 * Snap around if the word wraps around at the end or
 		 * beginning of a line.
 		 */
-		prevgp = &term.line[*y][*x];
+		prevgp = &TLINE(*y)[*x];
 		prevdelim = ISDELIM(prevgp->u);
 		for (;;) {
 			newx = *x + direction;
@@ -536,14 +617,14 @@ selsnap(int *x, int *y, int direction)
 					yt = *y, xt = *x;
 				else
 					yt = newy, xt = newx;
-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
+				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
 					break;
 			}
 
 			if (newx >= tlinelen(newy))
 				break;
 
-			gp = &term.line[newy][newx];
+			gp = &TLINE(newy)[newx];
 			delim = ISDELIM(gp->u);
 			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
 					|| (delim && gp->u != prevgp->u)))
@@ -564,14 +645,14 @@ selsnap(int *x, int *y, int direction)
 		*x = (direction < 0) ? 0 : term.col - 1;
 		if (direction < 0) {
 			for (; *y > 0; *y += direction) {
-				if (!(term.line[*y-1][term.col-1].mode
+				if (!(TLINE(*y-1)[term.col-1].mode
 						& ATTR_WRAP)) {
 					break;
 				}
 			}
 		} else if (direction > 0) {
 			for (; *y < term.row-1; *y += direction) {
-				if (!(term.line[*y][term.col-1].mode
+				if (!(TLINE(*y)[term.col-1].mode
 						& ATTR_WRAP)) {
 					break;
 				}
@@ -591,24 +672,32 @@ getsel(void)
 	if (sel.ob.x == -1)
 		return NULL;
 
-	bufsize = (term.col+1) * (sel.ne.y-sel.nb.y+1) * UTF_SIZ;
+	int32_t syb = sel.ob.y - sel.ob.scroll + term.scr;
+	int32_t sye = sel.oe.y - sel.oe.scroll + term.scr;
+	if (syb > sye) {
+		int32_t tmp = sye;
+		sye = syb;
+		syb = tmp;
+	}
+
+	bufsize = (term.col+1) * (sye - syb + 1) * UTF_SIZ;
 	ptr = str = xmalloc(bufsize);
 
 	/* append every set & selected glyph to the selection */
-	for (y = sel.nb.y; y <= sel.ne.y; y++) {
+	for (y = syb; y <= sye; y++) {
 		if ((linelen = tlinelen(y)) == 0) {
 			*ptr++ = '\n';
 			continue;
 		}
 
 		if (sel.type == SEL_RECTANGULAR) {
-			gp = &term.line[y][sel.nb.x];
+			gp = &TLINE(y)[sel.nb.x];
 			lastx = sel.ne.x;
 		} else {
-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
-			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
+			gp = &TLINE(y)[syb == y ? sel.nb.x : 0];
+			lastx = (sye == y) ? sel.ne.x : term.col-1;
 		}
-		last = &term.line[y][MIN(lastx, linelen-1)];
+		last = &TLINE(y)[MIN(lastx, linelen-1)];
 		while (last >= gp && last->u == ' ')
 			--last;
 
@@ -831,6 +920,9 @@ void
 ttywrite(const char *s, size_t n, int may_echo)
 {
 	const char *next;
+	Arg arg = (Arg) { .i = term.scr };
+
+	kscrolldown(&arg);
 
 	if (may_echo && IS_SET(MODE_ECHO))
 		twrite(s, n, 1);
@@ -1042,13 +1134,53 @@ tswapscreen(void)
 }
 
 void
-tscrolldown(int orig, int n)
+kscrolldown(const Arg* a)
+{
+	int n = a->i;
+
+	if (n < 0)
+		n = term.row + n;
+
+	if (n > term.scr)
+		n = term.scr;
+
+	if (term.scr > 0) {
+		term.scr -= n;
+		selscroll(0, -n);
+		tfulldirt();
+	}
+}
+
+void
+kscrollup(const Arg* a)
+{
+	int n = a->i;
+
+	if (n < 0)
+		n = term.row + n;
+
+	if (term.scr <= HISTSIZE-n) {
+		term.scr += n;
+		selscroll(0, n);
+		tfulldirt();
+	}
+}
+
+void
+tscrolldown(int orig, int n, int copyhist)
 {
 	int i;
 	Line temp;
 
 	LIMIT(n, 0, term.bot-orig+1);
 
+	if (copyhist) {
+		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+		temp = term.hist[term.histi];
+		term.hist[term.histi] = term.line[term.bot];
+		term.line[term.bot] = temp;
+	}
+
 	tsetdirt(orig, term.bot-n);
 	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
 
@@ -1062,13 +1194,23 @@ tscrolldown(int orig, int n)
 }
 
 void
-tscrollup(int orig, int n)
+tscrollup(int orig, int n, int copyhist)
 {
 	int i;
 	Line temp;
 
 	LIMIT(n, 0, term.bot-orig+1);
 
+	if (copyhist) {
+		term.histi = (term.histi + 1) % HISTSIZE;
+		temp = term.hist[term.histi];
+		term.hist[term.histi] = term.line[orig];
+		term.line[orig] = temp;
+	}
+
+	if (term.scr > 0 && term.scr < HISTSIZE)
+		term.scr = MIN(term.scr + n, HISTSIZE-1);
+
 	tclearregion(0, orig, term.col-1, orig+n-1);
 	tsetdirt(orig+n, term.bot);
 
@@ -1088,6 +1230,7 @@ selscroll(int orig, int n)
 		return;
 
 	if (BETWEEN(sel.ob.y, orig, term.bot) || BETWEEN(sel.oe.y, orig, term.bot)) {
+		sel.oe.scroll = sel.ob.scroll = term.scr;
 		if ((sel.ob.y += n) > term.bot || (sel.oe.y += n) < term.top) {
 			selclear();
 			return;
@@ -1117,13 +1260,544 @@ tnewline(int first_col)
 	int y = term.c.y;
 
 	if (y == term.bot) {
-		tscrollup(term.top, 1);
+		tscrollup(term.top, 1, 1);
 	} else {
 		y++;
 	}
 	tmoveto(first_col ? 0 : term.c.x, y);
 }
 
+int
+currentLine(int x, int y)
+{
+	return (x == term.c.x || y == term.c.y);
+}
+
+int
+highlighted(int x, int y)
+{
+	// Compute the legal bounds for a hit:
+	int32_t const stringSize = size(&searchString);
+	int32_t xMin = x - stringSize;
+	int32_t yMin = y;
+	while (xMin < 0 && yMin > 0) { //< I think this temds to be more efficient than
+		xMin += term.col;            //  division + modulo.
+		--yMin;
+	}
+	if (xMin < 0) { xMin = 0; }
+
+	uint32_t highSize = size(&highlights);
+	uint32_t *ptr = (uint32_t*) highlights.content;
+	for (uint32_t i = 0; i < highSize; ++i) {
+		int32_t const sx = *(ptr++);
+		int32_t const sy = *(ptr++);
+		if (BETWEEN(sy, yMin, y) && (sy != yMin || sx > xMin) && (sy != y || sx <= x)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+int mod(int a, int b) {
+	while (a < 0) {
+		a+= b;
+	}
+	return a % b;
+}
+
+void displayString(DynamicArray const *str, Glyph *g, int yPos) {
+	// Threshold: if there is nothing or no space to print, do not print.
+	if (term.col == 0 || str->index == 0) {
+		term.dirty[yPos] = 1; //< mark this line as 'dirty', because the line is not
+		//  marked dirty when scrolling due to string display.
+		return;
+	}
+
+	uint32_t lineSize = MIN(size(str), term.col / 3);
+	uint32_t xEnd = term.col - 1;
+	assert(lineSize <= 1 + xEnd); //< as lineSize <= term.col/3 <= term.col - 1 + 1 = xEnd + 1
+	uint32_t xStart = 1 + xEnd - lineSize;
+
+	Line line = malloc(sizeof(Glyph) * lineSize);
+	assert(str->index - 1 >=  lineSize - 1); //< lineSize <= str->index -1 direct premise.
+
+	for (uint32_t lineIdx = 0; lineIdx < lineSize; lineIdx++) {
+		line[lineIdx] = *g;
+		char* end = viewEnd(str, lineSize - lineIdx - 1);
+		memcpy(&line[lineIdx].u, end, str->itemSize);
+	}
+	xdrawline(TLINE(yPos), 0, yPos, xStart);
+	xdrawline(line -xStart, xStart, yPos, xEnd+1);
+	free(line); // that sucks.
+}
+
+/// Print either the current command or the last comman din case the current command is empty.
+void printCommandString() {
+	Glyph g = {'c', ATTR_ITALIC | ATTR_FAINT , defaultfg, defaultbg};
+	if (term.c.y == term.row-1) { g.mode ^= ATTR_CURRENT; } //< dont highlight
+	DynamicArray * cc = currentCommand;
+	displayString(isEmpty(cc) ? lastCommand : cc, &g, term.row - 1);
+	//displayString(lastCommand, &g, term.row - 2);
+}
+
+void printSearchString() {
+	Glyph g = {'c', ATTR_ITALIC | ATTR_BOLD_FAINT, defaultfg, defaultbg};
+	if (term.c.y == term.row-2) { g.mode ^= ATTR_CURRENT; } //< dont highlight
+	displayString(&searchString, &g, term.row - 2);
+}
+
+/// Default state if no operation is performed.
+struct NormalModeState defaultNormalMode = {{0,0,0}, {noop, {0, 0, 0}}, {0, none, {0, 0, 0}, false}};
+
+void enableMode(enum Operation o) {
+	stateNormalMode.command.op = o;
+	stateNormalMode.command.startPosition.x = term.c.x;
+	stateNormalMode.command.startPosition.y = term.c.y;
+	stateNormalMode.command.startPosition.yScr = term.scr;
+}
+
+bool normalModeEnabled = false;
+
+void onNormalModeStart() {
+	normalModeEnabled = true;
+}
+
+void onNormalModeStop() { //XXX breaks if resized
+	normalModeEnabled = false;
+	applyPosition(&stateNormalMode.initialPosition);
+}
+
+void moveLine(int8_t sign) {
+	if (sign == -1) {
+		if (term.c.y-- == 0) {
+			if (++term.scr == HISTSIZE) {
+				term.c.y = term.row - 1;
+				term.scr = 0;
+			} else {
+				term.c.y = 0;
+			}
+		}
+	} else {
+		term.c.x = 0;
+		if (++term.c.y == term.row) {
+			if (term.scr-- == 0) {
+				term.c.y = 0;
+				term.scr = HISTSIZE - 1;
+			} else {
+				term.c.y = term.row - 1;
+			}
+		}
+	}
+}
+
+void moveLetter(int8_t sign) {
+	term.c.x += sign;
+	if (!BETWEEN(term.c.x, 0, term.col-1)) {
+		if (term.c.x < 0) {
+			term.c.x = term.col - 1;
+			moveLine(sign);
+		} else {
+			term.c.x = 0;
+			moveLine(sign);
+		}
+	}
+}
+
+bool contains (char ksym, char const * values, uint32_t amount) {
+	for (uint32_t i = 0; i < amount; i++) { if (ksym == values[i]) { return true; } }
+	return false;
+}
+
+
+void terminateCommand(bool abort) {
+	stateNormalMode.command = defaultNormalMode.command; //< clear command + motion
+	stateNormalMode.motion  = defaultNormalMode.motion;
+	selclear();                                          //< clear selection if any
+
+	if (!abort) { toggle = !toggle; }
+	empty(currentCommand);
+
+	printCommandString();
+	printSearchString();
+	//tsetdirt(0, term.row-3);
+}
+inline void exitCommand() { terminateCommand(false); }
+inline void abortCommand() { terminateCommand(true); }
+
+/// Go to next occurrence of string relative to the current location
+/// conduct search, starting at start pos
+bool
+gotoString(int8_t sign) {
+	uint32_t findIndex = 0;
+	uint32_t searchStringSize = size(&searchString);
+	uint32_t const maxIteration = (HISTSIZE + term.row) * term.col + searchStringSize;  //< one complete traversal.
+	for (uint32_t cIteration = 0; findIndex < searchStringSize
+			&& cIteration ++ < maxIteration; moveLetter(sign)) {
+		uint32_t const searchChar = *((uint32_t*)(sign == 1 ? view(&searchString, findIndex)
+					: viewEnd(&searchString, findIndex)));
+
+		uint32_t const fu = TLINE(term.c.y)[term.c.x].u;
+
+		if (fu == searchChar) findIndex++;
+		else findIndex = 0;
+	}
+	bool const found = findIndex == searchStringSize;
+	if (found) { for (uint32_t i = 0; i < searchStringSize; i++) { moveLetter(-sign); } }
+	return found;
+}
+
+/// Find the next occurrence of a word
+bool
+gotoNextString(int8_t sign) {
+	moveLetter(sign);
+	return gotoString(sign);
+}
+
+/// Highlight all found strings on the current screen.
+void
+highlightStringOnScreen() {
+	if (isEmpty(&searchString)) { return; }
+	uint32_t const searchStringSize = size(&searchString);
+	uint32_t findIndex = 0;
+	uint32_t xStart, yStart;
+	for (uint32_t y = 0; y < term.row; y++) {
+		for (uint32_t x = 0; x < term.col; x++) {
+			if (TLINE(y)[x].u == *((uint32_t*)(view(&searchString, findIndex)))) {
+				if (findIndex++ == 0) {
+					xStart = x;
+					yStart = y;
+				}
+				if (findIndex == searchStringSize) {
+					// mark selected
+					append(&highlights, &xStart);
+					append(&highlights, &yStart);
+
+					findIndex = 0;
+					term.dirty[yStart] = 1;
+				}
+			} else {
+				findIndex = 0;
+			}
+		}
+	}
+}
+
+void gotoStringAndHighlight(int8_t sign) {
+	bool const found = gotoString(sign);  //< find the next string to the current position
+	empty(&highlights);             //< remove previous highlights
+	if (found) {                          //< apply new highlights if found
+		//if (sign == -1) { moveLetter(-1); }
+		highlightStringOnScreen(sign);
+	} else {                              //< go to the position where the search started.
+		applyPosition(&stateNormalMode.motion.searchPosition);
+	}
+	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
+	                                      //  is painted separately.
+}
+
+void pressKeys(char const* nullTerminatedString) {
+	size_t end;
+	for (size_t i = 0, end=strlen(nullTerminatedString); i < end; ++i) {
+		if (nullTerminatedString[i] == '\n') {
+			kpressNormalMode(&nullTerminatedString[i], 0, false, true, false);
+		} else {
+			kpressNormalMode(&nullTerminatedString[i], 1, false, false, false);
+		}
+	}
+}
+
+void executeCommand(DynamicArray const *command) {
+	size_t end;
+	char decoded [32];
+	for (size_t i = 0, end=size(command); i < end; ++i) {
+		size_t len = utf8encode(*((Rune*)view(command, i)) , decoded);
+		kpressNormalMode(decoded, len, false, false, false);
+	}
+	//kpressNormalMode(NULL, 0, false, true, false);
+}
+
+void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace) {
+	// [ESC] or [ENTER] abort resp. finish the current operation or
+	// the Normal Mode if no operation is currently executed.
+	if (esc || enter) {
+		if (stateNormalMode.command.op == noop
+				&& stateNormalMode.motion.search == none
+				&& stateNormalMode.motion.amount == 0) {
+			terminateCommand(!enter);
+			empty(&highlights);
+			tfulldirt(); // < this also removes the search string and the last command.
+			normalMode(NULL);
+		} else {
+			if (enter && stateNormalMode.motion.search != none && !isEmpty(&searchString)) {
+				exitCommand(); //stateNormalMode.motion.finished = true;
+				return;
+			} else {
+				abortCommand();
+			}
+		}
+		return;
+	} //< ! (esc || enter)
+	// Search: append to search string & conduct search for best hit, starting at start pos,
+	//         highlighting all other occurrences on the current page if one is found.
+	if (stateNormalMode.motion.search != none && !stateNormalMode.motion.finished) {
+		int8_t const sign = stateNormalMode.motion.search == forward ? 1 : -1;
+		// Apply start position.
+		if (backspace) { // XXX: if a quantifier is subject to removal, it is currently only removed
+			               //      from the  command string.
+			if (!isEmpty(currentCommand) && !isEmpty(&searchString)) {
+				pop(currentCommand);
+				pop(&searchString);
+			} else if (isEmpty(currentCommand) || isEmpty(&searchString)) {
+				empty(&highlights);
+				stateNormalMode.motion = defaultNormalMode .motion; //< if typed once more than there are
+				selclear();                                         //  letters, the search motion is
+				return;                                             //  terminated
+			}
+			applyPosition(&stateNormalMode.motion.searchPosition);
+		} else {
+			if (len > 0) {
+				char* kSearch = checkGetNext(&searchString);
+				utf8decode(ksym, (Rune*)(kSearch), len);
+
+				char* kCommand = checkGetNext(currentCommand);
+				utf8decode(ksym, (Rune*)(kCommand), len);
+			}
+		}
+		if (sign == -1) { moveLetter(1); }
+		gotoStringAndHighlight(sign); //< go to the next occurrence of the string and highlight
+		                              //  all occurrences currently on screen
+
+		if (stateNormalMode.command.op == visual) {
+			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
+		} else if  (stateNormalMode.command.op == visualLine) {
+			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
+		}
+		printCommandString();
+		printSearchString();
+		return;
+	}
+
+	if (len == 0) { return; }
+	// V / v or y take precedence over movement commands.
+	switch(ksym[0]) {
+		case '.':
+			{
+
+				if (!isEmpty(currentCommand)) { toggle = !toggle; empty(currentCommand); }
+				executeCommand(lastCommand);
+			}
+			return;
+		case 'y': //< Yank mode
+			{
+				char* kCommand = checkGetNext(currentCommand);
+				utf8decode(ksym, (Rune*)(kCommand), len);
+				switch(stateNormalMode.command.op) {
+					case noop:           //< Start yank mode & set #op
+						enableMode(yank);
+						selstart(term.c.x, term.c.y, term.scr, 0);
+						empty(currentCommand);
+						break;
+					case visualLine:     //< Complete yank operation
+					case visual:
+						xsetsel(getsel());     //< yank
+						xclipcopy();
+						exitCommand();         //< reset command
+						break;
+					case yank:           //< Complete yank operation as in y#amount j
+						selstart(0, term.c.y, term.scr, 0);
+						uint32_t const origY = term.c.y;
+						for (int32_t i = 0; i < MAX(stateNormalMode.motion.amount, 1) - 1; i ++) moveLine(1);
+						selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
+						xsetsel(getsel());
+						xclipcopy();
+						term.c.y = origY;
+						exitCommand();
+				}
+			}
+			printCommandString();
+			printSearchString();
+			return;
+		case 'v':                //< Visual Mode: Toggle mode.
+		case 'V':
+			{
+				enum Operation mode = ksym[0] == 'v' ? visual : visualLine;
+				bool assign = stateNormalMode.command.op != mode;
+				abortCommand();
+				if (assign) {
+					enableMode(mode);
+					char* kCommand = checkGetNext(currentCommand);
+					utf8decode(ksym, (Rune*)(kCommand), len);
+					if (mode == visualLine) {
+						selstart(0, term.c.y, term.scr, 0);
+						selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
+					} else {
+						selstart(term.c.x, term.c.y, term.scr, 0);
+					}
+				}
+			}
+			return;
+	}
+	// Perform the movement.
+	int32_t sign = -1;    //< whehter a command goes 'forward' (1) or 'backward' (-1)
+	bool discard = false; //< discard input, as it does not have a meaning.
+	switch(ksym[0]) {
+		case 'j': sign = 1;
+		case 'k':
+							term.c.y += sign * MAX(stateNormalMode.motion.amount, 1);
+							break;
+		case 'H': term.c.y = 0;            break; //< [numer]H ~ L[number]j is not supported.
+		case 'M': term.c.y = term.bot / 2; break;
+		case 'L': term.c.y = term.bot;     break; //< [numer]L ~ L[number]k is not supported.
+		case 'G':  //< a little different from vim, but in this use case the most useful translation.
+							applyPosition(&stateNormalMode.initialPosition);
+		case 'l': sign = 1;
+		case 'h':
+							{
+								int32_t const amount = term.c.x + sign * MAX(stateNormalMode.motion.amount, 1);
+								term.c.x = amount % term.col;
+								while (term.c.x < 0) { term.c.x += term.col; }
+								term.c.y += floor(1.0 * amount / term.col);
+								break;
+							}
+		case '0':
+							if (stateNormalMode.motion.amount == 0) { term.c.x = 0; }
+							else { discard = true; }
+							break;
+		case '$': term.c.x = term.col-1; break;
+		case 'w':
+		case 'W':
+		case 'e':
+		case 'E': sign = 1;
+		case 'B':
+		case 'b':
+							{
+								bool const startSpaceIsSeparator = !(ksym[0] == 'w' || ksym[0] == 'W');
+								bool const capital = ksym[0] <= 90; //< defines the word separators to use
+								char const * const wDelim = capital ? wordDelimLarge : wordDelimSmall;
+								uint32_t const wDelimLen =  strlen(wDelim);
+								bool const performOffset = startSpaceIsSeparator; //< start & end with offset.
+								uint32_t const maxIteration = (HISTSIZE + term.row) * term.col;  //< one complete traversal.
+
+								// doesn't work exactly as in vim, but I think this version is better;
+								// Linebreak is counted as 'normal' separator; hence a jump can span multiple lines here.
+								stateNormalMode.motion.amount = MAX(stateNormalMode.motion.amount, 1);
+								for (; stateNormalMode.motion.amount > 0; stateNormalMode.motion.amount--) {
+									uint8_t state = 0;
+									if (performOffset) { moveLetter(sign); }
+									for (uint32_t cIteration = 0; cIteration ++ < maxIteration; moveLetter(sign)) {
+										if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
+											if (state == 1) {
+												if (performOffset) { moveLetter(-sign); }
+												break;
+											}
+										} else if (state == 0) { state = 1; }
+									}
+								}
+								break;
+							}
+		case '/': sign = 1;
+		case '?':
+							empty(&searchString);
+							stateNormalMode.motion.search = sign == 1 ? forward : backward;
+							stateNormalMode.motion.searchPosition.x = term.c.x;
+							stateNormalMode.motion.searchPosition.y = term.c.y;
+							stateNormalMode.motion.searchPosition.yScr = term.scr;
+							stateNormalMode.motion.finished = false;
+							break;
+		case 'n': sign = 1;
+		case 'N':
+							toggle = !toggle;
+							empty(currentCommand);
+							if (stateNormalMode.motion.search == none) {
+								stateNormalMode.motion.search = forward;
+								stateNormalMode.motion.finished = true;
+							}
+							for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); amount > 0; amount--) {
+								if (stateNormalMode.motion.search == backward) { sign *= -1; }
+								moveLetter(sign);
+								gotoStringAndHighlight(sign);
+							}
+							break;
+		case 't':
+							if (sel.type == SEL_REGULAR) {
+								sel.type = SEL_RECTANGULAR;
+							} else {
+								sel.type = SEL_REGULAR;
+							}
+							tsetdirt(sel.nb.y, sel.ne.y);
+							discard = true;
+		default:
+							discard = true;
+	}
+	bool const isNumber = len == 1 && BETWEEN(ksym[0], 48, 57);
+	if (isNumber) { //< record numbers
+		discard = false;
+		stateNormalMode.motion.amount =
+			MIN(SHRT_MAX, stateNormalMode.motion.amount * 10 + ksym[0] - 48);
+	} else if (!discard) {
+		stateNormalMode.motion.amount = 0;
+	}
+
+	if (discard) {
+		for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
+			if (ksym[0] == normalModeShortcuts[i].key) {
+				pressKeys(normalModeShortcuts[i].value);
+			}
+		}
+	} else {
+		char* kCommand = checkGetNext(currentCommand);
+		utf8decode(ksym, (Rune*)(kCommand), len);
+
+		int diff = 0;
+		if (term.c.y > 0) {
+			if (term.c.y > term.bot) {
+				diff = term.bot - term.c.y;
+				term.c.y = term.bot;
+			}
+		} else {
+			if (term.c.y < 0) {
+				diff = -term.c.y;
+				term.c.y = 0;
+			}
+		}
+
+		int const _newScr = term.scr + diff;
+		term.c.y = _newScr < 0 ? 0 : (_newScr >= HISTSIZE ? term.bot : term.c.y);
+		term.scr = mod(_newScr, HISTSIZE);
+
+		if (!isEmpty(&highlights)) {
+			empty(&highlights);
+			highlightStringOnScreen();
+		}
+
+		tsetdirt(0, term.row-3);
+		printCommandString();
+		printSearchString();
+
+		if (stateNormalMode.command.op == visual) {
+			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
+		} else if  (stateNormalMode.command.op == visualLine) {
+			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
+		} else {
+			if (!isNumber && (stateNormalMode.motion.search == none
+					|| stateNormalMode.motion.finished)) {
+				toggle = !toggle;
+				empty(currentCommand);
+			}
+			if (stateNormalMode.command.op == yank) {
+				if (!isNumber && !discard) {
+					// copy
+					selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
+					xsetsel(getsel());
+					xclipcopy();
+					applyPosition(&stateNormalMode.command.startPosition);
+					exitCommand();
+				}
+			}
+		}
+	}
+}
+
 void
 csiparse(void)
 {
@@ -1176,6 +1850,10 @@ tmoveto(int x, int y)
 	term.c.state &= ~CURSOR_WRAPNEXT;
 	term.c.x = LIMIT(x, 0, term.col-1);
 	term.c.y = LIMIT(y, miny, maxy);
+	// Set the last position in order to restore after normal mode exits.
+	stateNormalMode.initialPosition.x = term.c.x;
+	stateNormalMode.initialPosition.y = term.c.y;
+	stateNormalMode.initialPosition.yScr = term.scr;
 }
 
 void
@@ -1282,14 +1960,14 @@ void
 tinsertblankline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrolldown(term.c.y, n);
+		tscrolldown(term.c.y, n, 0);
 }
 
 void
 tdeleteline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrollup(term.c.y, n);
+		tscrollup(term.c.y, n, 0);
 }
 
 int32_t
@@ -1720,11 +2398,11 @@ csihandle(void)
 		break;
 	case 'S': /* SU -- Scroll <n> line up */
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrollup(term.top, csiescseq.arg[0]);
+		tscrollup(term.top, csiescseq.arg[0], 0);
 		break;
 	case 'T': /* SD -- Scroll <n> line down */
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrolldown(term.top, csiescseq.arg[0]);
+		tscrolldown(term.top, csiescseq.arg[0], 0);
 		break;
 	case 'L': /* IL -- Insert <n> blank lines */
 		DEFAULT(csiescseq.arg[0], 1);
@@ -2227,7 +2905,7 @@ eschandle(uchar ascii)
 		return 0;
 	case 'D': /* IND -- Linefeed */
 		if (term.c.y == term.bot) {
-			tscrollup(term.top, 1);
+			tscrollup(term.top, 1, 1);
 		} else {
 			tmoveto(term.c.x, term.c.y+1);
 		}
@@ -2240,7 +2918,7 @@ eschandle(uchar ascii)
 		break;
 	case 'M': /* RI -- Reverse index */
 		if (term.c.y == term.top) {
-			tscrolldown(term.top, 1);
+			tscrolldown(term.top, 1, 1);
 		} else {
 			tmoveto(term.c.x, term.c.y-1);
 		}
@@ -2458,7 +3136,7 @@ twrite(const char *buf, int buflen, int show_ctrl)
 void
 tresize(int col, int row)
 {
-	int i;
+	int i, j;
 	int minrow = MIN(row, term.row);
 	int mincol = MIN(col, term.col);
 	int *bp;
@@ -2495,6 +3173,14 @@ tresize(int col, int row)
 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 
+	for (i = 0; i < HISTSIZE; i++) {
+		term.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));
+		for (j = mincol; j < col; j++) {
+			term.hist[i][j] = term.c.attr;
+			term.hist[i][j].u = ' ';
+		}
+	}
+
 	/* resize each row to new width, zero-pad if needed */
 	for (i = 0; i < minrow; i++) {
 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
@@ -2552,7 +3238,7 @@ drawregion(int x1, int y1, int x2, int y2)
 			continue;
 
 		term.dirty[y] = 0;
-		xdrawline(term.line[y], x1, y, x2);
+		xdrawline(TLINE(y), x1, y, x2);
 	}
 }
 
@@ -2573,8 +3259,8 @@ draw(void)
 		cx--;
 
 	drawregion(0, 0, term.col, term.row);
-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
-			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
+	xdrawcursor(cx, term.c.y, TLINE(term.c.y)[cx],
+			term.ocx, term.ocy, TLINE(term.ocy)[term.ocx]);
 	term.ocx = cx, term.ocy = term.c.y;
 	xfinishdraw();
 	xximspot(term.ocx, term.ocy);
diff --git a/st.h b/st.h
index 4da3051..7bd8bba 100644
--- a/st.h
+++ b/st.h
@@ -1,5 +1,6 @@
 /* See LICENSE for license details. */
 
+#include <stdbool.h>
 #include <stdint.h>
 #include <sys/types.h>
 
@@ -10,6 +11,8 @@
 #define BETWEEN(x, a, b)	((a) <= (x) && (x) <= (b))
 #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
 #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
+#define INTERVAL(x, a, b)		(x) < (a) ? (a) : (x) > (b) ? (b) : (x)
+#define INTERVAL_DIFF(x, a, b)		(x) < (a) ? (x) - (a) : (x) > (b) ? (x) - (b) : 0
 #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
 #define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
 				(a).bg != (b).bg)
@@ -33,6 +36,8 @@ enum glyph_attribute {
 	ATTR_WRAP       = 1 << 8,
 	ATTR_WIDE       = 1 << 9,
 	ATTR_WDUMMY     = 1 << 10,
+	ATTR_HIGHLIGHT  = 1 << 11 | ATTR_UNDERLINE,
+	ATTR_CURRENT    = 1 << 12,
 	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
 };
 
@@ -80,6 +85,14 @@ void die(const char *, ...);
 void redraw(void);
 void draw(void);
 
+int highlighted(int, int);
+int currentLine(int, int);
+void kscrolldown(const Arg *);
+void kscrollup(const Arg *);
+void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace);
+void normalMode(Arg const *);
+void onNormalModeStart();
+void onNormalModeStop();
 void printscreen(const Arg *);
 void printsel(const Arg *);
 void sendbreak(const Arg *);
@@ -99,8 +112,10 @@ void resettitle(void);
 
 void selclear(void);
 void selinit(void);
-void selstart(int, int, int);
-void selextend(int, int, int, int);
+void selstart(int, int, int, int);
+void xselstart(int, int, int);
+void selextend(int, int, int, int, int);
+void xselextend(int, int, int, int);
 int selected(int, int);
 char *getsel(void);
 
@@ -110,6 +125,8 @@ void *xmalloc(size_t);
 void *xrealloc(void *, size_t);
 char *xstrdup(char *);
 
+
+
 /* config.h globals */
 extern char *utmp;
 extern char *stty_args;
@@ -120,3 +137,13 @@ extern char *termname;
 extern unsigned int tabspaces;
 extern unsigned int defaultfg;
 extern unsigned int defaultbg;
+extern char wordDelimSmall[];
+extern char wordDelimLarge[];
+
+typedef struct NormalModeShortcuts {
+	char key;
+	char *value;
+} NormalModeShortcuts;
+
+extern NormalModeShortcuts normalModeShortcuts[];
+extern size_t const amountNormalModeShortcuts;
diff --git a/win.h b/win.h
index a6ef1b9..1a6fefe 100644
--- a/win.h
+++ b/win.h
@@ -19,6 +19,7 @@ enum win_mode {
 	MODE_MOUSEMANY   = 1 << 15,
 	MODE_BRCKTPASTE  = 1 << 16,
 	MODE_NUMLOCK     = 1 << 17,
+	MODE_NORMAL      = 1 << 18,
 	MODE_MOUSE       = MODE_MOUSEBTN|MODE_MOUSEMOTION|MODE_MOUSEX10\
 	                  |MODE_MOUSEMANY,
 };
@@ -27,6 +28,7 @@ void xbell(void);
 void xclipcopy(void);
 void xdrawcursor(int, int, Glyph, int, int, Glyph);
 void xdrawline(Line, int, int, int);
+void xdrawglyph(Glyph, int, int);
 void xfinishdraw(void);
 void xloadcols(void);
 int xsetcolorname(int, const char *);
diff --git a/x.c b/x.c
index 5828a3b..ccf1751 100644
--- a/x.c
+++ b/x.c
@@ -136,7 +136,6 @@ typedef struct {
 static inline ushort sixd_to_16bit(int);
 static int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);
 static void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);
-static void xdrawglyph(Glyph, int, int);
 static void xclear(int, int, int, int);
 static int xgeommasktogravity(int);
 static void ximopen(Display *);
@@ -340,7 +339,7 @@ mousesel(XEvent *e, int done)
 			break;
 		}
 	}
-	selextend(evcol(e), evrow(e), seltype, done);
+	xselextend(evcol(e), evrow(e), seltype, done);
 	if (done)
 		setsel(getsel(), e->xbutton.time);
 }
@@ -444,7 +443,7 @@ bpress(XEvent *e)
 		xsel.tclick2 = xsel.tclick1;
 		xsel.tclick1 = now;
 
-		selstart(evcol(e), evrow(e), snap);
+		xselstart(evcol(e), evrow(e), snap);
 	}
 }
 
@@ -730,6 +729,19 @@ xloadcolor(int i, const char *name, Color *ncolor)
 	return XftColorAllocName(xw.dpy, xw.vis, xw.cmap, name, ncolor);
 }
 
+void
+normalMode(Arg const *_)  //< the argument is just for the sake of
+                          //  adhering to the function format.
+{
+	win.mode ^= MODE_NORMAL; //< toggle normal mode via exclusive or.
+	if (win.mode & MODE_NORMAL) {
+		onNormalModeStart();
+	} else {
+		onNormalModeStop();
+	}
+}
+
+
 void
 xloadcols(void)
 {
@@ -1296,6 +1308,14 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 		base.fg = defaultattr;
 	}
 
+	if (base.mode & ATTR_HIGHLIGHT) {
+		base.bg = highlightBg;
+		base.fg = highlightFg;
+	} else if ((base.mode & ATTR_CURRENT) && (win.mode & MODE_NORMAL)) {
+		base.bg = currentBg;
+		base.fg = currentFg;
+	}
+
 	if (IS_TRUECOL(base.fg)) {
 		colfg.alpha = 0xffff;
 		colfg.red = TRUERED(base.fg);
@@ -1428,8 +1448,9 @@ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
 	Color drawcol;
 
 	/* remove the old cursor */
-	if (selected(ox, oy))
-		og.mode ^= ATTR_REVERSE;
+	if (selected(ox, oy)) og.mode ^= ATTR_REVERSE;
+	if (highlighted(ox, oy)) { og.mode ^= ATTR_HIGHLIGHT; }
+	if (currentLine(ox, oy)) { og.mode ^= ATTR_CURRENT; }
 	xdrawglyph(og, ox, oy);
 
 	if (IS_SET(MODE_HIDE))
@@ -1461,6 +1482,11 @@ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
 		drawcol = dc.col[g.bg];
 	}
 
+	if ((g.mode & ATTR_CURRENT) && (win.mode & MODE_NORMAL)) {
+		g.bg = currentBg;
+		g.fg = currentFg;
+	}
+
 	/* draw the new one */
 	if (IS_SET(MODE_FOCUSED)) {
 		switch (win.cursor) {
@@ -1550,6 +1576,12 @@ xdrawline(Line line, int x1, int y1, int x2)
 			continue;
 		if (selected(x, y1))
 			new.mode ^= ATTR_REVERSE;
+		if (highlighted(x, y1)) {
+			new.mode ^= ATTR_HIGHLIGHT;
+		}
+    if (currentLine(x, y1)) {
+			new.mode ^= ATTR_CURRENT;
+		}
 		if (i > 0 && ATTRCMP(base, new)) {
 			xdrawglyphfontspecs(specs, base, i, ox, y1);
 			specs += i;
@@ -1731,6 +1763,12 @@ kpress(XEvent *ev)
 		return;
 
 	len = XmbLookupString(xw.xic, e, buf, sizeof buf, &ksym, &status);
+	if (IS_SET(MODE_NORMAL)) {
+		kpressNormalMode(buf, strlen(buf),
+				ksym == XK_Escape, ksym == XK_Return, ksym == XK_BackSpace);
+		return;
+	}
+
 	/* 1. shortcuts */
 	for (bp = shortcuts; bp < shortcuts + LEN(shortcuts); bp++) {
 		if (ksym == bp->keysym && match(bp->mod, e->state)) {
@@ -1870,8 +1908,9 @@ run(void)
 				XNextEvent(xw.dpy, &ev);
 				if (XFilterEvent(&ev, None))
 					continue;
-				if (handler[ev.type])
+				if (handler[ev.type]) {
 					(handler[ev.type])(&ev);
+				}
 			}
 
 			draw();
-- 
2.25.0


From aae3d1c2e5437a3bd2c79ae0cb2ad6380b10adce Mon Sep 17 00:00:00 2001
From: Kevin Velghe <kevin@paretje.be>
Date: Mon, 2 Dec 2019 23:25:52 +0100
Subject: [PATCH 02/23] Merge contribution of paretje: fix underlined text

https://github.com/juliusHuelsmann/st/issues/13
---
 st.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/st.h b/st.h
index 7bd8bba..4a78440 100644
--- a/st.h
+++ b/st.h
@@ -36,8 +36,8 @@ enum glyph_attribute {
 	ATTR_WRAP       = 1 << 8,
 	ATTR_WIDE       = 1 << 9,
 	ATTR_WDUMMY     = 1 << 10,
-	ATTR_HIGHLIGHT  = 1 << 11 | ATTR_UNDERLINE,
-	ATTR_CURRENT    = 1 << 12,
+	ATTR_HIGHLIGHT  = 1 << 12,
+	ATTR_CURRENT    = 1 << 13,
 	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
 };
 
-- 
2.25.0


From 6d9f029c9adf9724f0668d0aa18cdb865f7a42a3 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Wed, 18 Dec 2019 17:09:30 +0100
Subject: [PATCH 03/23] chore: add option to the default config

---
 config.def.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/config.def.h b/config.def.h
index 1b0e501..6c3fe85 100644
--- a/config.def.h
+++ b/config.def.h
@@ -478,6 +478,8 @@ struct NormalModeShortcuts normalModeShortcuts [] = {
 	{ 'c', "/Building\n" },
 	{ 'F', "?: error:\n" },
 	{ 'f', "/: error:\n" },
+	{ 'Q', "?[Leaving vim, starting execution]\n" },
+	{ 'S', "Qf" },
 	{ 'X', "?juli@machine\n" },
 	{ 'x', "/juli@machine\n" },
 };
-- 
2.25.0


From b7467401ef62a02063b08d9d99b5aa241a82e952 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 3 Feb 2020 17:18:55 +0100
Subject: [PATCH 04/23] feat: 'i' as <ESC> alternative

Soft exit (by typing "i") transitions from normal mode into insert mode,
if no operation is currently active.

Closes #14
---
 st.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/st.c b/st.c
index 27bfca8..fbcca52 100644
--- a/st.c
+++ b/st.c
@@ -1519,7 +1519,9 @@ void executeCommand(DynamicArray const *command) {
 void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace) {
 	// [ESC] or [ENTER] abort resp. finish the current operation or
 	// the Normal Mode if no operation is currently executed.
-	if (esc || enter) {
+	// #softEsc i acts like esc in case no operation is currently performed.
+	bool const softEsc = (len == 1 && ksym[0] == 'i');
+	if (esc || enter || softEsc) {
 		if (stateNormalMode.command.op == noop
 				&& stateNormalMode.motion.search == none
 				&& stateNormalMode.motion.amount == 0) {
@@ -1527,15 +1529,16 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 			empty(&highlights);
 			tfulldirt(); // < this also removes the search string and the last command.
 			normalMode(NULL);
-		} else {
+			return;
+		} else if (!softEsc) {
 			if (enter && stateNormalMode.motion.search != none && !isEmpty(&searchString)) {
 				exitCommand(); //stateNormalMode.motion.finished = true;
 				return;
 			} else {
 				abortCommand();
 			}
+			return;
 		}
-		return;
 	} //< ! (esc || enter)
 	// Search: append to search string & conduct search for best hit, starting at start pos,
 	//         highlighting all other occurrences on the current page if one is found.
-- 
2.25.0


From 970699f4b42f6eb7d1c07e68cd511babd58e1bf2 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Tue, 4 Feb 2020 13:14:13 +0100
Subject: [PATCH 05/23] feat: Contribute to [op]i[mot] feature

Contributes to #10
---
 dynamicArray.h |  48 ++++++---
 st.c           | 265 +++++++++++++++++++++++++++++++++++++++----------
 st.h           |  15 ++-
 3 files changed, 258 insertions(+), 70 deletions(-)

diff --git a/dynamicArray.h b/dynamicArray.h
index c65fbef..c98a029 100644
--- a/dynamicArray.h
+++ b/dynamicArray.h
@@ -1,3 +1,6 @@
+#ifndef DYNAMIC_ARRAY_H
+#define DYNAMIC_ARRAY_H
+
 #include <stdint.h>
 #include <assert.h>
 #include <stdlib.h>
@@ -25,48 +28,49 @@ typedef struct DynamicArray {
 #define UTF8_ARRAY  DWORD_ARRAY
 
 
-inline char*
+static inline char*
 gnext(DynamicArray *s) { return &s->content[s->index+=s->itemSize]; }
 
-inline char*
+static inline char*
 get(DynamicArray const * s) { return &s->content[s->index]; }
 
-inline char*
+static inline char*
 view(DynamicArray const * s, uint32_t i) {
 	return s->content + i*s->itemSize;
 }
 
-inline char *
+static inline char *
 viewEnd(DynamicArray const *s, uint32_t i) {
 	return s->content + s->index - (i + 1) * s->itemSize;
 }
 
-inline void
-set(DynamicArray* s, char const *vals, uint8_t amount) {
-	assert(amount <= s->itemSize);
+static inline void
+set(DynamicArray* s, char const *vals, uint32_t amount) {
 	memcpy(s->content + s->index, vals, amount);
 }
 
-inline void
-snext(DynamicArray* s, char const *vals, uint8_t amount) {
+static inline void
+snext(DynamicArray* s, char const *vals, uint32_t amount) {
 	set(s, vals, amount);
-	s->index+=s->itemSize;
+	uint8_t const rest = amount % s->itemSize;
+	s->index+= amount + (rest ? s->itemSize : 0);
 }
 
-inline void
+static inline void
 empty(DynamicArray* s) { s->index = 0; }
 
-inline bool
+static inline bool
 isEmpty(DynamicArray* s) { return s->index == 0; }
 
-inline uint32_t
+static inline uint32_t
 size(DynamicArray const * s) { return s->index / s->itemSize; }
 
-inline void
+static inline void
 pop(DynamicArray* s) { s->index -= s->itemSize; }
 
-inline void checkSetNext(DynamicArray *s, char const *c, uint8_t amount) {
-	if (s->index + s->itemSize >= s->allocated) {
+
+static inline void checkSetNext(DynamicArray *s, char const *c, uint32_t amount) {
+	while (s->index + s->itemSize * amount >= s->allocated) {
 		if ((s->content = (char *)realloc(
 						s->content, s->allocated += EXPAND_STEP * s->itemSize)) == NULL) {
 			exit(1);
@@ -75,6 +79,15 @@ inline void checkSetNext(DynamicArray *s, char const *c, uint8_t amount) {
 	if (amount) { snext(s, c, amount); }
 }
 
+static inline void checkSetNextV(DynamicArray *s, char const c) {
+	checkSetNext(s, &c, 1);
+}
+
+static inline void checkSetNextP(DynamicArray *s, char const *c) {
+	checkSetNext(s, c, strlen(c));
+}
+
+
 char *checkGetNext(DynamicArray *s) {
 	if (s->index + s->itemSize >= s->allocated) {
 		if ((s->content = (char *)realloc(
@@ -88,3 +101,6 @@ char *checkGetNext(DynamicArray *s) {
 
 #define append(s, c) checkSetNext((s), (char const *) (c), (s)->itemSize)
 #define appendPartial(s, c, i) checkSetNext((s), (char const *) (c), (i))
+
+
+#endif // DYNAMIC_ARRAY_H
diff --git a/st.c b/st.c
index fbcca52..d579569 100644
--- a/st.c
+++ b/st.c
@@ -180,12 +180,13 @@ struct NormalModeState {
 	// Operation:
 	struct OperationState {
 		enum Operation {
-			noop,
-			visual,
-			visualLine,
-			yank
+			noop = ' ',
+			visual = 'v',
+			visualLine = 'V',
+			yank = 'y'
 		} op;
 		Position startPosition;
+		uint8_t inner;
 	} command;
 	// Motions:
 	struct MotionState {
@@ -200,6 +201,9 @@ struct NormalModeState {
 	} motion;
 } stateNormalMode;
 
+/// Default state if no operation is performed.
+struct NormalModeState defaultNormalMode = {{0,0,0}, {noop, {0, 0, 0}, false}, {0, none, {0, 0, 0}, false}};
+
 
 DynamicArray searchString =  UTF8_ARRAY;
 DynamicArray commandHist0 =  UTF8_ARRAY;
@@ -1346,11 +1350,10 @@ void printSearchString() {
 	displayString(&searchString, &g, term.row - 2);
 }
 
-/// Default state if no operation is performed.
-struct NormalModeState defaultNormalMode = {{0,0,0}, {noop, {0, 0, 0}}, {0, none, {0, 0, 0}, false}};
 
 void enableMode(enum Operation o) {
 	stateNormalMode.command.op = o;
+	stateNormalMode.command.inner = 0;
 	stateNormalMode.command.startPosition.x = term.c.x;
 	stateNormalMode.command.startPosition.y = term.c.y;
 	stateNormalMode.command.startPosition.yScr = term.scr;
@@ -1409,20 +1412,23 @@ bool contains (char ksym, char const * values, uint32_t amount) {
 }
 
 
-void terminateCommand(bool abort) {
-	stateNormalMode.command = defaultNormalMode.command; //< clear command + motion
+void terminateCommand(bool abort, bool both) {
+	bool const exitMotion = both || (stateNormalMode.motion.search == none);
 	stateNormalMode.motion  = defaultNormalMode.motion;
-	selclear();                                          //< clear selection if any
-
-	if (!abort) { toggle = !toggle; }
-	empty(currentCommand);
+	
+	if (exitMotion) {
+		stateNormalMode.command = defaultNormalMode.command;
+		selclear();
+		if (!abort) { toggle = !toggle; }
+		empty(currentCommand);
+	}
 
 	printCommandString();
 	printSearchString();
 	//tsetdirt(0, term.row-3);
 }
-inline void exitCommand() { terminateCommand(false); }
-inline void abortCommand() { terminateCommand(true); }
+static inline void exitCommand(bool motion) { terminateCommand(false, motion); }
+static inline void abortCommand() { terminateCommand(true, true); }
 
 /// Go to next occurrence of string relative to the current location
 /// conduct search, starting at start pos
@@ -1431,6 +1437,7 @@ gotoString(int8_t sign) {
 	uint32_t findIndex = 0;
 	uint32_t searchStringSize = size(&searchString);
 	uint32_t const maxIteration = (HISTSIZE + term.row) * term.col + searchStringSize;  //< one complete traversal.
+	moveLetter(sign);
 	for (uint32_t cIteration = 0; findIndex < searchStringSize
 			&& cIteration ++ < maxIteration; moveLetter(sign)) {
 		uint32_t const searchChar = *((uint32_t*)(sign == 1 ? view(&searchString, findIndex)
@@ -1482,7 +1489,7 @@ highlightStringOnScreen() {
 	}
 }
 
-void gotoStringAndHighlight(int8_t sign) {
+bool gotoStringAndHighlight(int8_t sign) {
 	bool const found = gotoString(sign);  //< find the next string to the current position
 	empty(&highlights);             //< remove previous highlights
 	if (found) {                          //< apply new highlights if found
@@ -1493,51 +1500,151 @@ void gotoStringAndHighlight(int8_t sign) {
 	}
 	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
 	                                      //  is painted separately.
+	return found;
 }
 
-void pressKeys(char const* nullTerminatedString) {
-	size_t end;
-	for (size_t i = 0, end=strlen(nullTerminatedString); i < end; ++i) {
+bool pressKeys(char const* nullTerminatedString, size_t end) {
+        bool succ = true;
+	for (size_t i = 0; i < end && succ; ++i) {
 		if (nullTerminatedString[i] == '\n') {
-			kpressNormalMode(&nullTerminatedString[i], 0, false, true, false);
+			succ = kpressNormalMode(&nullTerminatedString[i], 0, false, true, false);
 		} else {
-			kpressNormalMode(&nullTerminatedString[i], 1, false, false, false);
+			succ = kpressNormalMode(&nullTerminatedString[i], 1, false, false, false);
 		}
 	}
+	return succ;
 }
 
-void executeCommand(DynamicArray const *command) {
-	size_t end;
+bool executeCommand(DynamicArray const *command) {
+	size_t end=size(command);
 	char decoded [32];
-	for (size_t i = 0, end=size(command); i < end; ++i) {
+	bool success = true;
+	for (size_t i = 0; i < end && success; ++i) {
 		size_t len = utf8encode(*((Rune*)view(command, i)) , decoded);
-		kpressNormalMode(decoded, len, false, false, false);
+		success = kpressNormalMode(decoded, len, false, false, false);
 	}
+	return success;
 	//kpressNormalMode(NULL, 0, false, true, false);
 }
 
-void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace) {
+struct {
+	char const first; 
+	char const second;
+} const Brackets [] = {
+	{'(', ')'},
+	{'<', '>'},
+	{'{', '}'},
+	{'[', ']'},
+};
+
+
+/// Emits Command prefix and suffix when i motion is performed (e.g. yiw).
+/// 
+/// @param c:             motion character
+/// @param expandMode:    1 for 'i', 2 for 'a'
+/// @param first, second: Dynamic arrays in which the prefix and postfix
+///                       commands will be returned
+/// @return               whether the command could be extracted successfully. 
+bool expandExpression(char const c, char expandMode, 
+		DynamicArray *first, DynamicArray *second) {
+	empty(first);
+	empty(second);
+	// Motions
+	char const lower = tolower(c);
+	if (lower == 'w') {
+		// translated into wb[command]e resp. WB[command]E, which works
+		// file even when at the fist letter. Does not work for single
+		// letter words though.
+		int const diff = c - lower;
+		checkSetNextV(first, c);
+		checkSetNextV(first, (signed char)(((int)'b') + diff));
+		checkSetNextV(second, (signed char)(((int)'e') + diff));
+		return true;
+	}
+	// Symmetrical brackets (quotation marks)
+	if (c == '\'' || c == '"') {
+		if (TLINE(term.c.y)[term.c.x].u  == c) {
+			// Local ambiguity -> do nothing. It cannot be
+			// determined if the current character is the first
+			// character of the selection or the second one.
+			//  <---- search here? -- ['] -- or search here? --->
+			return false;
+		}
+		// ?[c]\nl
+		char res [] = {'?', c, '\n'};
+		checkSetNextP(first, res);
+		checkSetNextV(expandMode == 1 ? first : second, 'l');
+		res[0] = '/';
+		checkSetNextP(second, res);
+		if (expandMode == 1) { checkSetNextV(second, 'h'); }
+		return true;
+	}
+	// Brackets: Does not if in range / if the brackets belong togehter.
+	for (int pid = 0; pid < sizeof(Brackets); ++pid) {
+		if(Brackets[pid].first == c || Brackets[pid].second == c) {
+			if (TLINE(term.c.y)[term.c.x].u  == Brackets[pid].first) {
+				checkSetNextV(first, 'l');
+			}
+			checkSetNextV(first, '?');
+			checkSetNextV(first, Brackets[pid].first);
+			checkSetNextV(first, '\n');
+			checkSetNextV(expandMode == 1 ? first : second, 'l');
+			checkSetNextV(second, '/');
+			checkSetNextV(second, Brackets[pid].second);
+			checkSetNextV(second, '\n');
+			if (expandMode == 1) { checkSetNextV(second, 'h'); }
+			return true;
+		}
+	}
+	// search string
+	// complicated search operation: <tag>
+	if (c == 't') {
+		// XXX: (Bug in vim: @vit )
+		// <tag_name attr="hier" a2="\<sch\>"> [current pos] </tag_name>
+		
+		// 1. Copy history ( tag := hist[?<\n:/ \n] )
+		// 2. Copy history ( first_find := hist[?<\n: next place in 
+		//                   history where count '>' > count '<'
+		//                   (can be behind current pos) )
+		// 3. first := [?first_find][#first_ind]l
+		//    second:= [/tag">"]h
+		//return true; // XXX: not implmented yet.
+	}
+	return false;
+}
+
+
+
+bool kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace) {
 	// [ESC] or [ENTER] abort resp. finish the current operation or
 	// the Normal Mode if no operation is currently executed.
 	// #softEsc i acts like esc in case no operation is currently performed.
 	bool const softEsc = (len == 1 && ksym[0] == 'i');
 	if (esc || enter || softEsc) {
-		if (stateNormalMode.command.op == noop
+		if (stateNormalMode.command.op == yank) {
+			printf("\nyank\n");
+			// copy
+			selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
+			xsetsel(getsel());
+			xclipcopy();
+			applyPosition(&stateNormalMode.command.startPosition);
+			exitCommand(true);
+		} else if (stateNormalMode.command.op == noop
 				&& stateNormalMode.motion.search == none
 				&& stateNormalMode.motion.amount == 0) {
-			terminateCommand(!enter);
+			terminateCommand(!enter, true);
 			empty(&highlights);
 			tfulldirt(); // < this also removes the search string and the last command.
 			normalMode(NULL);
-			return;
+			return true;
 		} else if (!softEsc) {
 			if (enter && stateNormalMode.motion.search != none && !isEmpty(&searchString)) {
-				exitCommand(); //stateNormalMode.motion.finished = true;
-				return;
+				exitCommand(false);
+				return true;
 			} else {
 				abortCommand();
 			}
-			return;
+			return true;
 		}
 	} //< ! (esc || enter)
 	// Search: append to search string & conduct search for best hit, starting at start pos,
@@ -1554,7 +1661,7 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 				empty(&highlights);
 				stateNormalMode.motion = defaultNormalMode .motion; //< if typed once more than there are
 				selclear();                                         //  letters, the search motion is
-				return;                                             //  terminated
+				return true;                                             //  terminated
 			}
 			applyPosition(&stateNormalMode.motion.searchPosition);
 		} else {
@@ -1566,9 +1673,8 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 				utf8decode(ksym, (Rune*)(kCommand), len);
 			}
 		}
-		if (sign == -1) { moveLetter(1); }
-		gotoStringAndHighlight(sign); //< go to the next occurrence of the string and highlight
-		                              //  all occurrences currently on screen
+		//if (sign == -1) { moveLetter(1); }
+		bool const result = gotoStringAndHighlight(sign);
 
 		if (stateNormalMode.command.op == visual) {
 			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
@@ -1577,19 +1683,70 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 		}
 		printCommandString();
 		printSearchString();
-		return;
+		return result;
+	}
+
+	if (len == 0) { return false; }
+
+	// 'i' mode enabled, hence the expression is to be expanded:
+	// [start_expression(ksym[0])] [operation] [stop_expression(ksym[0])]
+	if (stateNormalMode.command.inner) {
+		DynamicArray prefix = CHAR_ARRAY; 
+		DynamicArray suffix = CHAR_ARRAY; 
+		bool const found = expandExpression(ksym[0], 
+		        stateNormalMode.command.inner, &prefix, &suffix);
+		if (!found) { 
+			stateNormalMode.command.inner = 0;
+			free(prefix.content);
+			free(suffix.content);
+			return false; 
+		}
+
+		char const operation = stateNormalMode.command.op;
+		struct NormalModeState const st = stateNormalMode;
+		TCursor const tc = term.c;
+		stateNormalMode.command.op = noop;
+		stateNormalMode.command.inner = 0;
+
+		bool succ = true;
+		for (size_t i = 0; i < size(&prefix) && succ; ++i) {
+			succ = pressKeys(&prefix.content[i], 1);
+			//printf("%c", prefix.content[i]);
+		}
+		if (succ) { 
+			kpressNormalMode(&operation, 1, 0, 0, 0); 
+			//printf("%c", operation);
+		}
+		for (size_t i = 0; i < size(&suffix) && succ; ++i) {
+			succ = pressKeys(&suffix.content[i], 1);
+			//printf("%c", suffix.content[i]);
+		}
+
+		if (!succ) { // go back to the old position, apply op
+			stateNormalMode = st;
+			term.c = tc;
+			//printf("\nnot successful\n");
+		}
+
+		free(prefix.content);
+		free(suffix.content);
+		return succ;
 	}
 
-	if (len == 0) { return; }
+
 	// V / v or y take precedence over movement commands.
 	switch(ksym[0]) {
 		case '.':
 			{
-
 				if (!isEmpty(currentCommand)) { toggle = !toggle; empty(currentCommand); }
-				executeCommand(lastCommand);
+				return executeCommand(lastCommand);
 			}
-			return;
+		case 'i': 
+			stateNormalMode.command.inner = 1;
+			return true;
+		case 'a': 
+			stateNormalMode.command.inner = 2;
+			return true;
 		case 'y': //< Yank mode
 			{
 				char* kCommand = checkGetNext(currentCommand);
@@ -1604,7 +1761,7 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 					case visual:
 						xsetsel(getsel());     //< yank
 						xclipcopy();
-						exitCommand();         //< reset command
+						exitCommand(true);         //< reset command
 						break;
 					case yank:           //< Complete yank operation as in y#amount j
 						selstart(0, term.c.y, term.scr, 0);
@@ -1614,12 +1771,12 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 						xsetsel(getsel());
 						xclipcopy();
 						term.c.y = origY;
-						exitCommand();
+						exitCommand(true);
 				}
 			}
 			printCommandString();
 			printSearchString();
-			return;
+			return true;
 		case 'v':                //< Visual Mode: Toggle mode.
 		case 'V':
 			{
@@ -1638,11 +1795,12 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 					}
 				}
 			}
-			return;
+			return true;
 	}
 	// Perform the movement.
 	int32_t sign = -1;    //< whehter a command goes 'forward' (1) or 'backward' (-1)
 	bool discard = false; //< discard input, as it does not have a meaning.
+	bool success = true;
 	switch(ksym[0]) {
 		case 'j': sign = 1;
 		case 'k':
@@ -1699,7 +1857,7 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 								break;
 							}
 		case '/': sign = 1;
-		case '?':
+		case '?': 
 							empty(&searchString);
 							stateNormalMode.motion.search = sign == 1 ? forward : backward;
 							stateNormalMode.motion.searchPosition.x = term.c.x;
@@ -1715,10 +1873,10 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 								stateNormalMode.motion.search = forward;
 								stateNormalMode.motion.finished = true;
 							}
-							for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); amount > 0; amount--) {
-								if (stateNormalMode.motion.search == backward) { sign *= -1; }
-								moveLetter(sign);
-								gotoStringAndHighlight(sign);
+							if (stateNormalMode.motion.search == backward) { sign *= -1; }
+							for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); success && amount > 0; amount--) {
+								//moveLetter(sign);
+								success = gotoStringAndHighlight(sign);
 							}
 							break;
 		case 't':
@@ -1744,7 +1902,7 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 	if (discard) {
 		for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
 			if (ksym[0] == normalModeShortcuts[i].key) {
-				pressKeys(normalModeShortcuts[i].value);
+				success = pressKeys(normalModeShortcuts[i].value, strlen(normalModeShortcuts[i].value));
 			}
 		}
 	} else {
@@ -1788,17 +1946,18 @@ void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, boo
 				empty(currentCommand);
 			}
 			if (stateNormalMode.command.op == yank) {
-				if (!isNumber && !discard) {
+				if (!isNumber && !discard && stateNormalMode.motion.search == none) {
 					// copy
 					selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
 					xsetsel(getsel());
 					xclipcopy();
 					applyPosition(&stateNormalMode.command.startPosition);
-					exitCommand();
+					exitCommand(true);
 				}
 			}
 		}
 	}
+	return success;
 }
 
 void
@@ -2963,7 +3122,7 @@ tputc(Rune u)
 {
 	char c[UTF_SIZ];
 	int control;
-	int width, len;
+	int width = 0, len;
 	Glyph *gp;
 
 	control = ISCONTROL(u);
diff --git a/st.h b/st.h
index 4a78440..76b4dca 100644
--- a/st.h
+++ b/st.h
@@ -89,7 +89,7 @@ int highlighted(int, int);
 int currentLine(int, int);
 void kscrolldown(const Arg *);
 void kscrollup(const Arg *);
-void kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace);
+bool kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace);
 void normalMode(Arg const *);
 void onNormalModeStart();
 void onNormalModeStop();
@@ -147,3 +147,16 @@ typedef struct NormalModeShortcuts {
 
 extern NormalModeShortcuts normalModeShortcuts[];
 extern size_t const amountNormalModeShortcuts;
+
+/*[OP]i[Letter] <=> [Letter-start-target][OP][Ltter-stop-target]
+typedef struct {
+	char a;
+	char c;
+} keyCounterparts = {
+	{ '(', ')', "?" },
+	{ '<', '>' },
+	{ '{', '}' },
+	{ '[', ']' },
+	
+};
+*/
-- 
2.25.0


From dd188c38e326db88c8e8122285b8c9ed9cb9c475 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Wed, 5 Feb 2020 01:12:17 +0100
Subject: [PATCH 06/23] feat: Contribute to [op]i[mot] feature

Contributes to #10
---
 Makefile       |   8 +-
 config.def.h   |   6 +
 dynamicArray.h |   4 +-
 glyph.h        |  30 ++
 normalMode.c   | 818 +++++++++++++++++++++++++++++++++++++++++++++++++
 normalMode.h   |  36 +++
 st.c           | 806 +-----------------------------------------------
 st.h           |  55 +---
 term.h         |  73 +++++
 x.c            |  25 +-
 10 files changed, 991 insertions(+), 870 deletions(-)
 create mode 100644 glyph.h
 create mode 100644 normalMode.c
 create mode 100644 normalMode.h
 create mode 100644 term.h

diff --git a/Makefile b/Makefile
index 7d93347..92cdc6f 100644
--- a/Makefile
+++ b/Makefile
@@ -4,7 +4,7 @@
 
 include config.mk
 
-SRC = st.c x.c
+SRC = st.c x.c normalMode.c
 OBJ = $(SRC:.c=.o)
 
 all: options st
@@ -21,8 +21,8 @@ config.h:
 .c.o:
 	$(CC) $(STCFLAGS) -c $<
 
-st.o: config.h st.h win.h dynamicArray.h
-x.o: arg.h config.h st.h win.h dynamicArray.h
+st.o: config.h st.h win.h dynamicArray.h normalMode.h term.h glyph.h
+x.o: arg.h config.h st.h win.h dynamicArray.h normalMode.h term.h glyph.h
 
 $(OBJ): config.h config.mk
 
@@ -35,7 +35,7 @@ clean:
 dist: clean
 	mkdir -p st-$(VERSION)
 	cp -R FAQ LEGACY TODO LICENSE Makefile README config.mk\
-		config.def.h st.info st.1 arg.h st.h win.h dynamicArray.h $(SRC)\
+		config.def.h st.info st.1 arg.h st.h win.h dynamicArray.h normalMode.h term.h $(SRC)\
 		st-$(VERSION)
 	tar -cf - st-$(VERSION) | gzip > st-$(VERSION).tar.gz
 	rm -rf st-$(VERSION)
diff --git a/config.def.h b/config.def.h
index 6c3fe85..41b3626 100644
--- a/config.def.h
+++ b/config.def.h
@@ -485,3 +485,9 @@ struct NormalModeShortcuts normalModeShortcuts [] = {
 };
 
 size_t const amountNormalModeShortcuts = sizeof(normalModeShortcuts) / sizeof(*normalModeShortcuts);
+
+/// Style of the command string visualized in normal mode in the right corner.
+Glyph const styleCommand = {'c', ATTR_ITALIC | ATTR_FAINT, 7, 0};
+
+/// Style of the search string visualized in normal mode in the right corner.
+Glyph const styleSearch = {'c', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 0};
diff --git a/dynamicArray.h b/dynamicArray.h
index c98a029..9473219 100644
--- a/dynamicArray.h
+++ b/dynamicArray.h
@@ -62,7 +62,7 @@ empty(DynamicArray* s) { s->index = 0; }
 static inline bool
 isEmpty(DynamicArray* s) { return s->index == 0; }
 
-static inline uint32_t
+static inline int
 size(DynamicArray const * s) { return s->index / s->itemSize; }
 
 static inline void
@@ -88,7 +88,7 @@ static inline void checkSetNextP(DynamicArray *s, char const *c) {
 }
 
 
-char *checkGetNext(DynamicArray *s) {
+static char *checkGetNext(DynamicArray *s) {
 	if (s->index + s->itemSize >= s->allocated) {
 		if ((s->content = (char *)realloc(
 						s->content, s->allocated += EXPAND_STEP * s->itemSize)) == NULL) {
diff --git a/glyph.h b/glyph.h
new file mode 100644
index 0000000..84aa252
--- /dev/null
+++ b/glyph.h
@@ -0,0 +1,30 @@
+#ifndef LINE_H
+#define LINE_H
+
+//
+// Contains the representation of the entities in the buffer (Line, Gylph), that
+// is used by every part of the software implmeneting terminal logic.
+//
+
+#include <stdint.h>
+
+enum selection_type {
+	SEL_REGULAR = 1,
+	SEL_RECTANGULAR = 2
+};
+
+typedef uint_least32_t Rune;
+
+#define Glyph Glyph_
+
+typedef struct {
+	Rune u;           /* character code */
+	unsigned short mode;      /* attribute flags */
+	uint32_t fg;      /* foreground  */
+	uint32_t bg;      /* background  */
+} Glyph;
+
+
+typedef Glyph *Line;
+
+#endif // LINE_H
diff --git a/normalMode.c b/normalMode.c
new file mode 100644
index 0000000..8033a0b
--- /dev/null
+++ b/normalMode.c
@@ -0,0 +1,818 @@
+/* See LICENSE for license details. */
+#include "normalMode.h"
+#include "dynamicArray.h"
+#include "term.h"
+#include "win.h"
+
+#include <ctype.h>
+#include <stdio.h>
+#include <limits.h>
+#include <math.h>
+
+#define MIN(a, b)		((a) < (b) ? (a) : (b))
+#define MAX(a, b)		((a) < (b) ? (b) : (a))
+#define LEN(a)			(sizeof(a) / sizeof(a)[0])
+#define BETWEEN(x, a, b)	((a) <= (x) && (x) <= (b))
+#define FALLTHROUGH		__attribute__((fallthrough));
+
+// Config
+extern Glyph const styleCommand;
+extern Glyph const styleSearch;
+extern NormalModeShortcuts normalModeShortcuts[];
+extern size_t const amountNormalModeShortcuts;
+extern char wordDelimSmall[];
+extern char wordDelimLarge[];
+
+extern void selclear(void);
+extern void tsetdirt(int, int);
+extern size_t utf8encode(Rune, char *);
+extern size_t utf8decode(const char *, Rune *, size_t);
+
+extern void selextend(int, int, int, int, int);
+extern void selstart(int, int, int, int);
+extern char *getsel(void);
+extern void tfulldirt(void);
+
+
+/// Position (x, y , and current scroll in the y dimension).
+typedef struct {
+	uint32_t x;
+	uint32_t y;
+	uint32_t yScr;
+} Position;
+
+static void applyPosition(Position const *pos) {
+	term.c.x = pos->x;
+	term.c.y = pos->y;
+	term.scr = pos->yScr;
+}
+
+
+
+/// The entire normal mode state, consisting of an operation
+/// and a motion.
+typedef struct {
+	Position initialPosition;
+	// Operation:
+	struct OperationState {
+		enum Operation {
+			noop = ' ',
+			visual = 'v',
+			visualLine = 'V',
+			yank = 'y'
+		} op;
+		Position startPosition;
+		enum Infix {
+			infix_none = 0,
+			infix_i = 1,
+			infix_a = 2,
+		} infix;
+	} command;
+	// Motions:
+	struct MotionState {
+		uint32_t amount;
+		enum Search {
+			none,
+			forward,
+			backward,
+		} search;
+		Position searchPosition;
+		bool finished;
+	} motion;
+} NormalModeState;
+
+NormalModeState defaultNormalMode = {
+	{0,0,0}, 
+	{noop, {0, 0, 0}, false}, 
+	{0, none, {0, 0, 0}, true}
+};
+
+/// Default state if no operation is performed.
+NormalModeState stateNormalMode = {
+	{0,0,0}, 
+	{noop, {0, 0, 0}, false}, 
+	{0, none, {0, 0, 0}, true}
+};
+
+static inline int getSearchDirection(void) {
+	return stateNormalMode.motion.search == forward ? 1 : -1;
+}
+
+
+DynamicArray searchString =  UTF8_ARRAY;
+DynamicArray commandHist0 =  UTF8_ARRAY;
+DynamicArray commandHist1 =  UTF8_ARRAY;
+DynamicArray highlights   = QWORD_ARRAY;
+
+
+/// History command toggle
+bool toggle = false;
+#define currentCommand toggle ? &commandHist0 : &commandHist1
+#define lastCommand    toggle ? &commandHist1 : &commandHist0
+
+
+int
+highlighted(int x, int y)
+{
+	// Compute the legal bounds for a hit:
+	int32_t const stringSize = size(&searchString);
+	int32_t xMin = x - stringSize;
+	int32_t yMin = y;
+	while (xMin < 0 && yMin > 0) { //< I think this temds to be more efficient than
+		xMin += term.col;            //  division + modulo.
+		--yMin;
+	}
+	if (xMin < 0) { xMin = 0; }
+
+	uint32_t highSize = size(&highlights);
+	uint32_t *ptr = (uint32_t*) highlights.content;
+	for (uint32_t i = 0; i < highSize; ++i) {
+		int32_t const sx = *(ptr++);
+		int32_t const sy = *(ptr++);
+		if (BETWEEN(sy, yMin, y) && (sy != yMin || sx > xMin) && (sy != y || sx <= x)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+static inline int mod(int a, int b) {
+	for (;a < 0; a+=b);
+	return a % b;
+}
+
+static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
+	// Threshold: if there is nothing or no space to print, do not print.
+	if (term.col == 0 || str->index == 0) {
+		term.dirty[yPos] = 1; //< mark this line as 'dirty', because the line is not
+		//  marked dirty when scrolling due to string display.
+		return;
+	}
+
+	uint32_t lineSize = MIN(size(str), term.col / 3);
+	uint32_t xEnd = term.col - 1;
+	assert(lineSize <= 1 + xEnd); //< as lineSize <= term.col/3 <= term.col - 1 + 1 = xEnd + 1
+	uint32_t xStart = 1 + xEnd - lineSize;
+
+	Line line = malloc(sizeof(Glyph) * lineSize);
+	assert(str->index - 1 >=  lineSize - 1); //< lineSize <= str->index -1 direct premise.
+
+	for (uint32_t lineIdx = 0; lineIdx < lineSize; lineIdx++) {
+		line[lineIdx] = *g;
+		char* end = viewEnd(str, lineSize - lineIdx - 1);
+		memcpy(&line[lineIdx].u, end, str->itemSize);
+	}
+	xdrawline(TLINE(yPos), 0, yPos, xStart);
+	xdrawline(line -xStart, xStart, yPos, xEnd+1);
+	free(line); // that sucks.
+}
+
+/// Print either the current command or the last comman din case the current command is empty.
+static inline void printCommandString(void) {
+	Glyph g = styleCommand;
+	displayString(isEmpty(currentCommand) ? lastCommand : currentCommand,
+			&g, term.row - 1);
+}
+
+static inline void printSearchString(void) {
+	Glyph g = styleSearch;
+	displayString(&searchString, &g, term.row - 2);
+}
+
+static inline void enableOperation(enum Operation o) {
+	stateNormalMode.command.op = o;
+	stateNormalMode.command.infix = infix_none;
+	stateNormalMode.command.startPosition.x = term.c.x;
+	stateNormalMode.command.startPosition.y = term.c.y;
+	stateNormalMode.command.startPosition.yScr = term.scr;
+}
+
+static inline bool isMotionFinished(void) {
+	return stateNormalMode.motion.finished;
+}
+
+static inline void finishMotion(void) {
+	stateNormalMode.motion.finished = true;
+}
+
+static inline bool isOperationFinished(void) {
+	return stateNormalMode.command.op == noop
+		&& stateNormalMode.command.infix == infix_none;
+}
+
+static inline void finishOperation(void) {
+	stateNormalMode.command = defaultNormalMode.command;
+	assert(isOperationFinished());
+}
+
+static bool replay = false;
+
+static inline void emptyCurrentCommand(void) {
+	if (!replay) { empty(currentCommand); }
+}
+
+
+/// @param abort: If enabled, the command exits without registering
+/// @return       Whether the the application is ready to yield control back to
+//the normal command flow
+static bool terminateCommand(bool abort) {
+	bool const exitOperation = isMotionFinished();
+	bool exitNormalMode = false;
+	finishMotion();
+
+	if (exitOperation) {
+		exitNormalMode = isOperationFinished();
+		finishOperation();
+		selclear();
+
+		if (!replay) {
+			emptyCurrentCommand();
+			if (!abort) { toggle = !toggle; }
+		}
+		empty(&highlights);
+	}
+	printCommandString();
+	printSearchString();
+	return exitNormalMode;
+}
+
+static inline void exitCommand(void) { terminateCommand(false); }
+
+static inline void abortCommand(void) { terminateCommand(true); }
+
+static void moveLine(int8_t sign) {
+	if (sign == -1) {
+		if (term.c.y-- == 0) {
+			if (++term.scr == HISTSIZE) {
+				term.c.y = term.row - 1;
+				term.scr = 0;
+			} else {
+				term.c.y = 0;
+			}
+		}
+	} else {
+		term.c.x = 0;
+		if (++term.c.y == term.row) {
+			if (term.scr-- == 0) {
+				term.c.y = 0;
+				term.scr = HISTSIZE - 1;
+			} else {
+				term.c.y = term.row - 1;
+			}
+		}
+	}
+}
+
+static void moveLetter(int8_t sign) {
+	term.c.x += sign;
+	if (!BETWEEN(term.c.x, 0, term.col-1)) {
+		if (term.c.x < 0) {
+			term.c.x = term.col - 1;
+			moveLine(sign);
+		} else {
+			term.c.x = 0;
+			moveLine(sign);
+		}
+	}
+}
+
+static inline bool contains (char ksym, char const * values, uint32_t amount) {
+	for (uint32_t i = 0; i < amount; i++) { if (ksym == values[i]) { return true; } }
+	return false;
+}
+
+
+/// Go to next occurrence of string relative to the current location
+/// conduct search, starting at start pos
+bool
+gotoString(int8_t sign) {
+	uint32_t findIndex = 0;
+	uint32_t searchStringSize = size(&searchString);
+	uint32_t const maxIteration = (HISTSIZE + term.row) * term.col + searchStringSize;  //< one complete traversal.
+	//moveLetter(sign); // XXX: new
+	for (uint32_t cIteration = 0; findIndex < searchStringSize
+			&& cIteration ++ < maxIteration; moveLetter(sign)) {
+		uint32_t const searchChar = *((uint32_t*)(sign == 1 ? view(&searchString, findIndex)
+					: viewEnd(&searchString, findIndex)));
+
+		uint32_t const fu = TLINE(term.c.y)[term.c.x].u;
+
+		if (fu == searchChar) findIndex++;
+		else findIndex = 0;
+	}
+	bool const found = findIndex == searchStringSize;
+	if (found) { for (uint32_t i = 0; i < searchStringSize; i++) { moveLetter(-sign); } }
+	return found;
+}
+
+/// Find the next occurrence of a word
+static inline bool
+gotoNextString(int8_t sign) {
+	moveLetter(sign);
+	return gotoString(sign);
+}
+
+/// Highlight all found strings on the current screen.
+static void
+highlightStringOnScreen(void) {
+	if (isEmpty(&searchString)) { return; }
+	uint32_t const searchStringSize = size(&searchString);
+	uint32_t findIndex = 0;
+	uint32_t xStart, yStart;
+	for (int y = 0; y < term.row; y++) {
+		for (int x = 0; x < term.col; x++) {
+			if (TLINE(y)[x].u == *((uint32_t*)(view(&searchString, findIndex)))) {
+				if (findIndex++ == 0) {
+					xStart = x;
+					yStart = y;
+				}
+				if (findIndex == searchStringSize) {
+					// mark selected
+					append(&highlights, &xStart);
+					append(&highlights, &yStart);
+
+					findIndex = 0;
+					term.dirty[yStart] = 1;
+				}
+			} else {
+				findIndex = 0;
+			}
+		}
+	}
+}
+
+static bool gotoStringAndHighlight(int8_t sign) {
+	bool const found = gotoString(sign);  //< find the next string to the current position
+	empty(&highlights);             //< remove previous highlights
+	if (found) {                          //< apply new highlights if found
+		//if (sign == -1) { moveLetter(-1); }
+		highlightStringOnScreen();
+	} else {                              //< go to the position where the search started.
+		applyPosition(&stateNormalMode.motion.searchPosition);
+	}
+	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
+	                                      //  is painted separately.
+	return found;
+}
+
+static bool pressKeys(char const* nullTerminatedString, size_t end) {
+	replay = true;
+        bool succ = true;
+	for (size_t i = 0; i < end && succ; ++i) {
+		succ = kpressNormalMode(&nullTerminatedString[i], 1, false,
+				false, nullTerminatedString[i] == '\n', false);
+	}
+	replay = false;
+	return succ;
+}
+
+static bool executeCommand(DynamicArray const *command) {
+	replay = true;
+	size_t end=size(command);
+	char decoded [32];
+	bool succ = true;
+	size_t len;
+	for (size_t i = 0; i < end && succ; ++i) {
+		len = utf8encode(*((Rune*)view(command, i)), decoded);
+		succ = kpressNormalMode(decoded, len, false,
+				false, len == 1 && decoded[0]=='\n', false);
+	}
+	replay = false;
+	return succ;
+}
+
+struct {
+	char const first;
+	char const second;
+} const Brackets [] = {
+	{'(', ')'},
+	{'<', '>'},
+	{'{', '}'},
+	{'[', ']'},
+};
+
+
+/// Emits Command prefix and suffix when i motion is performed (e.g. yiw).
+///
+/// @param c:             motion character
+/// @param expandMode:    1 for 'i', 2 for 'a'
+/// @param first, second: Dynamic arrays in which the prefix and postfix
+///                       commands will be returned
+/// @return               whether the command could be extracted successfully.
+static bool expandExpression(char const c, enum Infix expandMode,
+		DynamicArray *first, DynamicArray *second) {
+	empty(first);
+	empty(second);
+	// Motions
+	char const lower = tolower(c);
+	if (lower == 'w') {
+		// translated into wb[command]e resp. WB[command]E, which works
+		// file even when at the fist letter. Does not work for single
+		// letter words though.
+		int const diff = c - lower;
+		checkSetNextV(first, c);
+		checkSetNextV(first, (signed char)(((int)'b') + diff));
+		checkSetNextV(second, (signed char)(((int)'e') + diff));
+		return true;
+	}
+	// Symmetrical brackets (quotation marks)
+	if (c == '\'' || c == '"') {
+		if (TLINE(term.c.y)[term.c.x].u == c) {
+			// Local ambiguity -> do nothing. It cannot be
+			// determined if the current character is the first
+			// character of the selection or the second one.
+			//  <---- search here? -- ['] -- or search here? --->
+			return false;
+		}
+		// ?[c]\nl
+		char res [] = {'?', c, '\n'};
+		checkSetNextP(first, res);
+		checkSetNextV(expandMode == infix_i ? first : second, 'l');
+		res[0] = '/';
+		checkSetNextP(second, res);
+		if (expandMode == infix_i) { checkSetNextV(second, 'h'); }
+		return true;
+	}
+	// Brackets: Does not if in range / if the brackets belong togehter.
+	for (size_t pid = 0; pid < sizeof(Brackets); ++pid) {
+		if(Brackets[pid].first == c || Brackets[pid].second == c) {
+			if (TLINE(term.c.y)[term.c.x].u == Brackets[pid].first) {
+				checkSetNextV(first, 'l');
+			}
+			checkSetNextV(first, '?');
+			checkSetNextV(first, Brackets[pid].first);
+			checkSetNextV(first, '\n');
+			checkSetNextV(expandMode == infix_i ? first : second, 'l');
+			checkSetNextV(second, '/');
+			checkSetNextV(second, Brackets[pid].second);
+			checkSetNextV(second, '\n');
+			if (expandMode == infix_i) { checkSetNextV(second, 'h'); }
+			return true;
+		}
+	}
+	// search string
+	// complicated search operation: <tag>
+	if (c == 't') {
+		// XXX: (Bug in vim: @vit )
+		// <tag_name attr="hier" a2="\<sch\>"> [current pos] </tag_name>
+		
+		// 1. Copy history ( tag := hist[?<\n:/ \n] )
+		// 2. Copy history ( first_find := hist[?<\n: next place in
+		//                   history where count '>' > count '<'
+		//                   (can be behind current pos) )
+		// 3. first := [?first_find][#first_ind]l
+		//    second:= [/tag">"]h
+		//return true; // XXX: not implmented yet.
+	}
+	return false;
+}
+
+ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
+		bool enter, bool backspace) {
+	if (ctrl) {
+		printf("hier\n");
+	}
+	// [ESC] or [ENTER] abort resp. finish the current level of operation.
+	// Typing 'i' if no operation is currently performed behaves like ESC.
+	if (esc || enter || (len == 1 && ksym[0] == 'i' && isMotionFinished()
+				&& isOperationFinished())) {
+		if (terminateCommand(!enter) ) {
+			applyPosition(&stateNormalMode.initialPosition);
+			stateNormalMode = defaultNormalMode;
+			tfulldirt();
+			return finished;
+		}
+		return success;
+	}
+	// Search: append to search string, then search & highlight
+	if (stateNormalMode.motion.search != none
+			&& !stateNormalMode.motion.finished) {
+		int8_t const sign = getSearchDirection();
+		// Apply start position.
+		if (backspace) { // XXX: if a quantifier is subject to removal, it is currently only removed
+			               //      from the  command string.
+			if (!isEmpty(currentCommand) && !isEmpty(&searchString)) {
+				pop(currentCommand);
+				pop(&searchString);
+			} else if (isEmpty(currentCommand) || isEmpty(&searchString)) {
+				empty(&highlights);
+				stateNormalMode.motion = defaultNormalMode .motion; //< if typed once more than there are
+				selclear();                                         //  letters, the search motion is
+				return success;                                             //  terminated
+			}
+			applyPosition(&stateNormalMode.motion.searchPosition);
+		} else {
+			if (len > 0) {
+				char* kSearch = checkGetNext(&searchString);
+				utf8decode(ksym, (Rune*)(kSearch), len);
+
+				char* kCommand = checkGetNext(currentCommand);
+				utf8decode(ksym, (Rune*)(kCommand), len);
+			}
+		}
+		if (sign == -1) { moveLetter(1); }
+		bool const result = gotoStringAndHighlight(sign);
+
+		if (stateNormalMode.command.op == visual) {
+			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
+		} else if  (stateNormalMode.command.op == visualLine) {
+			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
+		}
+		printCommandString();
+		printSearchString();
+		return result ? success : failed;
+	}
+
+	if (len == 0) { return failed; }
+
+	// 'i' mode enabled, hence the expression is to be expanded:
+	// [start_expression(ksym[0])] [operation] [stop_expression(ksym[0])]
+	if (stateNormalMode.command.infix != infix_none) {
+		DynamicArray prefix = CHAR_ARRAY;
+		DynamicArray suffix = CHAR_ARRAY;
+		bool const found = expandExpression(ksym[0],
+		        stateNormalMode.command.infix, &prefix, &suffix);
+		if (!found) {
+			stateNormalMode.command.infix = infix_none;
+			free(prefix.content);
+			free(suffix.content);
+			return failed;
+		}
+
+		char const operation = stateNormalMode.command.op;
+		NormalModeState const st = stateNormalMode;
+		TCursor const tc = term.c;
+		stateNormalMode.command.op = noop;
+		stateNormalMode.command.infix = infix_none;
+
+		bool succ = true;
+		replay = true;
+		for (int i = 0; i < size(&prefix) && succ; ++i) {
+			succ = pressKeys(&prefix.content[i], 1);
+		}
+		replay = true;
+		if (succ) {
+			kpressNormalMode(&operation, 1, false, 0, 0, 0);
+		}
+		replay = true;
+		for (int i = 0; i < size(&suffix) && succ; ++i) {
+			succ = pressKeys(&suffix.content[i], 1);
+		}
+		replay = false;
+
+		if (!succ) { // go back to the old position, apply op
+			stateNormalMode = st;
+			term.c = tc;
+		}
+
+		free(prefix.content);
+		free(suffix.content);
+		return succ ? success : failed;
+	}
+
+
+	// V / v or y take precedence over movement commands.
+	switch(ksym[0]) {
+		case '.':
+		{
+			if (!isEmpty(currentCommand)) { toggle = !toggle; empty(currentCommand); }
+			return executeCommand(lastCommand) ? success : failed;
+		}
+		case 'i':
+			stateNormalMode.command.infix = infix_i;
+			return success;
+		case 'a':
+			stateNormalMode.command.infix = infix_a;
+			return success;
+		case 'y': //< Yank mode
+		{
+			char* kCommand = checkGetNext(currentCommand);
+			utf8decode(ksym, (Rune*)(kCommand), len);
+			switch(stateNormalMode.command.op) {
+				case noop:           //< Start yank mode & set #op
+					enableOperation(yank);
+					selstart(term.c.x, term.c.y, term.scr, 0);
+					emptyCurrentCommand();
+					break;
+				case visualLine:     //< Complete yank operation
+				case visual:
+					xsetsel(getsel());     //< yank
+					xclipcopy();
+					exitCommand();         //< reset command
+					break;
+				case yank:           //< Complete yank operation as in y#amount j
+					selstart(0, term.c.y, term.scr, 0);
+					int const origY = term.c.y;
+					for (uint32_t i = 1; i < MAX(stateNormalMode.motion.amount, 1); ++i) moveLine(1);
+					selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
+					xsetsel(getsel());
+					xclipcopy();
+					term.c.y = origY;
+					exitCommand();
+			}
+			printCommandString();
+			printSearchString();
+			return success;
+		}
+		case 'v':                //< Visual Mode: Toggle mode.
+		case 'V':
+		{
+			enum Operation op = ksym[0] == 'v' ? visual : visualLine;
+			bool assign = stateNormalMode.command.op != op;
+			abortCommand();
+			if (assign) {
+				enableOperation(op);
+				char* kCommand = checkGetNext(currentCommand);
+				utf8decode(ksym, (Rune*)(kCommand), len);
+				if (op == visualLine) {
+					selstart(0, term.c.y, term.scr, 0);
+					selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
+				} else {
+					selstart(term.c.x, term.c.y, term.scr, 0);
+				}
+			}
+			return success;
+		}
+	}
+	// Perform the movement.
+	int32_t sign = -1;    //< whether a command goes 'forward' (1) or 'backward' (-1)
+	bool discard = false; //< discard input, as it does not have a meaning.
+	bool cmdSuccessful = true;
+	switch(ksym[0]) {
+		case 'j': sign = 1; FALLTHROUGH
+		case 'k':
+			term.c.y += sign * MAX(stateNormalMode.motion.amount,1);
+			break;
+		case 'H': term.c.y = 0;
+			  break; //< [numer]H ~ L[number]j is not supported.
+		case 'M': term.c.y = term.bot / 2;
+			  break;
+		case 'L': term.c.y = term.bot;
+			  break; //< [numer]L ~ L[number]k is not supported.
+		case 'G':  //< Differs from vim, but most useful translation.
+			applyPosition(&stateNormalMode.initialPosition);
+			break;
+		case 'l': sign = 1; FALLTHROUGH
+		case 'h':
+		{
+			int32_t const amount = term.c.x 
+				+ sign * MAX(stateNormalMode.motion.amount, 1);
+			term.c.x = amount % term.col;
+			while (term.c.x < 0) { term.c.x += term.col; }
+			term.c.y += floor(1.0 * amount / term.col);
+			break;
+		}
+		case '0':
+			if (!stateNormalMode.motion.amount) { term.c.x = 0; }
+			else { discard = true; }
+			break;
+		case '$': term.c.x = term.col-1; 
+			  break;
+		case 'w': FALLTHROUGH
+		case 'W': FALLTHROUGH
+		case 'e': FALLTHROUGH
+		case 'E': sign = 1; FALLTHROUGH
+		case 'B': FALLTHROUGH
+		case 'b':
+		{
+			char const * const wDelim = ksym[0] <= 90 
+				? wordDelimLarge : wordDelimSmall;
+			uint32_t const wDelimLen = strlen(wDelim);
+			
+			bool const startSpaceIsSeparator = 
+				!(ksym[0] == 'w' || ksym[0] == 'W');
+			// Whether to start & end with offset:
+			bool const performOffset = startSpaceIsSeparator;
+			// Max iteration := One complete hist traversal.
+			uint32_t const maxIter = (HISTSIZE+term.row) * term.col;
+			// Doesn't work exactly as in vim: Linebreak is 
+			// counted as 'normal' separator, hence a jump can 
+			// span multiple lines here.
+			stateNormalMode.motion.amount = 
+				MAX(stateNormalMode.motion.amount, 1);
+			for (; stateNormalMode.motion.amount > 0; stateNormalMode.motion.amount--) {
+				uint8_t state = 0;
+				if (performOffset) { moveLetter(sign); }
+				for (uint32_t cIt = 0; cIt ++ < maxIter; moveLetter(sign)) {
+					if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
+						if (state == 1) {
+							if (performOffset) { moveLetter(-sign); }
+							break;
+						}
+					} else if (state == 0) { state = 1; }
+				}
+			}
+			break;
+		}
+		case '/': sign = 1; FALLTHROUGH
+		case '?':
+			  empty(&searchString);
+			  stateNormalMode.motion.search = sign == 1 ? forward : backward;
+			  stateNormalMode.motion.searchPosition.x = term.c.x;
+			  stateNormalMode.motion.searchPosition.y = term.c.y;
+			  stateNormalMode.motion.searchPosition.yScr = term.scr;
+			  stateNormalMode.motion.finished = false;
+			  break;
+		case 'n': sign = 1; FALLTHROUGH
+		case 'N':
+			  toggle = !toggle;
+			  emptyCurrentCommand();
+			  if (stateNormalMode.motion.search == none) {
+				  stateNormalMode.motion.search = forward;
+				  stateNormalMode.motion.finished = true;
+			  }
+			  if (stateNormalMode.motion.search == backward) { sign *= -1; }
+			  for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); cmdSuccessful && amount > 0; amount--) {
+				  moveLetter(sign);
+				  cmdSuccessful = gotoStringAndHighlight(sign);
+			  }
+			  break;
+		case 't':
+			  if (sel.type == SEL_REGULAR) {
+				  sel.type = SEL_RECTANGULAR;
+			  } else {
+				  sel.type = SEL_REGULAR;
+			  }
+			  tsetdirt(sel.nb.y, sel.ne.y);
+			  discard = true;
+			  break;
+		default:
+			  discard = true;
+			  break;
+	}
+	bool const isNumber = len == 1 && BETWEEN(ksym[0], 48, 57);
+	if (isNumber) { //< record numbers
+		discard = false;
+		stateNormalMode.motion.amount =
+			MIN(SHRT_MAX, stateNormalMode.motion.amount * 10 + ksym[0] - 48);
+	} else if (!discard) {
+		stateNormalMode.motion.amount = 0;
+	}
+
+	if (discard) {
+		for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
+			if (ksym[0] == normalModeShortcuts[i].key) {
+				cmdSuccessful = pressKeys(normalModeShortcuts[i].value, strlen(normalModeShortcuts[i].value));
+			}
+		}
+	} else {
+		char* kCommand = checkGetNext(currentCommand);
+		utf8decode(ksym, (Rune*)(kCommand), len);
+
+		int diff = 0;
+		if (term.c.y > 0) {
+			if (term.c.y > term.bot) {
+				diff = term.bot - term.c.y;
+				term.c.y = term.bot;
+			}
+		} else {
+			if (term.c.y < 0) {
+				diff = -term.c.y;
+				term.c.y = 0;
+			}
+		}
+
+		int const _newScr = term.scr + diff;
+		term.c.y = _newScr < 0 ? 0 : (_newScr >= HISTSIZE ? term.bot : term.c.y);
+		term.scr = mod(_newScr, HISTSIZE);
+
+		if (!isEmpty(&highlights)) {
+			empty(&highlights);
+			highlightStringOnScreen();
+		}
+
+		tsetdirt(0, term.row-3);
+		printCommandString();
+		printSearchString();
+
+		if (stateNormalMode.command.op == visual) {
+			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
+		} else if  (stateNormalMode.command.op == visualLine) {
+			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
+		} else {
+			if (!isNumber && (stateNormalMode.motion.search == none
+					|| stateNormalMode.motion.finished)) {
+				toggle = !toggle;
+				emptyCurrentCommand();
+			}
+			if (stateNormalMode.command.op == yank) {
+				if (!isNumber && !discard && stateNormalMode.motion.search == none) {
+					// copy
+					selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
+					xsetsel(getsel());
+					xclipcopy();
+					applyPosition(&stateNormalMode.command.startPosition);
+					exitCommand();
+				}
+			}
+		}
+	}
+	return cmdSuccessful ? success : failed;
+}
+
+ void onMove(void) {
+	stateNormalMode.initialPosition.x = term.c.x;
+	stateNormalMode.initialPosition.y = term.c.y;
+	stateNormalMode.initialPosition.yScr = term.scr;
+}
+
diff --git a/normalMode.h b/normalMode.h
new file mode 100644
index 0000000..b78ca15
--- /dev/null
+++ b/normalMode.h
@@ -0,0 +1,36 @@
+/* See LICENSE for license details. */
+#ifndef NORMAL_MODE_H
+#define NORMAL_MODE_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+/// Used in the configuration file to define custom shortcuts.
+typedef struct NormalModeShortcuts {
+	char key;
+	char *value;
+} NormalModeShortcuts;
+
+/// Holds the exit status of the #kpressNormalMode function, which informs the
+/// caller when to exit normal mode.
+typedef enum ExitState {
+	failed = 0,
+	success = 1,
+	finished = 2,
+} ExitState;
+
+/// Called when curr position is altered.
+void onMove(void);
+
+/// Function which returns whether the value at position provided as arguments
+/// is to be highlighted.
+int highlighted(int, int);
+
+/// Handles keys in normal mode.
+ExitState kpressNormalMode(
+		char const * ksym, int len, bool ctrlPressed,
+		bool esc, bool enter, bool backspace);
+
+
+#endif // NORMAL_MODE_H
diff --git a/st.c b/st.c
index d579569..12e8a37 100644
--- a/st.c
+++ b/st.c
@@ -20,9 +20,9 @@
 #include <wchar.h>
 
 
+#include "term.h"
 #include "st.h"
 #include "win.h"
-#include "dynamicArray.h"
 
 #if   defined(__linux)
  #include <pty.h>
@@ -39,8 +39,6 @@
 #define ESC_ARG_SIZ   16
 #define STR_BUF_SIZ   ESC_BUF_SIZ
 #define STR_ARG_SIZ   ESC_ARG_SIZ
-//#define HISTSIZE      100
-#define HISTSIZE      2000
 
 /* macros */
 #define IS_SET(flag)		((term.mode & (flag)) != 0)
@@ -48,9 +46,7 @@
 #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
 #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
 #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
-#define TLINE(y)		((y) < term.scr ? term.hist[((y) + term.histi - \
-				term.scr + HISTSIZE + 1) % HISTSIZE] : \
-				term.line[(y) - term.scr])
+#define INTERVAL(x, a, b)	(x) < (a) ? (a) : (x) > (b) ? (b) : (x)
 
 enum term_mode {
 	MODE_WRAP        = 1 << 0,
@@ -95,56 +91,6 @@ enum escape_state {
 	ESC_DCS        =128,
 };
 
-typedef struct {
-	Glyph attr; /* current char attributes */
-	int x;
-	int y;
-	char state;
-} TCursor;
-
-typedef struct {
-	int mode;
-	int type;
-	int snap;
-	/// Selection variables:
-	/// ob – original coordinates of the beginning of the selection
-	/// oe – original coordinates of the end of the selection
-	struct {
-		int x, y, scroll;
-	} ob, oe;
-	/// Selection variables; currently displayed chunk.
-	/// nb – normalized coordinates of the beginning of the selection
-	/// ne – normalized coordinates of the end of the selection
-	struct {
-		int x, y;
-	} nb, ne;
-
-	int alt;
-} Selection;
-
-/* Internal representation of the screen */
-typedef struct {
-	int row;      /* nb row */
-	int col;      /* nb col */
-	Line *line;   /* screen */
-	Line *alt;    /* alternate screen */
-	Line hist[HISTSIZE]; /* history buffer */
-	int histi;    /* history index */
-	int scr;      /* scroll back */
-	int *dirty;   /* dirtyness of lines */
-	TCursor c;    /* cursor */
-	int ocx;      /* old cursor col */
-	int ocy;      /* old cursor row */
-	int top;      /* top    scroll limit */
-	int bot;      /* bottom scroll limit */
-	int mode;     /* terminal mode flags */
-	int esc;      /* escape state flags */
-	char trantbl[4]; /* charset table translation */
-	int charset;  /* current charset */
-	int icharset; /* selected charset for sequence */
-	int *tabs;
-} Term;
-
 /* CSI Escape sequence structs */
 /* ESC '[' [[ [<priv>] <arg> [;]] <mode> [<mode>]] */
 typedef struct {
@@ -166,53 +112,7 @@ typedef struct {
 	int narg;              /* nb of args */
 } STREscape;
 
-/// Position (x, y , and current scroll in the y dimension).
-typedef struct Position {
-	uint32_t x;
-	uint32_t y;
-	uint32_t yScr;
-} Position;
-
-/// The entire normal mode state, consisting of an operation
-/// and a motion.
-struct NormalModeState {
-	Position initialPosition;
-	// Operation:
-	struct OperationState {
-		enum Operation {
-			noop = ' ',
-			visual = 'v',
-			visualLine = 'V',
-			yank = 'y'
-		} op;
-		Position startPosition;
-		uint8_t inner;
-	} command;
-	// Motions:
-	struct MotionState {
-		uint32_t amount;
-		enum Search {
-			none,
-			forward,
-			backward,
-		} search;
-		Position searchPosition;
-		bool finished;
-	} motion;
-} stateNormalMode;
-
-/// Default state if no operation is performed.
-struct NormalModeState defaultNormalMode = {{0,0,0}, {noop, {0, 0, 0}, false}, {0, none, {0, 0, 0}, false}};
-
-
-DynamicArray searchString =  UTF8_ARRAY;
-DynamicArray commandHist0 =  UTF8_ARRAY;
-DynamicArray commandHist1 =  UTF8_ARRAY;
-DynamicArray highlights   = QWORD_ARRAY;
-/// History command toggle
-bool toggle = false;
-#define currentCommand toggle ? &commandHist0 : &commandHist1
-#define lastCommand    toggle ? &commandHist1 : &commandHist0
+void tfulldirt(void);
 
 static void execsh(char *, char **);
 static void stty(char **);
@@ -250,12 +150,10 @@ static void tscrollup(int, int, int);
 static void tscrolldown(int, int, int);
 static void tsetattr(int *, int);
 static void tsetchar(Rune, Glyph *, int, int);
-static void tsetdirt(int, int);
 static void tsetscroll(int, int);
 static void tswapscreen(void);
 static void tsetmode(int, int, int *, int);
 static int twrite(const char *, int, int);
-static void tfulldirt(void);
 static void tcontrolcode(uchar );
 static void tdectest(char );
 static void tdefutf8(char);
@@ -269,7 +167,6 @@ static void selnormalize(void);
 static void selscroll(int, int);
 static void selsnap(int *, int *, int);
 
-static size_t utf8decode(const char *, Rune *, size_t);
 static Rune utf8decodebyte(char, size_t *);
 static char utf8encodebyte(Rune, size_t);
 static size_t utf8validate(Rune *, size_t);
@@ -280,8 +177,8 @@ static char base64dec_getc(const char **);
 static ssize_t xwrite(int, const char *, size_t);
 
 /* Globals */
-static Term term;
-static Selection sel;
+Term term;
+Selection sel;
 static CSIEscape csiescseq;
 static STREscape strescseq;
 static int iofd = 1;
@@ -293,12 +190,6 @@ static uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
 static Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
 static Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
 
-void applyPosition(Position const *pos) {
-	term.c.x = pos->x;
-	term.c.y = pos->y;
-	term.scr = pos->yScr;
-}
-
 ssize_t
 xwrite(int fd, const char *s, size_t len)
 {
@@ -1277,689 +1168,6 @@ currentLine(int x, int y)
 	return (x == term.c.x || y == term.c.y);
 }
 
-int
-highlighted(int x, int y)
-{
-	// Compute the legal bounds for a hit:
-	int32_t const stringSize = size(&searchString);
-	int32_t xMin = x - stringSize;
-	int32_t yMin = y;
-	while (xMin < 0 && yMin > 0) { //< I think this temds to be more efficient than
-		xMin += term.col;            //  division + modulo.
-		--yMin;
-	}
-	if (xMin < 0) { xMin = 0; }
-
-	uint32_t highSize = size(&highlights);
-	uint32_t *ptr = (uint32_t*) highlights.content;
-	for (uint32_t i = 0; i < highSize; ++i) {
-		int32_t const sx = *(ptr++);
-		int32_t const sy = *(ptr++);
-		if (BETWEEN(sy, yMin, y) && (sy != yMin || sx > xMin) && (sy != y || sx <= x)) {
-			return true;
-		}
-	}
-	return false;
-}
-
-int mod(int a, int b) {
-	while (a < 0) {
-		a+= b;
-	}
-	return a % b;
-}
-
-void displayString(DynamicArray const *str, Glyph *g, int yPos) {
-	// Threshold: if there is nothing or no space to print, do not print.
-	if (term.col == 0 || str->index == 0) {
-		term.dirty[yPos] = 1; //< mark this line as 'dirty', because the line is not
-		//  marked dirty when scrolling due to string display.
-		return;
-	}
-
-	uint32_t lineSize = MIN(size(str), term.col / 3);
-	uint32_t xEnd = term.col - 1;
-	assert(lineSize <= 1 + xEnd); //< as lineSize <= term.col/3 <= term.col - 1 + 1 = xEnd + 1
-	uint32_t xStart = 1 + xEnd - lineSize;
-
-	Line line = malloc(sizeof(Glyph) * lineSize);
-	assert(str->index - 1 >=  lineSize - 1); //< lineSize <= str->index -1 direct premise.
-
-	for (uint32_t lineIdx = 0; lineIdx < lineSize; lineIdx++) {
-		line[lineIdx] = *g;
-		char* end = viewEnd(str, lineSize - lineIdx - 1);
-		memcpy(&line[lineIdx].u, end, str->itemSize);
-	}
-	xdrawline(TLINE(yPos), 0, yPos, xStart);
-	xdrawline(line -xStart, xStart, yPos, xEnd+1);
-	free(line); // that sucks.
-}
-
-/// Print either the current command or the last comman din case the current command is empty.
-void printCommandString() {
-	Glyph g = {'c', ATTR_ITALIC | ATTR_FAINT , defaultfg, defaultbg};
-	if (term.c.y == term.row-1) { g.mode ^= ATTR_CURRENT; } //< dont highlight
-	DynamicArray * cc = currentCommand;
-	displayString(isEmpty(cc) ? lastCommand : cc, &g, term.row - 1);
-	//displayString(lastCommand, &g, term.row - 2);
-}
-
-void printSearchString() {
-	Glyph g = {'c', ATTR_ITALIC | ATTR_BOLD_FAINT, defaultfg, defaultbg};
-	if (term.c.y == term.row-2) { g.mode ^= ATTR_CURRENT; } //< dont highlight
-	displayString(&searchString, &g, term.row - 2);
-}
-
-
-void enableMode(enum Operation o) {
-	stateNormalMode.command.op = o;
-	stateNormalMode.command.inner = 0;
-	stateNormalMode.command.startPosition.x = term.c.x;
-	stateNormalMode.command.startPosition.y = term.c.y;
-	stateNormalMode.command.startPosition.yScr = term.scr;
-}
-
-bool normalModeEnabled = false;
-
-void onNormalModeStart() {
-	normalModeEnabled = true;
-}
-
-void onNormalModeStop() { //XXX breaks if resized
-	normalModeEnabled = false;
-	applyPosition(&stateNormalMode.initialPosition);
-}
-
-void moveLine(int8_t sign) {
-	if (sign == -1) {
-		if (term.c.y-- == 0) {
-			if (++term.scr == HISTSIZE) {
-				term.c.y = term.row - 1;
-				term.scr = 0;
-			} else {
-				term.c.y = 0;
-			}
-		}
-	} else {
-		term.c.x = 0;
-		if (++term.c.y == term.row) {
-			if (term.scr-- == 0) {
-				term.c.y = 0;
-				term.scr = HISTSIZE - 1;
-			} else {
-				term.c.y = term.row - 1;
-			}
-		}
-	}
-}
-
-void moveLetter(int8_t sign) {
-	term.c.x += sign;
-	if (!BETWEEN(term.c.x, 0, term.col-1)) {
-		if (term.c.x < 0) {
-			term.c.x = term.col - 1;
-			moveLine(sign);
-		} else {
-			term.c.x = 0;
-			moveLine(sign);
-		}
-	}
-}
-
-bool contains (char ksym, char const * values, uint32_t amount) {
-	for (uint32_t i = 0; i < amount; i++) { if (ksym == values[i]) { return true; } }
-	return false;
-}
-
-
-void terminateCommand(bool abort, bool both) {
-	bool const exitMotion = both || (stateNormalMode.motion.search == none);
-	stateNormalMode.motion  = defaultNormalMode.motion;
-	
-	if (exitMotion) {
-		stateNormalMode.command = defaultNormalMode.command;
-		selclear();
-		if (!abort) { toggle = !toggle; }
-		empty(currentCommand);
-	}
-
-	printCommandString();
-	printSearchString();
-	//tsetdirt(0, term.row-3);
-}
-static inline void exitCommand(bool motion) { terminateCommand(false, motion); }
-static inline void abortCommand() { terminateCommand(true, true); }
-
-/// Go to next occurrence of string relative to the current location
-/// conduct search, starting at start pos
-bool
-gotoString(int8_t sign) {
-	uint32_t findIndex = 0;
-	uint32_t searchStringSize = size(&searchString);
-	uint32_t const maxIteration = (HISTSIZE + term.row) * term.col + searchStringSize;  //< one complete traversal.
-	moveLetter(sign);
-	for (uint32_t cIteration = 0; findIndex < searchStringSize
-			&& cIteration ++ < maxIteration; moveLetter(sign)) {
-		uint32_t const searchChar = *((uint32_t*)(sign == 1 ? view(&searchString, findIndex)
-					: viewEnd(&searchString, findIndex)));
-
-		uint32_t const fu = TLINE(term.c.y)[term.c.x].u;
-
-		if (fu == searchChar) findIndex++;
-		else findIndex = 0;
-	}
-	bool const found = findIndex == searchStringSize;
-	if (found) { for (uint32_t i = 0; i < searchStringSize; i++) { moveLetter(-sign); } }
-	return found;
-}
-
-/// Find the next occurrence of a word
-bool
-gotoNextString(int8_t sign) {
-	moveLetter(sign);
-	return gotoString(sign);
-}
-
-/// Highlight all found strings on the current screen.
-void
-highlightStringOnScreen() {
-	if (isEmpty(&searchString)) { return; }
-	uint32_t const searchStringSize = size(&searchString);
-	uint32_t findIndex = 0;
-	uint32_t xStart, yStart;
-	for (uint32_t y = 0; y < term.row; y++) {
-		for (uint32_t x = 0; x < term.col; x++) {
-			if (TLINE(y)[x].u == *((uint32_t*)(view(&searchString, findIndex)))) {
-				if (findIndex++ == 0) {
-					xStart = x;
-					yStart = y;
-				}
-				if (findIndex == searchStringSize) {
-					// mark selected
-					append(&highlights, &xStart);
-					append(&highlights, &yStart);
-
-					findIndex = 0;
-					term.dirty[yStart] = 1;
-				}
-			} else {
-				findIndex = 0;
-			}
-		}
-	}
-}
-
-bool gotoStringAndHighlight(int8_t sign) {
-	bool const found = gotoString(sign);  //< find the next string to the current position
-	empty(&highlights);             //< remove previous highlights
-	if (found) {                          //< apply new highlights if found
-		//if (sign == -1) { moveLetter(-1); }
-		highlightStringOnScreen(sign);
-	} else {                              //< go to the position where the search started.
-		applyPosition(&stateNormalMode.motion.searchPosition);
-	}
-	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
-	                                      //  is painted separately.
-	return found;
-}
-
-bool pressKeys(char const* nullTerminatedString, size_t end) {
-        bool succ = true;
-	for (size_t i = 0; i < end && succ; ++i) {
-		if (nullTerminatedString[i] == '\n') {
-			succ = kpressNormalMode(&nullTerminatedString[i], 0, false, true, false);
-		} else {
-			succ = kpressNormalMode(&nullTerminatedString[i], 1, false, false, false);
-		}
-	}
-	return succ;
-}
-
-bool executeCommand(DynamicArray const *command) {
-	size_t end=size(command);
-	char decoded [32];
-	bool success = true;
-	for (size_t i = 0; i < end && success; ++i) {
-		size_t len = utf8encode(*((Rune*)view(command, i)) , decoded);
-		success = kpressNormalMode(decoded, len, false, false, false);
-	}
-	return success;
-	//kpressNormalMode(NULL, 0, false, true, false);
-}
-
-struct {
-	char const first; 
-	char const second;
-} const Brackets [] = {
-	{'(', ')'},
-	{'<', '>'},
-	{'{', '}'},
-	{'[', ']'},
-};
-
-
-/// Emits Command prefix and suffix when i motion is performed (e.g. yiw).
-/// 
-/// @param c:             motion character
-/// @param expandMode:    1 for 'i', 2 for 'a'
-/// @param first, second: Dynamic arrays in which the prefix and postfix
-///                       commands will be returned
-/// @return               whether the command could be extracted successfully. 
-bool expandExpression(char const c, char expandMode, 
-		DynamicArray *first, DynamicArray *second) {
-	empty(first);
-	empty(second);
-	// Motions
-	char const lower = tolower(c);
-	if (lower == 'w') {
-		// translated into wb[command]e resp. WB[command]E, which works
-		// file even when at the fist letter. Does not work for single
-		// letter words though.
-		int const diff = c - lower;
-		checkSetNextV(first, c);
-		checkSetNextV(first, (signed char)(((int)'b') + diff));
-		checkSetNextV(second, (signed char)(((int)'e') + diff));
-		return true;
-	}
-	// Symmetrical brackets (quotation marks)
-	if (c == '\'' || c == '"') {
-		if (TLINE(term.c.y)[term.c.x].u  == c) {
-			// Local ambiguity -> do nothing. It cannot be
-			// determined if the current character is the first
-			// character of the selection or the second one.
-			//  <---- search here? -- ['] -- or search here? --->
-			return false;
-		}
-		// ?[c]\nl
-		char res [] = {'?', c, '\n'};
-		checkSetNextP(first, res);
-		checkSetNextV(expandMode == 1 ? first : second, 'l');
-		res[0] = '/';
-		checkSetNextP(second, res);
-		if (expandMode == 1) { checkSetNextV(second, 'h'); }
-		return true;
-	}
-	// Brackets: Does not if in range / if the brackets belong togehter.
-	for (int pid = 0; pid < sizeof(Brackets); ++pid) {
-		if(Brackets[pid].first == c || Brackets[pid].second == c) {
-			if (TLINE(term.c.y)[term.c.x].u  == Brackets[pid].first) {
-				checkSetNextV(first, 'l');
-			}
-			checkSetNextV(first, '?');
-			checkSetNextV(first, Brackets[pid].first);
-			checkSetNextV(first, '\n');
-			checkSetNextV(expandMode == 1 ? first : second, 'l');
-			checkSetNextV(second, '/');
-			checkSetNextV(second, Brackets[pid].second);
-			checkSetNextV(second, '\n');
-			if (expandMode == 1) { checkSetNextV(second, 'h'); }
-			return true;
-		}
-	}
-	// search string
-	// complicated search operation: <tag>
-	if (c == 't') {
-		// XXX: (Bug in vim: @vit )
-		// <tag_name attr="hier" a2="\<sch\>"> [current pos] </tag_name>
-		
-		// 1. Copy history ( tag := hist[?<\n:/ \n] )
-		// 2. Copy history ( first_find := hist[?<\n: next place in 
-		//                   history where count '>' > count '<'
-		//                   (can be behind current pos) )
-		// 3. first := [?first_find][#first_ind]l
-		//    second:= [/tag">"]h
-		//return true; // XXX: not implmented yet.
-	}
-	return false;
-}
-
-
-
-bool kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace) {
-	// [ESC] or [ENTER] abort resp. finish the current operation or
-	// the Normal Mode if no operation is currently executed.
-	// #softEsc i acts like esc in case no operation is currently performed.
-	bool const softEsc = (len == 1 && ksym[0] == 'i');
-	if (esc || enter || softEsc) {
-		if (stateNormalMode.command.op == yank) {
-			printf("\nyank\n");
-			// copy
-			selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
-			xsetsel(getsel());
-			xclipcopy();
-			applyPosition(&stateNormalMode.command.startPosition);
-			exitCommand(true);
-		} else if (stateNormalMode.command.op == noop
-				&& stateNormalMode.motion.search == none
-				&& stateNormalMode.motion.amount == 0) {
-			terminateCommand(!enter, true);
-			empty(&highlights);
-			tfulldirt(); // < this also removes the search string and the last command.
-			normalMode(NULL);
-			return true;
-		} else if (!softEsc) {
-			if (enter && stateNormalMode.motion.search != none && !isEmpty(&searchString)) {
-				exitCommand(false);
-				return true;
-			} else {
-				abortCommand();
-			}
-			return true;
-		}
-	} //< ! (esc || enter)
-	// Search: append to search string & conduct search for best hit, starting at start pos,
-	//         highlighting all other occurrences on the current page if one is found.
-	if (stateNormalMode.motion.search != none && !stateNormalMode.motion.finished) {
-		int8_t const sign = stateNormalMode.motion.search == forward ? 1 : -1;
-		// Apply start position.
-		if (backspace) { // XXX: if a quantifier is subject to removal, it is currently only removed
-			               //      from the  command string.
-			if (!isEmpty(currentCommand) && !isEmpty(&searchString)) {
-				pop(currentCommand);
-				pop(&searchString);
-			} else if (isEmpty(currentCommand) || isEmpty(&searchString)) {
-				empty(&highlights);
-				stateNormalMode.motion = defaultNormalMode .motion; //< if typed once more than there are
-				selclear();                                         //  letters, the search motion is
-				return true;                                             //  terminated
-			}
-			applyPosition(&stateNormalMode.motion.searchPosition);
-		} else {
-			if (len > 0) {
-				char* kSearch = checkGetNext(&searchString);
-				utf8decode(ksym, (Rune*)(kSearch), len);
-
-				char* kCommand = checkGetNext(currentCommand);
-				utf8decode(ksym, (Rune*)(kCommand), len);
-			}
-		}
-		//if (sign == -1) { moveLetter(1); }
-		bool const result = gotoStringAndHighlight(sign);
-
-		if (stateNormalMode.command.op == visual) {
-			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
-		} else if  (stateNormalMode.command.op == visualLine) {
-			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
-		}
-		printCommandString();
-		printSearchString();
-		return result;
-	}
-
-	if (len == 0) { return false; }
-
-	// 'i' mode enabled, hence the expression is to be expanded:
-	// [start_expression(ksym[0])] [operation] [stop_expression(ksym[0])]
-	if (stateNormalMode.command.inner) {
-		DynamicArray prefix = CHAR_ARRAY; 
-		DynamicArray suffix = CHAR_ARRAY; 
-		bool const found = expandExpression(ksym[0], 
-		        stateNormalMode.command.inner, &prefix, &suffix);
-		if (!found) { 
-			stateNormalMode.command.inner = 0;
-			free(prefix.content);
-			free(suffix.content);
-			return false; 
-		}
-
-		char const operation = stateNormalMode.command.op;
-		struct NormalModeState const st = stateNormalMode;
-		TCursor const tc = term.c;
-		stateNormalMode.command.op = noop;
-		stateNormalMode.command.inner = 0;
-
-		bool succ = true;
-		for (size_t i = 0; i < size(&prefix) && succ; ++i) {
-			succ = pressKeys(&prefix.content[i], 1);
-			//printf("%c", prefix.content[i]);
-		}
-		if (succ) { 
-			kpressNormalMode(&operation, 1, 0, 0, 0); 
-			//printf("%c", operation);
-		}
-		for (size_t i = 0; i < size(&suffix) && succ; ++i) {
-			succ = pressKeys(&suffix.content[i], 1);
-			//printf("%c", suffix.content[i]);
-		}
-
-		if (!succ) { // go back to the old position, apply op
-			stateNormalMode = st;
-			term.c = tc;
-			//printf("\nnot successful\n");
-		}
-
-		free(prefix.content);
-		free(suffix.content);
-		return succ;
-	}
-
-
-	// V / v or y take precedence over movement commands.
-	switch(ksym[0]) {
-		case '.':
-			{
-				if (!isEmpty(currentCommand)) { toggle = !toggle; empty(currentCommand); }
-				return executeCommand(lastCommand);
-			}
-		case 'i': 
-			stateNormalMode.command.inner = 1;
-			return true;
-		case 'a': 
-			stateNormalMode.command.inner = 2;
-			return true;
-		case 'y': //< Yank mode
-			{
-				char* kCommand = checkGetNext(currentCommand);
-				utf8decode(ksym, (Rune*)(kCommand), len);
-				switch(stateNormalMode.command.op) {
-					case noop:           //< Start yank mode & set #op
-						enableMode(yank);
-						selstart(term.c.x, term.c.y, term.scr, 0);
-						empty(currentCommand);
-						break;
-					case visualLine:     //< Complete yank operation
-					case visual:
-						xsetsel(getsel());     //< yank
-						xclipcopy();
-						exitCommand(true);         //< reset command
-						break;
-					case yank:           //< Complete yank operation as in y#amount j
-						selstart(0, term.c.y, term.scr, 0);
-						uint32_t const origY = term.c.y;
-						for (int32_t i = 0; i < MAX(stateNormalMode.motion.amount, 1) - 1; i ++) moveLine(1);
-						selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
-						xsetsel(getsel());
-						xclipcopy();
-						term.c.y = origY;
-						exitCommand(true);
-				}
-			}
-			printCommandString();
-			printSearchString();
-			return true;
-		case 'v':                //< Visual Mode: Toggle mode.
-		case 'V':
-			{
-				enum Operation mode = ksym[0] == 'v' ? visual : visualLine;
-				bool assign = stateNormalMode.command.op != mode;
-				abortCommand();
-				if (assign) {
-					enableMode(mode);
-					char* kCommand = checkGetNext(currentCommand);
-					utf8decode(ksym, (Rune*)(kCommand), len);
-					if (mode == visualLine) {
-						selstart(0, term.c.y, term.scr, 0);
-						selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
-					} else {
-						selstart(term.c.x, term.c.y, term.scr, 0);
-					}
-				}
-			}
-			return true;
-	}
-	// Perform the movement.
-	int32_t sign = -1;    //< whehter a command goes 'forward' (1) or 'backward' (-1)
-	bool discard = false; //< discard input, as it does not have a meaning.
-	bool success = true;
-	switch(ksym[0]) {
-		case 'j': sign = 1;
-		case 'k':
-							term.c.y += sign * MAX(stateNormalMode.motion.amount, 1);
-							break;
-		case 'H': term.c.y = 0;            break; //< [numer]H ~ L[number]j is not supported.
-		case 'M': term.c.y = term.bot / 2; break;
-		case 'L': term.c.y = term.bot;     break; //< [numer]L ~ L[number]k is not supported.
-		case 'G':  //< a little different from vim, but in this use case the most useful translation.
-							applyPosition(&stateNormalMode.initialPosition);
-		case 'l': sign = 1;
-		case 'h':
-							{
-								int32_t const amount = term.c.x + sign * MAX(stateNormalMode.motion.amount, 1);
-								term.c.x = amount % term.col;
-								while (term.c.x < 0) { term.c.x += term.col; }
-								term.c.y += floor(1.0 * amount / term.col);
-								break;
-							}
-		case '0':
-							if (stateNormalMode.motion.amount == 0) { term.c.x = 0; }
-							else { discard = true; }
-							break;
-		case '$': term.c.x = term.col-1; break;
-		case 'w':
-		case 'W':
-		case 'e':
-		case 'E': sign = 1;
-		case 'B':
-		case 'b':
-							{
-								bool const startSpaceIsSeparator = !(ksym[0] == 'w' || ksym[0] == 'W');
-								bool const capital = ksym[0] <= 90; //< defines the word separators to use
-								char const * const wDelim = capital ? wordDelimLarge : wordDelimSmall;
-								uint32_t const wDelimLen =  strlen(wDelim);
-								bool const performOffset = startSpaceIsSeparator; //< start & end with offset.
-								uint32_t const maxIteration = (HISTSIZE + term.row) * term.col;  //< one complete traversal.
-
-								// doesn't work exactly as in vim, but I think this version is better;
-								// Linebreak is counted as 'normal' separator; hence a jump can span multiple lines here.
-								stateNormalMode.motion.amount = MAX(stateNormalMode.motion.amount, 1);
-								for (; stateNormalMode.motion.amount > 0; stateNormalMode.motion.amount--) {
-									uint8_t state = 0;
-									if (performOffset) { moveLetter(sign); }
-									for (uint32_t cIteration = 0; cIteration ++ < maxIteration; moveLetter(sign)) {
-										if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
-											if (state == 1) {
-												if (performOffset) { moveLetter(-sign); }
-												break;
-											}
-										} else if (state == 0) { state = 1; }
-									}
-								}
-								break;
-							}
-		case '/': sign = 1;
-		case '?': 
-							empty(&searchString);
-							stateNormalMode.motion.search = sign == 1 ? forward : backward;
-							stateNormalMode.motion.searchPosition.x = term.c.x;
-							stateNormalMode.motion.searchPosition.y = term.c.y;
-							stateNormalMode.motion.searchPosition.yScr = term.scr;
-							stateNormalMode.motion.finished = false;
-							break;
-		case 'n': sign = 1;
-		case 'N':
-							toggle = !toggle;
-							empty(currentCommand);
-							if (stateNormalMode.motion.search == none) {
-								stateNormalMode.motion.search = forward;
-								stateNormalMode.motion.finished = true;
-							}
-							if (stateNormalMode.motion.search == backward) { sign *= -1; }
-							for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); success && amount > 0; amount--) {
-								//moveLetter(sign);
-								success = gotoStringAndHighlight(sign);
-							}
-							break;
-		case 't':
-							if (sel.type == SEL_REGULAR) {
-								sel.type = SEL_RECTANGULAR;
-							} else {
-								sel.type = SEL_REGULAR;
-							}
-							tsetdirt(sel.nb.y, sel.ne.y);
-							discard = true;
-		default:
-							discard = true;
-	}
-	bool const isNumber = len == 1 && BETWEEN(ksym[0], 48, 57);
-	if (isNumber) { //< record numbers
-		discard = false;
-		stateNormalMode.motion.amount =
-			MIN(SHRT_MAX, stateNormalMode.motion.amount * 10 + ksym[0] - 48);
-	} else if (!discard) {
-		stateNormalMode.motion.amount = 0;
-	}
-
-	if (discard) {
-		for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
-			if (ksym[0] == normalModeShortcuts[i].key) {
-				success = pressKeys(normalModeShortcuts[i].value, strlen(normalModeShortcuts[i].value));
-			}
-		}
-	} else {
-		char* kCommand = checkGetNext(currentCommand);
-		utf8decode(ksym, (Rune*)(kCommand), len);
-
-		int diff = 0;
-		if (term.c.y > 0) {
-			if (term.c.y > term.bot) {
-				diff = term.bot - term.c.y;
-				term.c.y = term.bot;
-			}
-		} else {
-			if (term.c.y < 0) {
-				diff = -term.c.y;
-				term.c.y = 0;
-			}
-		}
-
-		int const _newScr = term.scr + diff;
-		term.c.y = _newScr < 0 ? 0 : (_newScr >= HISTSIZE ? term.bot : term.c.y);
-		term.scr = mod(_newScr, HISTSIZE);
-
-		if (!isEmpty(&highlights)) {
-			empty(&highlights);
-			highlightStringOnScreen();
-		}
-
-		tsetdirt(0, term.row-3);
-		printCommandString();
-		printSearchString();
-
-		if (stateNormalMode.command.op == visual) {
-			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
-		} else if  (stateNormalMode.command.op == visualLine) {
-			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
-		} else {
-			if (!isNumber && (stateNormalMode.motion.search == none
-					|| stateNormalMode.motion.finished)) {
-				toggle = !toggle;
-				empty(currentCommand);
-			}
-			if (stateNormalMode.command.op == yank) {
-				if (!isNumber && !discard && stateNormalMode.motion.search == none) {
-					// copy
-					selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
-					xsetsel(getsel());
-					xclipcopy();
-					applyPosition(&stateNormalMode.command.startPosition);
-					exitCommand(true);
-				}
-			}
-		}
-	}
-	return success;
-}
-
 void
 csiparse(void)
 {
@@ -2013,9 +1221,7 @@ tmoveto(int x, int y)
 	term.c.x = LIMIT(x, 0, term.col-1);
 	term.c.y = LIMIT(y, miny, maxy);
 	// Set the last position in order to restore after normal mode exits.
-	stateNormalMode.initialPosition.x = term.c.x;
-	stateNormalMode.initialPosition.y = term.c.y;
-	stateNormalMode.initialPosition.yScr = term.scr;
+	onMove();
 }
 
 void
diff --git a/st.h b/st.h
index 76b4dca..c2aa8bb 100644
--- a/st.h
+++ b/st.h
@@ -1,6 +1,8 @@
 /* See LICENSE for license details. */
 
-#include <stdbool.h>
+#include "glyph.h"
+#include "normalMode.h"
+
 #include <stdint.h>
 #include <sys/types.h>
 
@@ -11,8 +13,6 @@
 #define BETWEEN(x, a, b)	((a) <= (x) && (x) <= (b))
 #define DIVCEIL(n, d)		(((n) + ((d) - 1)) / (d))
 #define DEFAULT(a, b)		(a) = (a) ? (a) : (b)
-#define INTERVAL(x, a, b)		(x) < (a) ? (a) : (x) > (b) ? (b) : (x)
-#define INTERVAL_DIFF(x, a, b)		(x) < (a) ? (x) - (a) : (x) > (b) ? (x) - (b) : 0
 #define LIMIT(x, a, b)		(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)
 #define ATTRCMP(a, b)		((a).mode != (b).mode || (a).fg != (b).fg || \
 				(a).bg != (b).bg)
@@ -47,11 +47,6 @@ enum selection_mode {
 	SEL_READY = 2
 };
 
-enum selection_type {
-	SEL_REGULAR = 1,
-	SEL_RECTANGULAR = 2
-};
-
 enum selection_snap {
 	SNAP_WORD = 1,
 	SNAP_LINE = 2
@@ -62,18 +57,6 @@ typedef unsigned int uint;
 typedef unsigned long ulong;
 typedef unsigned short ushort;
 
-typedef uint_least32_t Rune;
-
-#define Glyph Glyph_
-typedef struct {
-	Rune u;           /* character code */
-	ushort mode;      /* attribute flags */
-	uint32_t fg;      /* foreground  */
-	uint32_t bg;      /* background  */
-} Glyph;
-
-typedef Glyph *Line;
-
 typedef union {
 	int i;
 	uint ui;
@@ -85,14 +68,11 @@ void die(const char *, ...);
 void redraw(void);
 void draw(void);
 
-int highlighted(int, int);
 int currentLine(int, int);
 void kscrolldown(const Arg *);
 void kscrollup(const Arg *);
-bool kpressNormalMode(char const * ksym, uint32_t len, bool esc, bool enter, bool backspace);
 void normalMode(Arg const *);
-void onNormalModeStart();
-void onNormalModeStop();
+
 void printscreen(const Arg *);
 void printsel(const Arg *);
 void sendbreak(const Arg *);
@@ -102,6 +82,8 @@ int tattrset(int);
 void tnew(int, int);
 void tresize(int, int);
 void tsetdirtattr(int);
+size_t utf8decode(const char *, Rune *, size_t);
+void tsetdirt(int, int);
 void ttyhangup(void);
 int ttynew(char *, char *, char *, char **);
 size_t ttyread(void);
@@ -125,8 +107,6 @@ void *xmalloc(size_t);
 void *xrealloc(void *, size_t);
 char *xstrdup(char *);
 
-
-
 /* config.h globals */
 extern char *utmp;
 extern char *stty_args;
@@ -137,26 +117,3 @@ extern char *termname;
 extern unsigned int tabspaces;
 extern unsigned int defaultfg;
 extern unsigned int defaultbg;
-extern char wordDelimSmall[];
-extern char wordDelimLarge[];
-
-typedef struct NormalModeShortcuts {
-	char key;
-	char *value;
-} NormalModeShortcuts;
-
-extern NormalModeShortcuts normalModeShortcuts[];
-extern size_t const amountNormalModeShortcuts;
-
-/*[OP]i[Letter] <=> [Letter-start-target][OP][Ltter-stop-target]
-typedef struct {
-	char a;
-	char c;
-} keyCounterparts = {
-	{ '(', ')', "?" },
-	{ '<', '>' },
-	{ '{', '}' },
-	{ '[', ']' },
-	
-};
-*/
diff --git a/term.h b/term.h
new file mode 100644
index 0000000..6619255
--- /dev/null
+++ b/term.h
@@ -0,0 +1,73 @@
+#ifndef TERM_H
+#define TERM_H
+
+//
+// Internal terminal structs.
+//
+
+#include "glyph.h"
+
+#include <stdint.h>
+
+#define HISTSIZE      2000
+
+typedef struct {
+	Glyph attr; /* current char attributes */
+	int x;
+	int y;
+	char state;
+} TCursor;
+
+typedef struct {
+	int mode;
+	int type;
+	int snap;
+	/// Selection variables:
+	/// ob – original coordinates of the beginning of the selection
+	/// oe – original coordinates of the end of the selection
+	struct {
+		int x, y, scroll;
+	} ob, oe;
+	/// Selection variables; currently displayed chunk.
+	/// nb – normalized coordinates of the beginning of the selection
+	/// ne – normalized coordinates of the end of the selection
+	struct {
+		int x, y;
+	} nb, ne;
+
+	int alt;
+} Selection;
+
+/* Internal representation of the screen */
+typedef struct {
+	int row;      /* nb row */
+	int col;      /* nb col */
+	Line *line;   /* screen */
+	Line *alt;    /* alternate screen */
+	Line hist[HISTSIZE]; /* history buffer */
+	int histi;    /* history index */
+	int scr;      /* scroll back */
+	int *dirty;   /* dirtyness of lines */
+	TCursor c;    /* cursor */
+	int ocx;      /* old cursor col */
+	int ocy;      /* old cursor row */
+	int top;      /* top    scroll limit */
+	int bot;      /* bottom scroll limit */
+	int mode;     /* terminal mode flags */
+	int esc;      /* escape state flags */
+	char trantbl[4]; /* charset table translation */
+	int charset;  /* current charset */
+	int icharset; /* selected charset for sequence */
+	int *tabs;
+} Term;
+
+extern Term term;
+
+#define TLINE(y) ((y) < term.scr ? term.hist[((y) + term.histi - \
+		 term.scr + HISTSIZE + 1) % HISTSIZE] : \
+		 term.line[(y) - term.scr])
+
+extern Selection sel;
+
+
+#endif // TERM_H
diff --git a/x.c b/x.c
index ccf1751..9d92f5b 100644
--- a/x.c
+++ b/x.c
@@ -730,15 +730,9 @@ xloadcolor(int i, const char *name, Color *ncolor)
 }
 
 void
-normalMode(Arg const *_)  //< the argument is just for the sake of
-                          //  adhering to the function format.
-{
-	win.mode ^= MODE_NORMAL; //< toggle normal mode via exclusive or.
-	if (win.mode & MODE_NORMAL) {
-		onNormalModeStart();
-	} else {
-		onNormalModeStop();
-	}
+normalMode(Arg const *_) {
+	(void) _;
+	win.mode ^= MODE_NORMAL;
 }
 
 
@@ -1579,7 +1573,7 @@ xdrawline(Line line, int x1, int y1, int x2)
 		if (highlighted(x, y1)) {
 			new.mode ^= ATTR_HIGHLIGHT;
 		}
-    if (currentLine(x, y1)) {
+		if (currentLine(x, y1)) {
 			new.mode ^= ATTR_CURRENT;
 		}
 		if (i > 0 && ATTRCMP(base, new)) {
@@ -1764,9 +1758,11 @@ kpress(XEvent *ev)
 
 	len = XmbLookupString(xw.xic, e, buf, sizeof buf, &ksym, &status);
 	if (IS_SET(MODE_NORMAL)) {
-		kpressNormalMode(buf, strlen(buf),
-				ksym == XK_Escape, ksym == XK_Return, ksym == XK_BackSpace);
-		return;
+		ExitState const es = kpressNormalMode(buf, strlen(buf),
+				match(ControlMask, e->state), ksym == XK_Escape,
+			       	ksym == XK_Return, ksym == XK_BackSpace); 
+		if (es == finished) { normalMode(NULL); } 
+		return; //if (es != failed) { return; }
 	}
 
 	/* 1. shortcuts */
@@ -1908,9 +1904,8 @@ run(void)
 				XNextEvent(xw.dpy, &ev);
 				if (XFilterEvent(&ev, None))
 					continue;
-				if (handler[ev.type]) {
+				if (handler[ev.type])
 					(handler[ev.type])(&ev);
-				}
 			}
 
 			draw();
-- 
2.25.0


From a54928d7982b36d1624fb8141557e935e7ab347e Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Wed, 5 Feb 2020 17:47:50 +0100
Subject: [PATCH 07/23] chore: Cleanup + assertion mgmt

Contributes to #20
---
 Makefile       |   7 +-
 dynamicArray.h | 135 ++++++++---
 normalMode.c   | 633 +++++++++++++++++++++++++++----------------------
 3 files changed, 459 insertions(+), 316 deletions(-)

diff --git a/Makefile b/Makefile
index 92cdc6f..af8f0be 100644
--- a/Makefile
+++ b/Makefile
@@ -21,8 +21,8 @@ config.h:
 .c.o:
 	$(CC) $(STCFLAGS) -c $<
 
-st.o: config.h st.h win.h dynamicArray.h normalMode.h term.h glyph.h
-x.o: arg.h config.h st.h win.h dynamicArray.h normalMode.h term.h glyph.h
+st.o: config.h st.h win.h dynamicArray.h normalMode.h term.h glyph.h error.h
+x.o: arg.h config.h st.h win.h dynamicArray.h normalMode.h term.h glyph.h error.h
 
 $(OBJ): config.h config.mk
 
@@ -35,7 +35,8 @@ clean:
 dist: clean
 	mkdir -p st-$(VERSION)
 	cp -R FAQ LEGACY TODO LICENSE Makefile README config.mk\
-		config.def.h st.info st.1 arg.h st.h win.h dynamicArray.h normalMode.h term.h $(SRC)\
+		config.def.h st.info st.1 arg.h st.h win.h dynamicArray.h\
+		normalMode.h term.h error.h $(SRC)\
 		st-$(VERSION)
 	tar -cf - st-$(VERSION) | gzip > st-$(VERSION).tar.gz
 	rm -rf st-$(VERSION)
diff --git a/dynamicArray.h b/dynamicArray.h
index 9473219..8af5d9c 100644
--- a/dynamicArray.h
+++ b/dynamicArray.h
@@ -1,8 +1,9 @@
 #ifndef DYNAMIC_ARRAY_H
 #define DYNAMIC_ARRAY_H
 
+#include "error.h"
+
 #include <stdint.h>
-#include <assert.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdbool.h>
@@ -10,9 +11,13 @@
 /// Struct for which this file offers functionality in order to expand the array
 /// and set / get its content.
 typedef struct DynamicArray {
+	/// Size of the datatype contained in the array.
 	uint8_t itemSize;
+	/// Amount of bytes currently initialized
 	uint32_t index;
+	/// Amount of bytes currently reserved (not necessarily initialized)
 	uint32_t allocated;
+	/// Actual content.
 	char* content;
 } DynamicArray;
 
@@ -23,77 +28,141 @@ typedef struct DynamicArray {
 #define WORD_ARRAY  {2, 0, 0, NULL}
 #define DWORD_ARRAY {4, 0, 0, NULL}
 #define QWORD_ARRAY {8, 0, 0, NULL}
-/// (Wasteful) utf-8 array, that always used 4 bytes in order to display a character,
-/// even if the space is not required.
+/// (Wasteful) utf-8 array, that always used 4 bytes in order to display a
+/// character, even if the space is not required.
 #define UTF8_ARRAY  DWORD_ARRAY
 
+/// Check that at least \p bytes are allocated, if true implying that
+/// \p s->content[\bytes - 1] is allocated.
+static inline bool
+isAllocated(DynamicArray const *s, uint32_t bytes) {
+	return s != NULL && s->allocated >= bytes;
+}
 
-static inline char*
-gnext(DynamicArray *s) { return &s->content[s->index+=s->itemSize]; }
+/// @see #isAllocated
+static inline bool
+isInitialized(DynamicArray const *s, uint32_t bytes) {
+	return s != NULL && s->index >= bytes;
+}
 
+/// Return the next element in \p s and increment index without checking bounds.
 static inline char*
-get(DynamicArray const * s) { return &s->content[s->index]; }
+gnext(DynamicArray *s) {
+	ENSURE(s!=NULL, return NULL);
+	ENSURE(s->index % s->itemSize == 0 && "(index not aligned)",
+			s->index += s->itemSize - (s->index % s->itemSize));
+	ENSURE(isAllocated(s, s->index + 2 * s->itemSize), return NULL);
+	return s->content + (s->index += s->itemSize);
+}
 
+/// View element \p i in \p s.
 static inline char*
 view(DynamicArray const * s, uint32_t i) {
+	ENSURE((s != NULL) && isAllocated(s, (i+1) * s->itemSize), return NULL);
 	return s->content + i*s->itemSize;
 }
 
+/// Inspect element content[size() - 1 - i].
 static inline char *
 viewEnd(DynamicArray const *s, uint32_t i) {
+	ENSURE((s != NULL) && isInitialized(s, i * s->itemSize), return NULL);
+	ENSURE(s->index%s->itemSize == 0 && "(index not aligned)", return NULL);
 	return s->content + s->index - (i + 1) * s->itemSize;
 }
 
-static inline void
-set(DynamicArray* s, char const *vals, uint32_t amount) {
+/// Set conent without applying
+static inline bool
+setValues(DynamicArray* s, char const *vals, uint32_t amount) {
+	ENSURE(vals != NULL, return false);
+	ENSURE((s != NULL) && isAllocated(s, s->index + amount), return false);
 	memcpy(s->content + s->index, vals, amount);
+	return true;
 }
 
-static inline void
+static inline bool
 snext(DynamicArray* s, char const *vals, uint32_t amount) {
-	set(s, vals, amount);
+	bool const success = setValues(s, vals, amount);
+	ENSURE(success, return false);
 	uint8_t const rest = amount % s->itemSize;
-	s->index+= amount + (rest ? s->itemSize : 0);
+	uint32_t const newSize = s->index + amount + (rest ? s->itemSize : 0);
+	ENSURE(isAllocated(s, newSize), return false);
+	s->index = newSize;
+	return true;
 }
 
+/// Empty \p s.
 static inline void
-empty(DynamicArray* s) { s->index = 0; }
+empty(DynamicArray* s) {
+	ENSURE((s != NULL), return);
+	s->index = 0;
+}
 
+/// Check if \p s has initialized content (which can be the case even if memory
+/// is allocated).
 static inline bool
-isEmpty(DynamicArray* s) { return s->index == 0; }
+isEmpty(DynamicArray const * s) {
+	ENSURE((s != NULL), return true);
+	return s->index == 0;
+}
 
 static inline int
-size(DynamicArray const * s) { return s->index / s->itemSize; }
+size(DynamicArray const * s) {
+	ENSURE(s != NULL, return 0);
+	ENSURE(s->itemSize != 0, return 0);
+	return s->index / s->itemSize;
+}
 
 static inline void
-pop(DynamicArray* s) { s->index -= s->itemSize; }
-
+pop(DynamicArray* s) {
+	ENSURE((s != NULL), return);
+	ENSURE(s->index % s->itemSize == 0 && "(index not aligned)",
+			s->index += s->itemSize - (s->index % s->itemSize));
+	ENSURE(isInitialized(s, s->itemSize), return);
+	s->index -= s->itemSize;
+}
 
-static inline void checkSetNext(DynamicArray *s, char const *c, uint32_t amount) {
-	while (s->index + s->itemSize * amount >= s->allocated) {
-		if ((s->content = (char *)realloc(
-						s->content, s->allocated += EXPAND_STEP * s->itemSize)) == NULL) {
-			exit(1);
-		};
+static inline bool
+checkSetNext(DynamicArray *s, char const *c, uint32_t amount) {
+	ENSURE(s != NULL && c != NULL, return false);
+	if (s->allocated < s->index + s->itemSize * amount) {
+		uint32_t const diff = s->index+s->itemSize*amount-s->allocated;
+		uint32_t const newAlloSize = s->allocated + (diff > EXPAND_STEP
+				? diff : EXPAND_STEP) * s->itemSize;
+		char* tmp = realloc(s->content, newAlloSize);
+		if (tmp == NULL) { return false; }
+		s->allocated = newAlloSize;
+		s->content = tmp;
+		assert(s->allocated >= s->index + s->itemSize * amount);
 	}
 	if (amount) { snext(s, c, amount); }
+	return true;
 }
 
-static inline void checkSetNextV(DynamicArray *s, char const c) {
-	checkSetNext(s, &c, 1);
+static inline bool
+checkSetNextV(DynamicArray *s, char const c) {
+	return checkSetNext(s, &c, 1);
 }
 
-static inline void checkSetNextP(DynamicArray *s, char const *c) {
-	checkSetNext(s, c, strlen(c));
+static inline bool
+checkSetNextP(DynamicArray *s, char const *c) {
+	ENSURE(c != NULL, return false);
+	return checkSetNext(s, c, strlen(c));
 }
 
-
-static char *checkGetNext(DynamicArray *s) {
-	if (s->index + s->itemSize >= s->allocated) {
-		if ((s->content = (char *)realloc(
-						s->content, s->allocated += EXPAND_STEP * s->itemSize)) == NULL) {
-			exit(1);
-		};
+/// Expand the currently initialized content in \p s and the allocated chunk of
+/// memory if required.
+static char *
+expand(DynamicArray *s) {
+	ENSURE(s != NULL, return NULL);
+	if (s->allocated < s->index + s->itemSize) {
+		uint32_t const diff = s->index + s->itemSize - s->allocated;
+		uint32_t const newAlloSize = s->allocated + (diff > EXPAND_STEP
+				? diff : EXPAND_STEP) * s->itemSize;
+		char* tmp = realloc(s->content, newAlloSize);
+		if (tmp == NULL) { return NULL; }
+		s->allocated = newAlloSize;
+		s->content = tmp;
+		assert(s->allocated >= s->index + s->itemSize);
 	}
 	s->index+=s->itemSize;
 	return viewEnd(s, 0);
diff --git a/normalMode.c b/normalMode.c
index 8033a0b..5c15cd0 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -3,6 +3,7 @@
 #include "dynamicArray.h"
 #include "term.h"
 #include "win.h"
+#include "error.h"
 
 #include <ctype.h>
 #include <stdio.h>
@@ -15,7 +16,10 @@
 #define BETWEEN(x, a, b)	((a) <= (x) && (x) <= (b))
 #define FALLTHROUGH		__attribute__((fallthrough));
 
-// Config
+//
+// Interface to the terminal
+//
+
 extern Glyph const styleCommand;
 extern Glyph const styleSearch;
 extern NormalModeShortcuts normalModeShortcuts[];
@@ -33,22 +37,15 @@ extern void selstart(int, int, int, int);
 extern char *getsel(void);
 extern void tfulldirt(void);
 
-
-/// Position (x, y , and current scroll in the y dimension).
+//
+// `Private` structs
+//
 typedef struct {
 	uint32_t x;
 	uint32_t y;
 	uint32_t yScr;
 } Position;
 
-static void applyPosition(Position const *pos) {
-	term.c.x = pos->x;
-	term.c.y = pos->y;
-	term.scr = pos->yScr;
-}
-
-
-
 /// The entire normal mode state, consisting of an operation
 /// and a motion.
 typedef struct {
@@ -82,23 +79,18 @@ typedef struct {
 } NormalModeState;
 
 NormalModeState defaultNormalMode = {
-	{0,0,0}, 
-	{noop, {0, 0, 0}, false}, 
+	{0,0,0},
+	{noop, {0, 0, 0}, false},
 	{0, none, {0, 0, 0}, true}
 };
 
 /// Default state if no operation is performed.
 NormalModeState stateNormalMode = {
-	{0,0,0}, 
-	{noop, {0, 0, 0}, false}, 
+	{0,0,0},
+	{noop, {0, 0, 0}, false},
 	{0, none, {0, 0, 0}, true}
 };
 
-static inline int getSearchDirection(void) {
-	return stateNormalMode.motion.search == forward ? 1 : -1;
-}
-
-
 DynamicArray searchString =  UTF8_ARRAY;
 DynamicArray commandHist0 =  UTF8_ARRAY;
 DynamicArray commandHist1 =  UTF8_ARRAY;
@@ -110,64 +102,85 @@ bool toggle = false;
 #define currentCommand toggle ? &commandHist0 : &commandHist1
 #define lastCommand    toggle ? &commandHist1 : &commandHist0
 
+//
+// Utility functions
+//
 
-int
-highlighted(int x, int y)
-{
-	// Compute the legal bounds for a hit:
-	int32_t const stringSize = size(&searchString);
-	int32_t xMin = x - stringSize;
-	int32_t yMin = y;
-	while (xMin < 0 && yMin > 0) { //< I think this temds to be more efficient than
-		xMin += term.col;            //  division + modulo.
-		--yMin;
-	}
-	if (xMin < 0) { xMin = 0; }
+static inline int
+mod(int a, int b) {
+	for (; a < 0; a += b);
+	return a % b;
+}
 
-	uint32_t highSize = size(&highlights);
-	uint32_t *ptr = (uint32_t*) highlights.content;
-	for (uint32_t i = 0; i < highSize; ++i) {
-		int32_t const sx = *(ptr++);
-		int32_t const sy = *(ptr++);
-		if (BETWEEN(sy, yMin, y) && (sy != yMin || sx > xMin) && (sy != y || sx <= x)) {
-			return true;
-		}
-	}
+static inline bool
+contains (char c, char const * values, uint32_t memSize) {
+	ENSURE(values != NULL, return false);
+	for (uint32_t i = 0; i < memSize; ++i) if (c == values[i]) return true;
 	return false;
 }
 
-static inline int mod(int a, int b) {
-	for (;a < 0; a+=b);
-	return a % b;
+static inline void
+applyPosition(Position const *pos) {
+	ENSURE(pos != NULL, return);
+	term.c.x = pos->x;
+	term.c.y = pos->y;
+	term.scr = pos->yScr;
 }
 
-static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
-	// Threshold: if there is nothing or no space to print, do not print.
-	if (term.col == 0 || str->index == 0) {
-		term.dirty[yPos] = 1; //< mark this line as 'dirty', because the line is not
-		//  marked dirty when scrolling due to string display.
-		return;
-	}
+static inline int
+getSearchDirection(void) {
+	return stateNormalMode.motion.search == forward ? 1 : -1;
+}
 
-	uint32_t lineSize = MIN(size(str), term.col / 3);
-	uint32_t xEnd = term.col - 1;
-	assert(lineSize <= 1 + xEnd); //< as lineSize <= term.col/3 <= term.col - 1 + 1 = xEnd + 1
-	uint32_t xStart = 1 + xEnd - lineSize;
+//
+// `Private` functions:
+//
 
-	Line line = malloc(sizeof(Glyph) * lineSize);
-	assert(str->index - 1 >=  lineSize - 1); //< lineSize <= str->index -1 direct premise.
+// Fuctions: Temporarily display string on screen .
 
-	for (uint32_t lineIdx = 0; lineIdx < lineSize; lineIdx++) {
+///
+/// Display string at end of a specified line without writing it into the bufer.
+/// This reserves
+///
+/// @param str  string that is to be displayed
+/// @param g    glyph
+/// @param yPos
+static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
+	ENSURE((str != NULL) && (g != NULL) && (term.row > 0), return);
+	ENSURE(yPos >= 0, yPos = 0);
+	ENSURE(yPos < term.row, yPos = term.row - 1);
+	// Arbritary limit to avoid withhelding too much info from user.
+	int const maxFractionOverridden = 3;
+	// Threshold: if there is nothing or no space to print, do not print,
+	//            but transfer repsonsibility for printing back to [st].
+	if (term.col < maxFractionOverridden || str->index <= 0) {       // (0)
+		term.dirty[yPos] = 1;
+		return;
+	}
+	// Determine the dimensions of used chunk of screen.
+	uint32_t const overrideSize = MIN(size(str),
+			term.col / maxFractionOverridden);               // (1)
+	uint32_t const overrideEnd = term.col - 1;
+	// Has to follow trivially hence th assert:
+	// overrideSize <(1)= term.col/3  <(0)= term.col = overrideEnd + 1.
+	assert(overrideSize <= overrideEnd + 1);
+	uint32_t const overrideStart = 1 + overrideEnd - overrideSize;
+
+	Line line = malloc(sizeof(Glyph) * overrideSize);
+	assert(str->index - 1 >=  overrideSize - 1); //< triv. from (1).
+	if (line == NULL) { return; }
+
+	for (uint32_t lineIdx = 0; lineIdx < overrideSize; ++lineIdx) {
 		line[lineIdx] = *g;
-		char* end = viewEnd(str, lineSize - lineIdx - 1);
+		char* end = viewEnd(str, overrideSize - lineIdx - 1);
+		if (end == NULL) { break; }
 		memcpy(&line[lineIdx].u, end, str->itemSize);
 	}
-	xdrawline(TLINE(yPos), 0, yPos, xStart);
-	xdrawline(line -xStart, xStart, yPos, xEnd+1);
-	free(line); // that sucks.
+	xdrawline(TLINE(yPos), 0, yPos, overrideStart);
+	xdrawline(line -overrideStart, overrideStart, yPos, overrideEnd+1);
+	free(line);
 }
 
-/// Print either the current command or the last comman din case the current command is empty.
 static inline void printCommandString(void) {
 	Glyph g = styleCommand;
 	displayString(isEmpty(currentCommand) ? lastCommand : currentCommand,
@@ -179,6 +192,10 @@ static inline void printSearchString(void) {
 	displayString(&searchString, &g, term.row - 2);
 }
 
+
+// NormalMode Operation / Motion utilies.
+
+
 static inline void enableOperation(enum Operation o) {
 	stateNormalMode.command.op = o;
 	stateNormalMode.command.infix = infix_none;
@@ -205,13 +222,6 @@ static inline void finishOperation(void) {
 	assert(isOperationFinished());
 }
 
-static bool replay = false;
-
-static inline void emptyCurrentCommand(void) {
-	if (!replay) { empty(currentCommand); }
-}
-
-
 /// @param abort: If enabled, the command exits without registering
 /// @return       Whether the the application is ready to yield control back to
 //the normal command flow
@@ -225,10 +235,9 @@ static bool terminateCommand(bool abort) {
 		finishOperation();
 		selclear();
 
-		if (!replay) {
-			emptyCurrentCommand();
-			if (!abort) { toggle = !toggle; }
-		}
+		empty(currentCommand);
+		if (!abort) { toggle = !toggle; }
+
 		empty(&highlights);
 	}
 	printCommandString();
@@ -276,32 +285,25 @@ static void moveLetter(int8_t sign) {
 	}
 }
 
-static inline bool contains (char ksym, char const * values, uint32_t amount) {
-	for (uint32_t i = 0; i < amount; i++) { if (ksym == values[i]) { return true; } }
-	return false;
-}
-
-
 /// Go to next occurrence of string relative to the current location
 /// conduct search, starting at start pos
-bool
+static bool
 gotoString(int8_t sign) {
-	uint32_t findIndex = 0;
-	uint32_t searchStringSize = size(&searchString);
-	uint32_t const maxIteration = (HISTSIZE + term.row) * term.col + searchStringSize;  //< one complete traversal.
-	//moveLetter(sign); // XXX: new
-	for (uint32_t cIteration = 0; findIndex < searchStringSize
-			&& cIteration ++ < maxIteration; moveLetter(sign)) {
-		uint32_t const searchChar = *((uint32_t*)(sign == 1 ? view(&searchString, findIndex)
-					: viewEnd(&searchString, findIndex)));
-
-		uint32_t const fu = TLINE(term.c.y)[term.c.x].u;
-
-		if (fu == searchChar) findIndex++;
-		else findIndex = 0;
+	uint32_t const searchStrSize = size(&searchString);
+	uint32_t const maxIter = (HISTSIZE+term.row) * term.col + searchStrSize;
+	uint32_t findIdx = 0;
+	for (uint32_t cIteration = 0; findIdx < searchStrSize
+			&& cIteration ++ < maxIter; moveLetter(sign)) {
+		char const *const next = sign==1 ? view(&searchString, findIdx)
+			: viewEnd(&searchString, findIdx);
+		if (next == NULL) { return false; }
+		uint32_t const searchChar = *((uint32_t*) next);
+
+		if (TLINE(term.c.y)[term.c.x].u == searchChar) { ++findIdx; }
+		else { findIdx = 0; }
 	}
-	bool const found = findIndex == searchStringSize;
-	if (found) { for (uint32_t i = 0; i < searchStringSize; i++) { moveLetter(-sign); } }
+	bool const found = findIdx == searchStrSize;
+	if (found) { for (uint32_t i = 0; i < searchStrSize; i++) { moveLetter(-sign); } }
 	return found;
 }
 
@@ -317,37 +319,45 @@ static void
 highlightStringOnScreen(void) {
 	if (isEmpty(&searchString)) { return; }
 	uint32_t const searchStringSize = size(&searchString);
-	uint32_t findIndex = 0;
+	uint32_t findIdx = 0;
 	uint32_t xStart, yStart;
-	for (int y = 0; y < term.row; y++) {
-		for (int x = 0; x < term.col; x++) {
-			if (TLINE(y)[x].u == *((uint32_t*)(view(&searchString, findIndex)))) {
-				if (findIndex++ == 0) {
+	bool success = true;
+	for (int y = 0; y < term.row && success; y++) {
+		for (int x = 0; x < term.col && success; x++) {
+			char const * const next = view(&searchString, findIdx);
+			if (next == NULL) { return; }
+
+			if (TLINE(y)[x].u == *((uint32_t*)(next))) {
+				if (++findIdx == 1) {
 					xStart = x;
 					yStart = y;
 				}
-				if (findIndex == searchStringSize) {
+				if (findIdx == searchStringSize) {
 					// mark selected
-					append(&highlights, &xStart);
-					append(&highlights, &yStart);
+					success = success
+						&& append(&highlights, &xStart)
+						&& append(&highlights, &yStart);
 
-					findIndex = 0;
+					findIdx = 0;
 					term.dirty[yStart] = 1;
 				}
 			} else {
-				findIndex = 0;
+				findIdx = 0;
 			}
 		}
 	}
+	if (!success) {
+		empty(&highlights);
+	}
 }
 
 static bool gotoStringAndHighlight(int8_t sign) {
-	bool const found = gotoString(sign);  //< find the next string to the current position
-	empty(&highlights);             //< remove previous highlights
-	if (found) {                          //< apply new highlights if found
-		//if (sign == -1) { moveLetter(-1); }
+      	// Find hte next occurrence of the #searchString in direction #sign
+	bool const found = gotoString(sign);
+	empty(&highlights);
+	if (found) {
 		highlightStringOnScreen();
-	} else {                              //< go to the position where the search started.
+	} else {
 		applyPosition(&stateNormalMode.motion.searchPosition);
 	}
 	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
@@ -356,28 +366,26 @@ static bool gotoStringAndHighlight(int8_t sign) {
 }
 
 static bool pressKeys(char const* nullTerminatedString, size_t end) {
-	replay = true;
         bool succ = true;
 	for (size_t i = 0; i < end && succ; ++i) {
 		succ = kpressNormalMode(&nullTerminatedString[i], 1, false,
 				false, nullTerminatedString[i] == '\n', false);
 	}
-	replay = false;
 	return succ;
 }
 
 static bool executeCommand(DynamicArray const *command) {
-	replay = true;
 	size_t end=size(command);
 	char decoded [32];
 	bool succ = true;
 	size_t len;
 	for (size_t i = 0; i < end && succ; ++i) {
-		len = utf8encode(*((Rune*)view(command, i)), decoded);
+		char const *const nextRune = view(command, i);
+		if (nextRune == NULL) { return false; }
+		len = utf8encode(*((Rune *) nextRune), decoded);
 		succ = kpressNormalMode(decoded, len, false,
 				false, len == 1 && decoded[0]=='\n', false);
 	}
-	replay = false;
 	return succ;
 }
 
@@ -400,54 +408,58 @@ struct {
 ///                       commands will be returned
 /// @return               whether the command could be extracted successfully.
 static bool expandExpression(char const c, enum Infix expandMode,
-		DynamicArray *first, DynamicArray *second) {
-	empty(first);
-	empty(second);
-	// Motions
+		DynamicArray *fst, DynamicArray *snd) {
+	empty(fst);
+	empty(snd);
+	bool s = true; //< used in order to detect memory allocation errors.
 	char const lower = tolower(c);
+	// Motions
 	if (lower == 'w') {
 		// translated into wb[command]e resp. WB[command]E, which works
 		// file even when at the fist letter. Does not work for single
 		// letter words though.
 		int const diff = c - lower;
-		checkSetNextV(first, c);
-		checkSetNextV(first, (signed char)(((int)'b') + diff));
-		checkSetNextV(second, (signed char)(((int)'e') + diff));
-		return true;
+		s = s && checkSetNextV(fst, c);
+		s = s && checkSetNextV(fst, (signed char)(((int)'b') + diff));
+		s = s && checkSetNextV(snd, (signed char)(((int)'e')+ diff));
+		return s;
 	}
 	// Symmetrical brackets (quotation marks)
 	if (c == '\'' || c == '"') {
 		if (TLINE(term.c.y)[term.c.x].u == c) {
 			// Local ambiguity -> do nothing. It cannot be
-			// determined if the current character is the first
-			// character of the selection or the second one.
+			// determined if the current character is the fst
+			// character of the selection or the snd one.
 			//  <---- search here? -- ['] -- or search here? --->
 			return false;
 		}
 		// ?[c]\nl
 		char res [] = {'?', c, '\n'};
-		checkSetNextP(first, res);
-		checkSetNextV(expandMode == infix_i ? first : second, 'l');
+		s = s && checkSetNextP(fst, res);
+		s = s && checkSetNextV(expandMode == infix_i?fst:snd, 'l');
 		res[0] = '/';
-		checkSetNextP(second, res);
-		if (expandMode == infix_i) { checkSetNextV(second, 'h'); }
-		return true;
+		s = s && checkSetNextP(snd, res);
+		if (expandMode == infix_i) s = s && checkSetNextV(snd, 'h');
+		return s;
 	}
 	// Brackets: Does not if in range / if the brackets belong togehter.
 	for (size_t pid = 0; pid < sizeof(Brackets); ++pid) {
 		if(Brackets[pid].first == c || Brackets[pid].second == c) {
-			if (TLINE(term.c.y)[term.c.x].u == Brackets[pid].first) {
-				checkSetNextV(first, 'l');
+			if (TLINE(term.c.y)[term.c.x].u ==Brackets[pid].first) {
+				s = s && checkSetNextV(fst, 'l');
 			}
-			checkSetNextV(first, '?');
-			checkSetNextV(first, Brackets[pid].first);
-			checkSetNextV(first, '\n');
-			checkSetNextV(expandMode == infix_i ? first : second, 'l');
-			checkSetNextV(second, '/');
-			checkSetNextV(second, Brackets[pid].second);
-			checkSetNextV(second, '\n');
-			if (expandMode == infix_i) { checkSetNextV(second, 'h'); }
-			return true;
+			s = s && checkSetNextV(fst, '?');
+			s = s && checkSetNextV(fst, Brackets[pid].first);
+			s = s && checkSetNextV(fst, '\n');
+			s = s && checkSetNextV(
+					expandMode == infix_i ? fst : snd, 'l');
+			s = s && checkSetNextV(snd, '/');
+			s = s && checkSetNextV(snd, Brackets[pid].second);
+			s = s && checkSetNextV(snd, '\n');
+			if (expandMode == infix_i) {
+				s = s && checkSetNextV(snd, 'h');
+			}
+			return s;
 		}
 	}
 	// search string
@@ -467,11 +479,47 @@ static bool expandExpression(char const c, enum Infix expandMode,
 	return false;
 }
 
-ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
-		bool enter, bool backspace) {
-	if (ctrl) {
-		printf("hier\n");
+//
+// Public API
+//
+
+void
+onMove(void) {
+	stateNormalMode.initialPosition.x = term.c.x;
+	stateNormalMode.initialPosition.y = term.c.y;
+	stateNormalMode.initialPosition.yScr = term.scr;
+}
+
+
+int
+highlighted(int x, int y)
+{
+	// Compute the legal bounds for a hit:
+	int32_t const stringSize = size(&searchString);
+	int32_t xMin = x - stringSize;
+	int32_t yMin = y;
+	while (xMin < 0 && yMin > 0) {
+		xMin += term.col;
+		--yMin;
 	}
+	if (xMin < 0) { xMin = 0; }
+
+	uint32_t highSize = size(&highlights);
+	uint32_t *ptr = (uint32_t*) highlights.content;
+	for (uint32_t i = 0; i < highSize; ++i) {
+		int32_t const sx = *(ptr++);
+		int32_t const sy = *(ptr++);
+		if (BETWEEN(sy, yMin, y) && (sy != yMin || sx > xMin)
+				&& (sy != y || sx <= x)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+ExitState
+kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
+		bool backspace) {
 	// [ESC] or [ENTER] abort resp. finish the current level of operation.
 	// Typing 'i' if no operation is currently performed behaves like ESC.
 	if (esc || enter || (len == 1 && ksym[0] == 'i' && isMotionFinished()
@@ -488,29 +536,30 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 	if (stateNormalMode.motion.search != none
 			&& !stateNormalMode.motion.finished) {
 		int8_t const sign = getSearchDirection();
-		// Apply start position.
-		if (backspace) { // XXX: if a quantifier is subject to removal, it is currently only removed
-			               //      from the  command string.
-			if (!isEmpty(currentCommand) && !isEmpty(&searchString)) {
-				pop(currentCommand);
-				pop(&searchString);
-			} else if (isEmpty(currentCommand) || isEmpty(&searchString)) {
-				empty(&highlights);
-				stateNormalMode.motion = defaultNormalMode .motion; //< if typed once more than there are
-				selclear();                                         //  letters, the search motion is
-				return success;                                             //  terminated
+		// Append or remove current letter from command & searchString.
+		if (backspace) {
+			if (!isEmpty(currentCommand)) { pop(currentCommand); }
+			if (!isEmpty(&searchString)) { pop(&searchString); }
+			if (isEmpty(&searchString)) {
+				exitCommand();
+				return success;
 			}
-			applyPosition(&stateNormalMode.motion.searchPosition);
 		} else {
-			if (len > 0) {
-				char* kSearch = checkGetNext(&searchString);
-				utf8decode(ksym, (Rune*)(kSearch), len);
-
-				char* kCommand = checkGetNext(currentCommand);
-				utf8decode(ksym, (Rune*)(kCommand), len);
+			if (len < 1) { return true; }
+			char* kSearch = expand(&searchString);
+			if (kSearch == NULL) {
+				empty(&searchString);
+				return true;
+			}
+			utf8decode(ksym, (Rune*)(kSearch), len);
+			char* kCommand = expand(currentCommand);
+			if (kCommand == NULL) {
+				empty(currentCommand);
+				return true;
 			}
+			utf8decode(ksym, (Rune*)(kCommand), len);
 		}
-		if (sign == -1) { moveLetter(1); }
+		applyPosition(&stateNormalMode.motion.searchPosition);
 		bool const result = gotoStringAndHighlight(sign);
 
 		if (stateNormalMode.command.op == visual) {
@@ -546,19 +595,15 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 		stateNormalMode.command.infix = infix_none;
 
 		bool succ = true;
-		replay = true;
 		for (int i = 0; i < size(&prefix) && succ; ++i) {
 			succ = pressKeys(&prefix.content[i], 1);
 		}
-		replay = true;
 		if (succ) {
 			kpressNormalMode(&operation, 1, false, 0, 0, 0);
 		}
-		replay = true;
 		for (int i = 0; i < size(&suffix) && succ; ++i) {
 			succ = pressKeys(&suffix.content[i], 1);
 		}
-		replay = false;
 
 		if (!succ) { // go back to the old position, apply op
 			stateNormalMode = st;
@@ -586,13 +631,17 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 			return success;
 		case 'y': //< Yank mode
 		{
-			char* kCommand = checkGetNext(currentCommand);
+			char* kCommand = expand(currentCommand);
+			if (kCommand == NULL) {
+				empty(currentCommand);
+				return true;
+			}
 			utf8decode(ksym, (Rune*)(kCommand), len);
 			switch(stateNormalMode.command.op) {
 				case noop:           //< Start yank mode & set #op
 					enableOperation(yank);
 					selstart(term.c.x, term.c.y, term.scr, 0);
-					emptyCurrentCommand();
+					empty(currentCommand);
 					break;
 				case visualLine:     //< Complete yank operation
 				case visual:
@@ -622,7 +671,11 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 			abortCommand();
 			if (assign) {
 				enableOperation(op);
-				char* kCommand = checkGetNext(currentCommand);
+				char* kCommand = expand(currentCommand);
+				if (kCommand == NULL) {
+					empty(currentCommand);
+					return true;
+				}
 				utf8decode(ksym, (Rune*)(kCommand), len);
 				if (op == visualLine) {
 					selstart(0, term.c.y, term.scr, 0);
@@ -638,107 +691,126 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 	int32_t sign = -1;    //< whether a command goes 'forward' (1) or 'backward' (-1)
 	bool discard = false; //< discard input, as it does not have a meaning.
 	bool cmdSuccessful = true;
-	switch(ksym[0]) {
-		case 'j': sign = 1; FALLTHROUGH
-		case 'k':
-			term.c.y += sign * MAX(stateNormalMode.motion.amount,1);
-			break;
-		case 'H': term.c.y = 0;
-			  break; //< [numer]H ~ L[number]j is not supported.
-		case 'M': term.c.y = term.bot / 2;
-			  break;
-		case 'L': term.c.y = term.bot;
-			  break; //< [numer]L ~ L[number]k is not supported.
-		case 'G':  //< Differs from vim, but most useful translation.
-			applyPosition(&stateNormalMode.initialPosition);
-			break;
-		case 'l': sign = 1; FALLTHROUGH
-		case 'h':
-		{
-			int32_t const amount = term.c.x 
-				+ sign * MAX(stateNormalMode.motion.amount, 1);
-			term.c.x = amount % term.col;
-			while (term.c.x < 0) { term.c.x += term.col; }
-			term.c.y += floor(1.0 * amount / term.col);
-			break;
-		}
-		case '0':
-			if (!stateNormalMode.motion.amount) { term.c.x = 0; }
-			else { discard = true; }
-			break;
-		case '$': term.c.x = term.col-1; 
-			  break;
-		case 'w': FALLTHROUGH
-		case 'W': FALLTHROUGH
-		case 'e': FALLTHROUGH
-		case 'E': sign = 1; FALLTHROUGH
-		case 'B': FALLTHROUGH
-		case 'b':
-		{
-			char const * const wDelim = ksym[0] <= 90 
-				? wordDelimLarge : wordDelimSmall;
-			uint32_t const wDelimLen = strlen(wDelim);
-			
-			bool const startSpaceIsSeparator = 
-				!(ksym[0] == 'w' || ksym[0] == 'W');
-			// Whether to start & end with offset:
-			bool const performOffset = startSpaceIsSeparator;
-			// Max iteration := One complete hist traversal.
-			uint32_t const maxIter = (HISTSIZE+term.row) * term.col;
-			// Doesn't work exactly as in vim: Linebreak is 
-			// counted as 'normal' separator, hence a jump can 
-			// span multiple lines here.
-			stateNormalMode.motion.amount = 
-				MAX(stateNormalMode.motion.amount, 1);
-			for (; stateNormalMode.motion.amount > 0; stateNormalMode.motion.amount--) {
-				uint8_t state = 0;
-				if (performOffset) { moveLetter(sign); }
-				for (uint32_t cIt = 0; cIt ++ < maxIter; moveLetter(sign)) {
-					if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
-						if (state == 1) {
-							if (performOffset) { moveLetter(-sign); }
-							break;
-						}
-					} else if (state == 0) { state = 1; }
+	if (ctrl) {
+		switch(ksym[0]) {
+			case 'f':
+			case 'b':
+				break;
+			case 'u': // Half screen up
+				while ((term.scr -= sign * term.row / 2) < 0) {
+					term.scr += HISTSIZE;
 				}
-			}
-			break;
+				break;
+			case 'd': // Half screen down
+				term.scr += sign * term.row / 2;
+				term.scr %= HISTSIZE;
+				break;
+			default:
+				discard = true;
+		}
+
+	} else {
+		switch(ksym[0]) {
+			case 'j': sign = 1; FALLTHROUGH
+			case 'k':
+				  term.c.y += sign * MAX(stateNormalMode.motion.amount,1);
+				  break;
+			case 'H': term.c.y = 0;
+				  break; //< [numer]H ~ L[number]j is not supported.
+			case 'M': term.c.y = term.bot / 2;
+				  break;
+			case 'L': term.c.y = term.bot;
+				  break; //< [numer]L ~ L[number]k is not supported.
+			case 'G':  //< Differs from vim, but most useful translation.
+				  applyPosition(&stateNormalMode.initialPosition);
+				  break;
+			case 'l': sign = 1; FALLTHROUGH
+			case 'h':
+				  {
+					  int32_t const amount = term.c.x
+						  + sign * MAX(stateNormalMode.motion.amount, 1);
+					  term.c.x = amount % term.col;
+					  while (term.c.x < 0) { term.c.x += term.col; }
+					  term.c.y += floor(1.0 * amount / term.col);
+					  break;
+				  }
+			case '0':
+				  if (!stateNormalMode.motion.amount) { term.c.x = 0; }
+				  else { discard = true; }
+				  break;
+			case '$': term.c.x = term.col-1;
+				  break;
+			case 'w': FALLTHROUGH
+			case 'W': FALLTHROUGH
+			case 'e': FALLTHROUGH
+			case 'E': sign = 1; FALLTHROUGH
+			case 'B': FALLTHROUGH
+			case 'b':
+				{
+					  char const * const wDelim = ksym[0] <= 90
+						  ? wordDelimLarge : wordDelimSmall;
+					  uint32_t const wDelimLen = strlen(wDelim);
+
+					  bool const startSpaceIsSeparator =
+						  !(ksym[0] == 'w' || ksym[0] == 'W');
+					  // Whether to start & end with offset:
+					  bool const performOffset = startSpaceIsSeparator;
+					  // Max iteration := One complete hist traversal.
+					  uint32_t const maxIter = (HISTSIZE+term.row) * term.col;
+					  // Doesn't work exactly as in vim: Linebreak is
+					  // counted as 'normal' separator, hence a jump can
+					  // span multiple lines here.
+					  stateNormalMode.motion.amount =
+						  MAX(stateNormalMode.motion.amount, 1);
+					  for (; stateNormalMode.motion.amount > 0; stateNormalMode.motion.amount--) {
+						  uint8_t state = 0;
+						  if (performOffset) { moveLetter(sign); }
+						  for (uint32_t cIt = 0; cIt ++ < maxIter; moveLetter(sign)) {
+							  if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
+								  if (state == 1) {
+									  if (performOffset) { moveLetter(-sign); }
+									  break;
+								  }
+							  } else if (state == 0) { state = 1; }
+						  }
+					  }
+					  break;
+				  }
+			case '/': sign = 1; FALLTHROUGH
+			case '?':
+				  empty(&searchString);
+				  stateNormalMode.motion.search = sign == 1 ? forward : backward;
+				  stateNormalMode.motion.searchPosition.x = term.c.x;
+				  stateNormalMode.motion.searchPosition.y = term.c.y;
+				  stateNormalMode.motion.searchPosition.yScr = term.scr;
+				  stateNormalMode.motion.finished = false;
+				  break;
+			case 'n': sign = 1; FALLTHROUGH
+			case 'N':
+				  toggle = !toggle;
+				  empty(currentCommand);
+				  if (stateNormalMode.motion.search == none) {
+					  stateNormalMode.motion.search = forward;
+					  stateNormalMode.motion.finished = true;
+				  }
+				  if (stateNormalMode.motion.search == backward) { sign *= -1; }
+				  for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); cmdSuccessful && amount > 0; amount--) {
+					  moveLetter(sign);
+					  cmdSuccessful = gotoStringAndHighlight(sign);
+				  }
+				  break;
+			case 't':
+				  if (sel.type == SEL_REGULAR) {
+					  sel.type = SEL_RECTANGULAR;
+				  } else {
+					  sel.type = SEL_REGULAR;
+				  }
+				  tsetdirt(sel.nb.y, sel.ne.y);
+				  break;
+			default:
+				  discard = true;
+				  break;
 		}
-		case '/': sign = 1; FALLTHROUGH
-		case '?':
-			  empty(&searchString);
-			  stateNormalMode.motion.search = sign == 1 ? forward : backward;
-			  stateNormalMode.motion.searchPosition.x = term.c.x;
-			  stateNormalMode.motion.searchPosition.y = term.c.y;
-			  stateNormalMode.motion.searchPosition.yScr = term.scr;
-			  stateNormalMode.motion.finished = false;
-			  break;
-		case 'n': sign = 1; FALLTHROUGH
-		case 'N':
-			  toggle = !toggle;
-			  emptyCurrentCommand();
-			  if (stateNormalMode.motion.search == none) {
-				  stateNormalMode.motion.search = forward;
-				  stateNormalMode.motion.finished = true;
-			  }
-			  if (stateNormalMode.motion.search == backward) { sign *= -1; }
-			  for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); cmdSuccessful && amount > 0; amount--) {
-				  moveLetter(sign);
-				  cmdSuccessful = gotoStringAndHighlight(sign);
-			  }
-			  break;
-		case 't':
-			  if (sel.type == SEL_REGULAR) {
-				  sel.type = SEL_RECTANGULAR;
-			  } else {
-				  sel.type = SEL_REGULAR;
-			  }
-			  tsetdirt(sel.nb.y, sel.ne.y);
-			  discard = true;
-			  break;
-		default:
-			  discard = true;
-			  break;
 	}
 	bool const isNumber = len == 1 && BETWEEN(ksym[0], 48, 57);
 	if (isNumber) { //< record numbers
@@ -756,8 +828,15 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 			}
 		}
 	} else {
-		char* kCommand = checkGetNext(currentCommand);
-		utf8decode(ksym, (Rune*)(kCommand), len);
+		// Append to the current command
+		if (!ctrl) { // XXX: Currently don't store meta inf
+			char* kCommand = expand(currentCommand);
+			if (kCommand == NULL) {
+				empty(currentCommand);
+				return true;
+			}
+			utf8decode(ksym, (Rune*)(kCommand), len);
+		}
 
 		int diff = 0;
 		if (term.c.y > 0) {
@@ -793,7 +872,7 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 			if (!isNumber && (stateNormalMode.motion.search == none
 					|| stateNormalMode.motion.finished)) {
 				toggle = !toggle;
-				emptyCurrentCommand();
+				empty(currentCommand);
 			}
 			if (stateNormalMode.command.op == yank) {
 				if (!isNumber && !discard && stateNormalMode.motion.search == none) {
@@ -810,9 +889,3 @@ ExitState kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc,
 	return cmdSuccessful ? success : failed;
 }
 
- void onMove(void) {
-	stateNormalMode.initialPosition.x = term.c.x;
-	stateNormalMode.initialPosition.y = term.c.y;
-	stateNormalMode.initialPosition.yScr = term.scr;
-}
-
-- 
2.25.0


From 4cfb6fd9f5ae97a6c5c58d741a29318977ed87ae Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Thu, 6 Feb 2020 13:22:25 +0100
Subject: [PATCH 08/23] feat/fix: Page Up, add missing file

closes #9
---
 error.h      | 47 +++++++++++++++++++++++++++
 normalMode.c | 89 +++++++++++++++++++++++++++++++---------------------
 normalMode.h |  6 ++--
 x.c          |  6 ++--
 4 files changed, 107 insertions(+), 41 deletions(-)
 create mode 100644 error.h

diff --git a/error.h b/error.h
new file mode 100644
index 0000000..ad17690
--- /dev/null
+++ b/error.h
@@ -0,0 +1,47 @@
+#ifndef ERROR_H
+#define ERROR_H
+
+#include <assert.h>
+
+// Flag which determines whether to fail if a required condition is not met, or
+// to adapt the condition in order to work properly.
+// Attention: Be sure to perform a clean build after you alter preprocessor
+//            directives / definitions.
+//#define FAIL_ON_ERROR
+
+#include <stdio.h>
+
+///
+/// Function used in case the fail-on-error mode is disabled (via definition)
+/// to report errors. In debug production mode, alias st to st 2> error.log.
+static void reportError(char const * cond, char const * stt, char const * file,
+		unsigned int line ) {
+	unsigned int const maxErrorCount = 100;
+	static int errorCount = 0;
+	if (++errorCount == 1) {
+		printf("Report the following bug to "
+				"https://github.com/juliusHuelsmann/st.\n");
+	}
+	if (errorCount < maxErrorCount) {
+		printf("Bug:\tCondition '%s' evaluates to false.\n\tPerforming"
+				" '%s' to counteract.\n\tFile:%s:%u\n",
+				cond, stt, file, line);
+	} else if (errorCount == maxErrorCount) {
+		printf("Max amount of reported errors %u is reached. From here"
+				"on, no additional errors will be reported.\n",
+				maxErrorCount);
+	}
+}
+
+/// Note that everyting condition checked / endforced with #ENSURE is
+/// considered an error, and behaves like an error depending on the flag.
+#ifdef FAIL_ON_ERROR
+#define ENSURE(cond, stt) assert(cond);
+#else // FAIL_ON_ERROR
+#define ENSURE(cond, stt) if (!(cond)) {                                       \
+                          	reportError(#cond, #stt, __FILE__, __LINE__);  \
+                          	stt;                                           \
+                          }
+#endif // FAIL_ON_ERROR
+
+#endif // ERROR_H
diff --git a/normalMode.c b/normalMode.c
index 5c15cd0..dfae029 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -10,6 +10,9 @@
 #include <limits.h>
 #include <math.h>
 
+#include <X11/keysym.h>
+#include <X11/XKBlib.h>
+
 #define MIN(a, b)		((a) < (b) ? (a) : (b))
 #define MAX(a, b)		((a) < (b) ? (b) : (a))
 #define LEN(a)			(sizeof(a) / sizeof(a)[0])
@@ -366,12 +369,11 @@ static bool gotoStringAndHighlight(int8_t sign) {
 }
 
 static bool pressKeys(char const* nullTerminatedString, size_t end) {
-        bool succ = true;
-	for (size_t i = 0; i < end && succ; ++i) {
-		succ = kpressNormalMode(&nullTerminatedString[i], 1, false,
-				false, nullTerminatedString[i] == '\n', false);
+        bool sc = true;
+	for (size_t i = 0; i < end && sc; ++i) {
+		sc = kpressNormalMode(&nullTerminatedString[i], 1, false, NULL);
 	}
-	return succ;
+	return sc;
 }
 
 static bool executeCommand(DynamicArray const *command) {
@@ -383,8 +385,7 @@ static bool executeCommand(DynamicArray const *command) {
 		char const *const nextRune = view(command, i);
 		if (nextRune == NULL) { return false; }
 		len = utf8encode(*((Rune *) nextRune), decoded);
-		succ = kpressNormalMode(decoded, len, false,
-				false, len == 1 && decoded[0]=='\n', false);
+		succ = kpressNormalMode(decoded, len, false, NULL);
 	}
 	return succ;
 }
@@ -467,7 +468,7 @@ static bool expandExpression(char const c, enum Infix expandMode,
 	if (c == 't') {
 		// XXX: (Bug in vim: @vit )
 		// <tag_name attr="hier" a2="\<sch\>"> [current pos] </tag_name>
-		
+
 		// 1. Copy history ( tag := hist[?<\n:/ \n] )
 		// 2. Copy history ( first_find := hist[?<\n: next place in
 		//                   history where count '>' > count '<'
@@ -518,11 +519,17 @@ highlighted(int x, int y)
 }
 
 ExitState
-kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
-		bool backspace) {
+kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
+
+	bool const kNull = vsym == NULL;
+	KeySym const * const ksym = (KeySym*) vsym;
+	bool const esc = kNull ? false : *ksym == XK_Escape;
+	bool const enter = kNull ? len==1 && cs[0] == '\n' : *ksym == XK_Return;
+	bool const backspace = kNull ? false : *ksym == XK_BackSpace;
+
 	// [ESC] or [ENTER] abort resp. finish the current level of operation.
 	// Typing 'i' if no operation is currently performed behaves like ESC.
-	if (esc || enter || (len == 1 && ksym[0] == 'i' && isMotionFinished()
+	if (esc || enter || (len == 1 && cs[0] == 'i' && isMotionFinished()
 				&& isOperationFinished())) {
 		if (terminateCommand(!enter) ) {
 			applyPosition(&stateNormalMode.initialPosition);
@@ -551,13 +558,13 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 				empty(&searchString);
 				return true;
 			}
-			utf8decode(ksym, (Rune*)(kSearch), len);
+			utf8decode(cs, (Rune*)(kSearch), len);
 			char* kCommand = expand(currentCommand);
 			if (kCommand == NULL) {
 				empty(currentCommand);
 				return true;
 			}
-			utf8decode(ksym, (Rune*)(kCommand), len);
+			utf8decode(cs, (Rune*)(kCommand), len);
 		}
 		applyPosition(&stateNormalMode.motion.searchPosition);
 		bool const result = gotoStringAndHighlight(sign);
@@ -575,11 +582,11 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 	if (len == 0) { return failed; }
 
 	// 'i' mode enabled, hence the expression is to be expanded:
-	// [start_expression(ksym[0])] [operation] [stop_expression(ksym[0])]
+	// [start_expression(cs[0])] [operation] [stop_expression(cs[0])]
 	if (stateNormalMode.command.infix != infix_none) {
 		DynamicArray prefix = CHAR_ARRAY;
 		DynamicArray suffix = CHAR_ARRAY;
-		bool const found = expandExpression(ksym[0],
+		bool const found = expandExpression(cs[0],
 		        stateNormalMode.command.infix, &prefix, &suffix);
 		if (!found) {
 			stateNormalMode.command.infix = infix_none;
@@ -599,7 +606,7 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 			succ = pressKeys(&prefix.content[i], 1);
 		}
 		if (succ) {
-			kpressNormalMode(&operation, 1, false, 0, 0, 0);
+			kpressNormalMode(&operation, 1, false, NULL);
 		}
 		for (int i = 0; i < size(&suffix) && succ; ++i) {
 			succ = pressKeys(&suffix.content[i], 1);
@@ -617,7 +624,7 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 
 
 	// V / v or y take precedence over movement commands.
-	switch(ksym[0]) {
+	switch(cs[0]) {
 		case '.':
 		{
 			if (!isEmpty(currentCommand)) { toggle = !toggle; empty(currentCommand); }
@@ -636,7 +643,7 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 				empty(currentCommand);
 				return true;
 			}
-			utf8decode(ksym, (Rune*)(kCommand), len);
+			utf8decode(cs, (Rune*)(kCommand), len);
 			switch(stateNormalMode.command.op) {
 				case noop:           //< Start yank mode & set #op
 					enableOperation(yank);
@@ -666,7 +673,7 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 		case 'v':                //< Visual Mode: Toggle mode.
 		case 'V':
 		{
-			enum Operation op = ksym[0] == 'v' ? visual : visualLine;
+			enum Operation op = cs[0] == 'v' ? visual : visualLine;
 			bool assign = stateNormalMode.command.op != op;
 			abortCommand();
 			if (assign) {
@@ -676,7 +683,7 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 					empty(currentCommand);
 					return true;
 				}
-				utf8decode(ksym, (Rune*)(kCommand), len);
+				utf8decode(cs, (Rune*)(kCommand), len);
 				if (op == visualLine) {
 					selstart(0, term.c.y, term.scr, 0);
 					selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
@@ -688,29 +695,41 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 		}
 	}
 	// Perform the movement.
-	int32_t sign = -1;    //< whether a command goes 'forward' (1) or 'backward' (-1)
+	int32_t sign = -1;    //< if command goes 'forward'(1) or 'backward'(-1)
 	bool discard = false; //< discard input, as it does not have a meaning.
 	bool cmdSuccessful = true;
 	if (ctrl) {
-		switch(ksym[0]) {
-			case 'f':
-			case 'b':
+		if (ksym == NULL) { return false; }
+		switch(*ksym) {
+			case XK_f:
+			{
+				int const diff = MAX(term.row - 2, 1);
+				for (term.scr -= diff; term.scr < 0;
+						term.scr += HISTSIZE);
+				term.c.y = 0;
+				break;
+			}
+			case XK_b:
+			{	
+				int const diff = MAX(term.row - 2, 1);
+				term.scr = (term.scr + diff) % HISTSIZE;
+				term.c.y = term.bot;
 				break;
-			case 'u': // Half screen up
+			}
+			case XK_u: // Half screen up
 				while ((term.scr -= sign * term.row / 2) < 0) {
 					term.scr += HISTSIZE;
 				}
 				break;
-			case 'd': // Half screen down
+			case XK_d: // Half screen down
 				term.scr += sign * term.row / 2;
 				term.scr %= HISTSIZE;
 				break;
 			default:
-				discard = true;
+				return false;
 		}
-
 	} else {
-		switch(ksym[0]) {
+		switch(cs[0]) {
 			case 'j': sign = 1; FALLTHROUGH
 			case 'k':
 				  term.c.y += sign * MAX(stateNormalMode.motion.amount,1);
@@ -747,12 +766,12 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 			case 'B': FALLTHROUGH
 			case 'b':
 				{
-					  char const * const wDelim = ksym[0] <= 90
+					  char const * const wDelim = cs[0] <= 90
 						  ? wordDelimLarge : wordDelimSmall;
 					  uint32_t const wDelimLen = strlen(wDelim);
 
 					  bool const startSpaceIsSeparator =
-						  !(ksym[0] == 'w' || ksym[0] == 'W');
+						  !(cs[0] == 'w' || cs[0] == 'W');
 					  // Whether to start & end with offset:
 					  bool const performOffset = startSpaceIsSeparator;
 					  // Max iteration := One complete hist traversal.
@@ -812,18 +831,18 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 				  break;
 		}
 	}
-	bool const isNumber = len == 1 && BETWEEN(ksym[0], 48, 57);
+	bool const isNumber = len == 1 && BETWEEN(cs[0], 48, 57);
 	if (isNumber) { //< record numbers
 		discard = false;
 		stateNormalMode.motion.amount =
-			MIN(SHRT_MAX, stateNormalMode.motion.amount * 10 + ksym[0] - 48);
+			MIN(SHRT_MAX, stateNormalMode.motion.amount * 10 + cs[0] - 48);
 	} else if (!discard) {
 		stateNormalMode.motion.amount = 0;
 	}
 
 	if (discard) {
 		for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
-			if (ksym[0] == normalModeShortcuts[i].key) {
+			if (cs[0] == normalModeShortcuts[i].key) {
 				cmdSuccessful = pressKeys(normalModeShortcuts[i].value, strlen(normalModeShortcuts[i].value));
 			}
 		}
@@ -835,7 +854,7 @@ kpressNormalMode(char const * ksym, int len, bool ctrl, bool esc, bool enter,
 				empty(currentCommand);
 				return true;
 			}
-			utf8decode(ksym, (Rune*)(kCommand), len);
+			utf8decode(cs, (Rune*)(kCommand), len);
 		}
 
 		int diff = 0;
diff --git a/normalMode.h b/normalMode.h
index b78ca15..7d88259 100644
--- a/normalMode.h
+++ b/normalMode.h
@@ -28,9 +28,9 @@ void onMove(void);
 int highlighted(int, int);
 
 /// Handles keys in normal mode.
-ExitState kpressNormalMode(
-		char const * ksym, int len, bool ctrlPressed,
-		bool esc, bool enter, bool backspace);
+ExitState kpressNormalMode(char const * decoded, int len, bool ctrlPressed,
+		void const * ksym);
+		//bool esc, bool enter, bool backspace, void* keysym);
 
 
 #endif // NORMAL_MODE_H
diff --git a/x.c b/x.c
index 9d92f5b..b61f866 100644
--- a/x.c
+++ b/x.c
@@ -1759,9 +1759,9 @@ kpress(XEvent *ev)
 	len = XmbLookupString(xw.xic, e, buf, sizeof buf, &ksym, &status);
 	if (IS_SET(MODE_NORMAL)) {
 		ExitState const es = kpressNormalMode(buf, strlen(buf),
-				match(ControlMask, e->state), ksym == XK_Escape,
-			       	ksym == XK_Return, ksym == XK_BackSpace); 
-		if (es == finished) { normalMode(NULL); } 
+				match(ControlMask, e->state),
+				&ksym);
+		if (es == finished) { normalMode(NULL); }
 		return; //if (es != failed) { return; }
 	}
 
-- 
2.25.0


From b250daf3e3ad369e3bc6a518dfedd8287f9f9607 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Thu, 6 Feb 2020 14:10:42 +0100
Subject: [PATCH 09/23] chore: improve up / down motions

Contributes to #9
---
 error.h      |  2 +-
 normalMode.c | 16 ++++++----------
 2 files changed, 7 insertions(+), 11 deletions(-)

diff --git a/error.h b/error.h
index ad17690..91c621f 100644
--- a/error.h
+++ b/error.h
@@ -17,7 +17,7 @@
 static void reportError(char const * cond, char const * stt, char const * file,
 		unsigned int line ) {
 	unsigned int const maxErrorCount = 100;
-	static int errorCount = 0;
+	static unsigned int errorCount = 0;
 	if (++errorCount == 1) {
 		printf("Report the following bug to "
 				"https://github.com/juliusHuelsmann/st.\n");
diff --git a/normalMode.c b/normalMode.c
index dfae029..aebad10 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -704,26 +704,22 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			case XK_f:
 			{
 				int const diff = MAX(term.row - 2, 1);
-				for (term.scr -= diff; term.scr < 0;
-						term.scr += HISTSIZE);
+				term.scr = MAX(term.scr - diff, 0);
 				term.c.y = 0;
 				break;
 			}
 			case XK_b:
 			{	
 				int const diff = MAX(term.row - 2, 1);
-				term.scr = (term.scr + diff) % HISTSIZE;
+				term.scr = MIN(term.scr + diff, HISTSIZE);
 				term.c.y = term.bot;
 				break;
 			}
-			case XK_u: // Half screen up
-				while ((term.scr -= sign * term.row / 2) < 0) {
-					term.scr += HISTSIZE;
-				}
+			case XK_u:
+				term.scr = MIN(term.scr + term.row/2, HISTSIZE);
 				break;
-			case XK_d: // Half screen down
-				term.scr += sign * term.row / 2;
-				term.scr %= HISTSIZE;
+			case XK_d:
+				term.scr = MAX(term.scr - term.row / 2, 0);
 				break;
 			default:
 				return false;
-- 
2.25.0


From 7a9eb162a1eb98367e6e8b8f558ca74e6b5d761a Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Sat, 8 Feb 2020 23:35:50 +0100
Subject: [PATCH 10/23] chore: fix + style

---
 config.def.h |   4 +-
 normalMode.c | 768 ++++++++++++++++++++++-----------------------------
 term.h       |   2 +-
 3 files changed, 326 insertions(+), 448 deletions(-)

diff --git a/config.def.h b/config.def.h
index 41b3626..8f5697e 100644
--- a/config.def.h
+++ b/config.def.h
@@ -487,7 +487,7 @@ struct NormalModeShortcuts normalModeShortcuts [] = {
 size_t const amountNormalModeShortcuts = sizeof(normalModeShortcuts) / sizeof(*normalModeShortcuts);
 
 /// Style of the command string visualized in normal mode in the right corner.
-Glyph const styleCommand = {'c', ATTR_ITALIC | ATTR_FAINT, 7, 0};
+Glyph const styleCommand = {'c', ATTR_ITALIC | ATTR_FAINT, 7, 258};
 
 /// Style of the search string visualized in normal mode in the right corner.
-Glyph const styleSearch = {'c', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 0};
+Glyph const styleSearch = {'c', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 258};
diff --git a/normalMode.c b/normalMode.c
index aebad10..75c36ad 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -13,11 +13,24 @@
 #include <X11/keysym.h>
 #include <X11/XKBlib.h>
 
-#define MIN(a, b)		((a) < (b) ? (a) : (b))
-#define MAX(a, b)		((a) < (b) ? (b) : (a))
-#define LEN(a)			(sizeof(a) / sizeof(a)[0])
-#define BETWEEN(x, a, b)	((a) <= (x) && (x) <= (b))
-#define FALLTHROUGH		__attribute__((fallthrough));
+#define LEN(a)                 (sizeof(a) / sizeof(a)[0])
+#define BETWEEN(x, a, b)       ((a) <= (x) && (x) <= (b))
+#define FALLTHROUGH            __attribute__((fallthrough));
+#define SEC(var,ini,h,r)       var = ini; if (!var) { h; return r; }
+#define EXPAND(v1,v2,r)        char *SEC(v1, expand(v2), empty(v2), true)
+
+static inline int intervalDiff(int v, int a, int b) {
+	return (v < a) ? (v - a) : ((v > b) ? (v - b) : 0);
+}
+
+static inline void swap(DynamicArray *const a, DynamicArray *const b) {
+	DynamicArray tmp = *a;
+	*a = *b;
+	*b = tmp;
+}
+
+static inline int max(int a, int b) { return a > b ? a : b; }
+static inline int min(int a, int b) { return a < b ? a : b; }
 
 //
 // Interface to the terminal
@@ -88,7 +101,7 @@ NormalModeState defaultNormalMode = {
 };
 
 /// Default state if no operation is performed.
-NormalModeState stateNormalMode = {
+NormalModeState stateVB = {
 	{0,0,0},
 	{noop, {0, 0, 0}, false},
 	{0, none, {0, 0, 0}, true}
@@ -132,14 +145,32 @@ applyPosition(Position const *pos) {
 
 static inline int
 getSearchDirection(void) {
-	return stateNormalMode.motion.search == forward ? 1 : -1;
+	return stateVB.motion.search == forward ? 1 : -1;
+}
+
+//  Utilities for working with the current version of the scrollback patch.
+
+static bool moveLine(int32_t const amount) {
+	int32_t const reqShift = intervalDiff(term.c.y+=amount, 0, term.row-1);
+	term.c.y -= reqShift;
+	int32_t const sDiff = intervalDiff(term.scr-=reqShift, 0, HISTSIZE-1);
+	term.scr -= sDiff;
+	return sDiff == 0;
+}
+
+static void moveLetter(int32_t const amount) {
+	int32_t value = (term.c.x += amount) / term.col;
+	if (value -= (term.c.x < 0)) {
+		term.c.x = moveLine(value) ? mod(term.c.x, term.col)
+			: max(min(term.c.x,term.col), 0);
+	}
 }
 
 //
 // `Private` functions:
 //
 
-// Fuctions: Temporarily display string on screen .
+// Fuctions: Temporarily display string on screen.
 
 ///
 /// Display string at end of a specified line without writing it into the bufer.
@@ -161,7 +192,7 @@ static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
 		return;
 	}
 	// Determine the dimensions of used chunk of screen.
-	uint32_t const overrideSize = MIN(size(str),
+	uint32_t const overrideSize = min(size(str),
 			term.col / maxFractionOverridden);               // (1)
 	uint32_t const overrideEnd = term.col - 1;
 	// Has to follow trivially hence th assert:
@@ -169,14 +200,11 @@ static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
 	assert(overrideSize <= overrideEnd + 1);
 	uint32_t const overrideStart = 1 + overrideEnd - overrideSize;
 
-	Line line = malloc(sizeof(Glyph) * overrideSize);
-	assert(str->index - 1 >=  overrideSize - 1); //< triv. from (1).
-	if (line == NULL) { return; }
+	Line SEC(line, malloc(sizeof(Glyph) * overrideSize),,)
 
 	for (uint32_t lineIdx = 0; lineIdx < overrideSize; ++lineIdx) {
 		line[lineIdx] = *g;
-		char* end = viewEnd(str, overrideSize - lineIdx - 1);
-		if (end == NULL) { break; }
+		char * SEC(end, viewEnd(str, overrideSize - lineIdx - 1),,)
 		memcpy(&line[lineIdx].u, end, str->itemSize);
 	}
 	xdrawline(TLINE(yPos), 0, yPos, overrideStart);
@@ -199,30 +227,43 @@ static inline void printSearchString(void) {
 // NormalMode Operation / Motion utilies.
 
 
-static inline void enableOperation(enum Operation o) {
-	stateNormalMode.command.op = o;
-	stateNormalMode.command.infix = infix_none;
-	stateNormalMode.command.startPosition.x = term.c.x;
-	stateNormalMode.command.startPosition.y = term.c.y;
-	stateNormalMode.command.startPosition.yScr = term.scr;
-}
-
 static inline bool isMotionFinished(void) {
-	return stateNormalMode.motion.finished;
+	return stateVB.motion.finished;
 }
 
 static inline void finishMotion(void) {
-	stateNormalMode.motion.finished = true;
+	stateVB.motion.finished = true;
 }
 
 static inline bool isOperationFinished(void) {
-	return stateNormalMode.command.op == noop
-		&& stateNormalMode.command.infix == infix_none;
+	return stateVB.command.op == noop
+		&& stateVB.command.infix == infix_none;
+}
+
+/// Register that the current comamnd is finished and a new command is lgoged
+static inline  void startNewCommand(bool abort) {
+	if (!abort) { toggle = !toggle; }
+	empty(currentCommand);
 }
 
 static inline void finishOperation(void) {
-	stateNormalMode.command = defaultNormalMode.command;
+	stateVB.command = defaultNormalMode.command;
 	assert(isOperationFinished());
+	// After an operation is finished, the selection has to be released and
+	// no highlights are to be released.
+	selclear();
+	empty(&highlights);
+	// THe command string is reset for a new command.
+	startNewCommand(true);
+}
+
+static inline void enableOperation(enum Operation o) {
+	finishOperation();
+	stateVB.command.op = o;
+	stateVB.command.infix = infix_none;
+	stateVB.command.startPosition.x = term.c.x;
+	stateVB.command.startPosition.y = term.c.y;
+	stateVB.command.startPosition.yScr = term.scr;
 }
 
 /// @param abort: If enabled, the command exits without registering
@@ -236,12 +277,6 @@ static bool terminateCommand(bool abort) {
 	if (exitOperation) {
 		exitNormalMode = isOperationFinished();
 		finishOperation();
-		selclear();
-
-		empty(currentCommand);
-		if (!abort) { toggle = !toggle; }
-
-		empty(&highlights);
 	}
 	printCommandString();
 	printSearchString();
@@ -252,71 +287,28 @@ static inline void exitCommand(void) { terminateCommand(false); }
 
 static inline void abortCommand(void) { terminateCommand(true); }
 
-static void moveLine(int8_t sign) {
-	if (sign == -1) {
-		if (term.c.y-- == 0) {
-			if (++term.scr == HISTSIZE) {
-				term.c.y = term.row - 1;
-				term.scr = 0;
-			} else {
-				term.c.y = 0;
-			}
-		}
-	} else {
-		term.c.x = 0;
-		if (++term.c.y == term.row) {
-			if (term.scr-- == 0) {
-				term.c.y = 0;
-				term.scr = HISTSIZE - 1;
-			} else {
-				term.c.y = term.row - 1;
-			}
-		}
-	}
-}
-
-static void moveLetter(int8_t sign) {
-	term.c.x += sign;
-	if (!BETWEEN(term.c.x, 0, term.col-1)) {
-		if (term.c.x < 0) {
-			term.c.x = term.col - 1;
-			moveLine(sign);
-		} else {
-			term.c.x = 0;
-			moveLine(sign);
-		}
-	}
-}
-
 /// Go to next occurrence of string relative to the current location
 /// conduct search, starting at start pos
-static bool
-gotoString(int8_t sign) {
+static bool gotoString(int8_t sign) {
+	moveLetter(sign);
 	uint32_t const searchStrSize = size(&searchString);
 	uint32_t const maxIter = (HISTSIZE+term.row) * term.col + searchStrSize;
 	uint32_t findIdx = 0;
 	for (uint32_t cIteration = 0; findIdx < searchStrSize
-			&& cIteration ++ < maxIter; moveLetter(sign)) {
-		char const *const next = sign==1 ? view(&searchString, findIdx)
-			: viewEnd(&searchString, findIdx);
-		if (next == NULL) { return false; }
+			&& ++cIteration <= maxIter; moveLetter(sign)) {
+		char const * const SEC(next, sign==1 
+				? view(&searchString, findIdx)
+				: viewEnd(&searchString, findIdx), , false)
 		uint32_t const searchChar = *((uint32_t*) next);
 
 		if (TLINE(term.c.y)[term.c.x].u == searchChar) { ++findIdx; }
 		else { findIdx = 0; }
 	}
 	bool const found = findIdx == searchStrSize;
-	if (found) { for (uint32_t i = 0; i < searchStrSize; i++) { moveLetter(-sign); } }
+	for (uint32_t i = 0; found && i < searchStrSize; ++i) moveLetter(-sign);
 	return found;
 }
 
-/// Find the next occurrence of a word
-static inline bool
-gotoNextString(int8_t sign) {
-	moveLetter(sign);
-	return gotoString(sign);
-}
-
 /// Highlight all found strings on the current screen.
 static void
 highlightStringOnScreen(void) {
@@ -327,8 +319,7 @@ highlightStringOnScreen(void) {
 	bool success = true;
 	for (int y = 0; y < term.row && success; y++) {
 		for (int x = 0; x < term.col && success; x++) {
-			char const * const next = view(&searchString, findIdx);
-			if (next == NULL) { return; }
+			char const* const SEC(next,view(&searchString,findIdx),,)
 
 			if (TLINE(y)[x].u == *((uint32_t*)(next))) {
 				if (++findIdx == 1) {
@@ -361,7 +352,7 @@ static bool gotoStringAndHighlight(int8_t sign) {
 	if (found) {
 		highlightStringOnScreen();
 	} else {
-		applyPosition(&stateNormalMode.motion.searchPosition);
+		applyPosition(&stateVB.motion.searchPosition);
 	}
 	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
 	                                      //  is painted separately.
@@ -382,8 +373,7 @@ static bool executeCommand(DynamicArray const *command) {
 	bool succ = true;
 	size_t len;
 	for (size_t i = 0; i < end && succ; ++i) {
-		char const *const nextRune = view(command, i);
-		if (nextRune == NULL) { return false; }
+		char const *const SEC(nextRune, view(command, i),,false)
 		len = utf8encode(*((Rune *) nextRune), decoded);
 		succ = kpressNormalMode(decoded, len, false, NULL);
 	}
@@ -408,10 +398,9 @@ struct {
 /// @param first, second: Dynamic arrays in which the prefix and postfix
 ///                       commands will be returned
 /// @return               whether the command could be extracted successfully.
-static bool expandExpression(char const c, enum Infix expandMode,
-		DynamicArray *fst, DynamicArray *snd) {
-	empty(fst);
-	empty(snd);
+static bool expandExpression(char const c, enum Infix expandMode, 
+		char operation, DynamicArray *cmd) {
+	empty(cmd);
 	bool s = true; //< used in order to detect memory allocation errors.
 	char const lower = tolower(c);
 	// Motions
@@ -420,49 +409,54 @@ static bool expandExpression(char const c, enum Infix expandMode,
 		// file even when at the fist letter. Does not work for single
 		// letter words though.
 		int const diff = c - lower;
-		s = s && checkSetNextV(fst, c);
-		s = s && checkSetNextV(fst, (signed char)(((int)'b') + diff));
-		s = s && checkSetNextV(snd, (signed char)(((int)'e')+ diff));
+		s = s && checkSetNextV(cmd, c);
+		s = s && checkSetNextV(cmd, (signed char)(((int)'b') + diff));
+		s = s && checkSetNextV(cmd, operation);
+		s = s && checkSetNextV(cmd, (signed char)(((int)'e')+ diff));
 		return s;
 	}
 	// Symmetrical brackets (quotation marks)
 	if (c == '\'' || c == '"') {
+		// Local ambiguity -> do nothing. It cannot be determined if 
+		// the current char is the 1st or last char of the selection.
+		//  <---- search here? -- ['] -- or search here? --->
 		if (TLINE(term.c.y)[term.c.x].u == c) {
-			// Local ambiguity -> do nothing. It cannot be
-			// determined if the current character is the fst
-			// character of the selection or the snd one.
-			//  <---- search here? -- ['] -- or search here? --->
 			return false;
 		}
-		// ?[c]\nl
+		// Prefix
 		char res [] = {'?', c, '\n'};
-		s = s && checkSetNextP(fst, res);
-		s = s && checkSetNextV(expandMode == infix_i?fst:snd, 'l');
+		s = s && checkSetNextP(cmd, res);
+		// infix
+		bool const iffy = expandMode == infix_i;
+		if (iffy) { s = s && checkSetNextV(cmd, 'l'); }
+		s = s && checkSetNextV(cmd, operation); 
+		if (!iffy) { s = s && checkSetNextV(cmd, 'l'); }
+		// suffix
 		res[0] = '/';
-		s = s && checkSetNextP(snd, res);
-		if (expandMode == infix_i) s = s && checkSetNextV(snd, 'h');
+		s = s && checkSetNextP(cmd, res);
+		if (iffy) { s = s && checkSetNextV(cmd, 'h'); }
 		return s;
 	}
 	// Brackets: Does not if in range / if the brackets belong togehter.
 	for (size_t pid = 0; pid < sizeof(Brackets); ++pid) {
 		if(Brackets[pid].first == c || Brackets[pid].second == c) {
-			if (TLINE(term.c.y)[term.c.x].u ==Brackets[pid].first) {
-				s = s && checkSetNextV(fst, 'l');
-			}
-			s = s && checkSetNextV(fst, '?');
-			s = s && checkSetNextV(fst, Brackets[pid].first);
-			s = s && checkSetNextV(fst, '\n');
-			s = s && checkSetNextV(
-					expandMode == infix_i ? fst : snd, 'l');
-			s = s && checkSetNextV(snd, '/');
-			s = s && checkSetNextV(snd, Brackets[pid].second);
-			s = s && checkSetNextV(snd, '\n');
-			if (expandMode == infix_i) {
-				s = s && checkSetNextV(snd, 'h');
+			if (TLINE(term.c.y)[term.c.x].u!=Brackets[pid].first) {
+				s = s && checkSetNextV(cmd, '?');
+				s = s && checkSetNextV(cmd, Brackets[pid].first);
+				s = s && checkSetNextV(cmd, '\n');
 			}
+			bool const iffy = expandMode == infix_i;
+			if (iffy) { s = s && checkSetNextV(cmd, 'l'); }
+			s = s && checkSetNextV(cmd, operation); 
+			if (!iffy) { s = s && checkSetNextV(cmd, 'l'); }
+			s = s && checkSetNextV(cmd, '/');
+			s = s && checkSetNextV(cmd, Brackets[pid].second);
+			s = s && checkSetNextV(cmd, '\n');
+			if (iffy) { s = s && checkSetNextV(cmd, 'h'); }
 			return s;
 		}
-	}
+	} 
+	/**/
 	// search string
 	// complicated search operation: <tag>
 	if (c == 't') {
@@ -486,15 +480,14 @@ static bool expandExpression(char const c, enum Infix expandMode,
 
 void
 onMove(void) {
-	stateNormalMode.initialPosition.x = term.c.x;
-	stateNormalMode.initialPosition.y = term.c.y;
-	stateNormalMode.initialPosition.yScr = term.scr;
+	stateVB.initialPosition.x = term.c.x;
+	stateVB.initialPosition.y = term.c.y;
+	stateVB.initialPosition.yScr = term.scr;
 }
 
 
 int
-highlighted(int x, int y)
-{
+highlighted(int x, int y) {
 	// Compute the legal bounds for a hit:
 	int32_t const stringSize = size(&searchString);
 	int32_t xMin = x - stringSize;
@@ -520,387 +513,272 @@ highlighted(int x, int y)
 
 ExitState
 kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
-
-	bool const kNull = vsym == NULL;
 	KeySym const * const ksym = (KeySym*) vsym;
-	bool const esc = kNull ? false : *ksym == XK_Escape;
-	bool const enter = kNull ? len==1 && cs[0] == '\n' : *ksym == XK_Return;
-	bool const backspace = kNull ? false : *ksym == XK_BackSpace;
-
+	bool const esc = ksym &&  *ksym == XK_Escape;
+	bool const enter = (ksym && *ksym==XK_Return) || (len==1 &&cs[0]=='\n');
+	bool const quantifier = len == 1 && (BETWEEN(cs[0], 49, 57) 
+			|| (cs[0] == 48 && stateVB.motion.amount));
 	// [ESC] or [ENTER] abort resp. finish the current level of operation.
 	// Typing 'i' if no operation is currently performed behaves like ESC.
 	if (esc || enter || (len == 1 && cs[0] == 'i' && isMotionFinished()
 				&& isOperationFinished())) {
 		if (terminateCommand(!enter) ) {
-			applyPosition(&stateNormalMode.initialPosition);
-			stateNormalMode = defaultNormalMode;
+			applyPosition(&stateVB.initialPosition);
+			stateVB = defaultNormalMode;
 			tfulldirt();
 			return finished;
 		}
-		return success;
+		goto motionFinish;
 	}
 	// Search: append to search string, then search & highlight
-	if (stateNormalMode.motion.search != none
-			&& !stateNormalMode.motion.finished) {
-		int8_t const sign = getSearchDirection();
-		// Append or remove current letter from command & searchString.
-		if (backspace) {
+	if (stateVB.motion.search != none && !stateVB.motion.finished) {
+		if (ksym && *ksym == XK_BackSpace) {
 			if (!isEmpty(currentCommand)) { pop(currentCommand); }
 			if (!isEmpty(&searchString)) { pop(&searchString); }
 			if (isEmpty(&searchString)) {
 				exitCommand();
 				return success;
 			}
-		} else {
-			if (len < 1) { return true; }
-			char* kSearch = expand(&searchString);
-			if (kSearch == NULL) {
-				empty(&searchString);
-				return true;
-			}
+		} else if (len >= 1) {
+			EXPAND(kSearch, &searchString, true)
 			utf8decode(cs, (Rune*)(kSearch), len);
-			char* kCommand = expand(currentCommand);
-			if (kCommand == NULL) {
-				empty(currentCommand);
-				return true;
-			}
-			utf8decode(cs, (Rune*)(kCommand), len);
-		}
-		applyPosition(&stateNormalMode.motion.searchPosition);
-		bool const result = gotoStringAndHighlight(sign);
-
-		if (stateNormalMode.command.op == visual) {
-			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
-		} else if  (stateNormalMode.command.op == visualLine) {
-			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
-		}
-		printCommandString();
-		printSearchString();
-		return result ? success : failed;
+		} else { return success; }
+		applyPosition(&stateVB.motion.searchPosition);
+		gotoStringAndHighlight(getSearchDirection());
+		goto finish;
 	}
-
 	if (len == 0) { return failed; }
-
+	// Quantifiers
+	if (quantifier) {
+		stateVB.motion.amount = min(SHRT_MAX, 
+				stateVB.motion.amount * 10 + cs[0] - 48);
+		goto finish;
+	}
 	// 'i' mode enabled, hence the expression is to be expanded:
 	// [start_expression(cs[0])] [operation] [stop_expression(cs[0])]
-	if (stateNormalMode.command.infix != infix_none) {
-		DynamicArray prefix = CHAR_ARRAY;
-		DynamicArray suffix = CHAR_ARRAY;
-		bool const found = expandExpression(cs[0],
-		        stateNormalMode.command.infix, &prefix, &suffix);
-		if (!found) {
-			stateNormalMode.command.infix = infix_none;
-			free(prefix.content);
-			free(suffix.content);
-			return failed;
+	if (stateVB.command.infix != infix_none && stateVB.command.op != noop) {
+		DynamicArray cmd = CHAR_ARRAY;
+		char const operation = stateVB.command.op;
+		bool succ = expandExpression(cs[0], 
+				stateVB.command.infix, visual, &cmd);
+		if (operation == yank) {
+			succ = succ && checkSetNextV(&cmd, operation);
 		}
 
-		char const operation = stateNormalMode.command.op;
-		NormalModeState const st = stateNormalMode;
-		TCursor const tc = term.c;
-		stateNormalMode.command.op = noop;
-		stateNormalMode.command.infix = infix_none;
-
-		bool succ = true;
-		for (int i = 0; i < size(&prefix) && succ; ++i) {
-			succ = pressKeys(&prefix.content[i], 1);
-		}
+		NormalModeState const st = stateVB;
+		TCursor         const tc = term.c;
+		stateVB.command.infix    = infix_none;
 		if (succ) {
-			kpressNormalMode(&operation, 1, false, NULL);
-		}
-		for (int i = 0; i < size(&suffix) && succ; ++i) {
-			succ = pressKeys(&suffix.content[i], 1);
-		}
-
-		if (!succ) { // go back to the old position, apply op
-			stateNormalMode = st;
-			term.c = tc;
+			stateVB.command.op = noop;
+			for (int i = 0; i < size(&cmd) && succ; ++i) {
+				succ = pressKeys(&cmd.content[i], 1);
+			}
+			if (!succ) { // go back to the old position, apply op
+				stateVB = st;
+				term.c = tc;
+			}
+			swap(&cmd, currentCommand);
 		}
-
-		free(prefix.content);
-		free(suffix.content);
-		return succ ? success : failed;
+		free(cmd.content);
+		goto finishNoAppend;
 	}
-
-
-	// V / v or y take precedence over movement commands.
+	// Commands (V / v or y)
 	switch(cs[0]) {
 		case '.':
 		{
-			if (!isEmpty(currentCommand)) { toggle = !toggle; empty(currentCommand); }
-			return executeCommand(lastCommand) ? success : failed;
+			DynamicArray cmd = UTF8_ARRAY;
+			swap(&cmd, currentCommand);
+			executeCommand(&cmd) ? success : failed;
+			swap(&cmd, currentCommand);
+			goto finishNoAppend;
 		}
-		case 'i':
-			stateNormalMode.command.infix = infix_i;
-			return success;
-		case 'a':
-			stateNormalMode.command.infix = infix_a;
-			return success;
-		case 'y': //< Yank mode
-		{
-			char* kCommand = expand(currentCommand);
-			if (kCommand == NULL) {
-				empty(currentCommand);
-				return true;
-			}
-			utf8decode(cs, (Rune*)(kCommand), len);
-			switch(stateNormalMode.command.op) {
-				case noop:           //< Start yank mode & set #op
+		case 'i': stateVB.command.infix = infix_i; goto finish;
+		case 'a': stateVB.command.infix = infix_a; goto finish;
+		case 'y':
+			switch(stateVB.command.op) {
+				case noop: //< Start yank mode & set #op
 					enableOperation(yank);
-					selstart(term.c.x, term.c.y, term.scr, 0);
-					empty(currentCommand);
-					break;
-				case visualLine:     //< Complete yank operation
-				case visual:
-					xsetsel(getsel());     //< yank
-					xclipcopy();
-					exitCommand();         //< reset command
-					break;
-				case yank:           //< Complete yank operation as in y#amount j
+					selstart(term.c.x, term.c.y,term.scr,0);
+					goto finish;
+				case yank: //< Complete yank [y#amount j]
 					selstart(0, term.c.y, term.scr, 0);
 					int const origY = term.c.y;
-					for (uint32_t i = 1; i < MAX(stateNormalMode.motion.amount, 1); ++i) moveLine(1);
-					selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
+					moveLine(max(stateVB.motion.amount, 1));
+					selextend(term.col-1,term.c.y,term.scr, 
+							SEL_RECTANGULAR, 0);
+					term.c.y = origY;
+					FALLTHROUGH
+				case visualLine: // Yank visual selection
+				case visual:
 					xsetsel(getsel());
 					xclipcopy();
-					term.c.y = origY;
 					exitCommand();
+					goto finish;
+				default: 
+					return failed;
 			}
-			printCommandString();
-			printSearchString();
-			return success;
-		}
-		case 'v':                //< Visual Mode: Toggle mode.
-		case 'V':
-		{
-			enum Operation op = cs[0] == 'v' ? visual : visualLine;
-			bool assign = stateNormalMode.command.op != op;
-			abortCommand();
-			if (assign) {
-				enableOperation(op);
-				char* kCommand = expand(currentCommand);
-				if (kCommand == NULL) {
-					empty(currentCommand);
-					return true;
-				}
-				utf8decode(cs, (Rune*)(kCommand), len);
-				if (op == visualLine) {
-					selstart(0, term.c.y, term.scr, 0);
-					selextend(term.col-1, term.c.y, term.scr, SEL_RECTANGULAR, 0);
-				} else {
-					selstart(term.c.x, term.c.y, term.scr, 0);
-				}
+		case visual:
+		case visualLine:
+			if (stateVB.command.op == cs[0]) { 
+				finishOperation(); 
+				return true;
+			} else {
+				enableOperation(cs[0]);
+				selstart(cs[0] == visualLine ? 0 : term.c.x, 
+						term.c.y, term.scr, 0);
+				goto finish;
 			}
-			return success;
-		}
 	}
-	// Perform the movement.
+	// CTRL Motions
 	int32_t sign = -1;    //< if command goes 'forward'(1) or 'backward'(-1)
-	bool discard = false; //< discard input, as it does not have a meaning.
-	bool cmdSuccessful = true;
 	if (ctrl) {
 		if (ksym == NULL) { return false; }
 		switch(*ksym) {
 			case XK_f:
-			{
-				int const diff = MAX(term.row - 2, 1);
-				term.scr = MAX(term.scr - diff, 0);
+				term.scr = max(term.scr - max(term.row-2,1), 0);
 				term.c.y = 0;
-				break;
-			}
+				goto finish;
 			case XK_b:
-			{	
-				int const diff = MAX(term.row - 2, 1);
-				term.scr = MIN(term.scr + diff, HISTSIZE);
+				term.scr = min(term.scr + max(term.row - 2, 1),
+						HISTSIZE);
 				term.c.y = term.bot;
-				break;
-			}
+				goto finish;
 			case XK_u:
-				term.scr = MIN(term.scr + term.row/2, HISTSIZE);
-				break;
+				term.scr = min(term.scr + term.row/2, HISTSIZE);
+				goto finish;
 			case XK_d:
-				term.scr = MAX(term.scr - term.row / 2, 0);
+				term.scr = max(term.scr - term.row / 2, 0);
 				break;
-			default:
-				return false;
-		}
-	} else {
-		switch(cs[0]) {
-			case 'j': sign = 1; FALLTHROUGH
-			case 'k':
-				  term.c.y += sign * MAX(stateNormalMode.motion.amount,1);
-				  break;
-			case 'H': term.c.y = 0;
-				  break; //< [numer]H ~ L[number]j is not supported.
-			case 'M': term.c.y = term.bot / 2;
-				  break;
-			case 'L': term.c.y = term.bot;
-				  break; //< [numer]L ~ L[number]k is not supported.
-			case 'G':  //< Differs from vim, but most useful translation.
-				  applyPosition(&stateNormalMode.initialPosition);
-				  break;
-			case 'l': sign = 1; FALLTHROUGH
-			case 'h':
-				  {
-					  int32_t const amount = term.c.x
-						  + sign * MAX(stateNormalMode.motion.amount, 1);
-					  term.c.x = amount % term.col;
-					  while (term.c.x < 0) { term.c.x += term.col; }
-					  term.c.y += floor(1.0 * amount / term.col);
-					  break;
-				  }
-			case '0':
-				  if (!stateNormalMode.motion.amount) { term.c.x = 0; }
-				  else { discard = true; }
-				  break;
-			case '$': term.c.x = term.col-1;
-				  break;
-			case 'w': FALLTHROUGH
-			case 'W': FALLTHROUGH
-			case 'e': FALLTHROUGH
-			case 'E': sign = 1; FALLTHROUGH
-			case 'B': FALLTHROUGH
-			case 'b':
-				{
-					  char const * const wDelim = cs[0] <= 90
-						  ? wordDelimLarge : wordDelimSmall;
-					  uint32_t const wDelimLen = strlen(wDelim);
-
-					  bool const startSpaceIsSeparator =
-						  !(cs[0] == 'w' || cs[0] == 'W');
-					  // Whether to start & end with offset:
-					  bool const performOffset = startSpaceIsSeparator;
-					  // Max iteration := One complete hist traversal.
-					  uint32_t const maxIter = (HISTSIZE+term.row) * term.col;
-					  // Doesn't work exactly as in vim: Linebreak is
-					  // counted as 'normal' separator, hence a jump can
-					  // span multiple lines here.
-					  stateNormalMode.motion.amount =
-						  MAX(stateNormalMode.motion.amount, 1);
-					  for (; stateNormalMode.motion.amount > 0; stateNormalMode.motion.amount--) {
-						  uint8_t state = 0;
-						  if (performOffset) { moveLetter(sign); }
-						  for (uint32_t cIt = 0; cIt ++ < maxIter; moveLetter(sign)) {
-							  if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
-								  if (state == 1) {
-									  if (performOffset) { moveLetter(-sign); }
-									  break;
-								  }
-							  } else if (state == 0) { state = 1; }
-						  }
-					  }
-					  break;
-				  }
-			case '/': sign = 1; FALLTHROUGH
-			case '?':
-				  empty(&searchString);
-				  stateNormalMode.motion.search = sign == 1 ? forward : backward;
-				  stateNormalMode.motion.searchPosition.x = term.c.x;
-				  stateNormalMode.motion.searchPosition.y = term.c.y;
-				  stateNormalMode.motion.searchPosition.yScr = term.scr;
-				  stateNormalMode.motion.finished = false;
-				  break;
-			case 'n': sign = 1; FALLTHROUGH
-			case 'N':
-				  toggle = !toggle;
-				  empty(currentCommand);
-				  if (stateNormalMode.motion.search == none) {
-					  stateNormalMode.motion.search = forward;
-					  stateNormalMode.motion.finished = true;
-				  }
-				  if (stateNormalMode.motion.search == backward) { sign *= -1; }
-				  for (int32_t amount = MAX(stateNormalMode.motion.amount, 1); cmdSuccessful && amount > 0; amount--) {
-					  moveLetter(sign);
-					  cmdSuccessful = gotoStringAndHighlight(sign);
-				  }
-				  break;
-			case 't':
-				  if (sel.type == SEL_REGULAR) {
-					  sel.type = SEL_RECTANGULAR;
-				  } else {
-					  sel.type = SEL_REGULAR;
-				  }
-				  tsetdirt(sel.nb.y, sel.ne.y);
-				  break;
-			default:
-				  discard = true;
-				  break;
+			default: return false;
 		}
-	}
-	bool const isNumber = len == 1 && BETWEEN(cs[0], 48, 57);
-	if (isNumber) { //< record numbers
-		discard = false;
-		stateNormalMode.motion.amount =
-			MIN(SHRT_MAX, stateNormalMode.motion.amount * 10 + cs[0] - 48);
-	} else if (!discard) {
-		stateNormalMode.motion.amount = 0;
-	}
-
-	if (discard) {
-		for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
-			if (cs[0] == normalModeShortcuts[i].key) {
-				cmdSuccessful = pressKeys(normalModeShortcuts[i].value, strlen(normalModeShortcuts[i].value));
+	} 
+	// Motions
+	switch(cs[0]) {
+		case 'j': sign = 1; FALLTHROUGH
+		case 'k': moveLine(max(stateVB.motion.amount,1) * sign);
+			  goto motionFinish;
+		case 'H': term.c.y = 0;
+			  goto motionFinish;
+		case 'M': term.c.y = term.bot / 2; 
+			  goto motionFinish;
+		case 'L': term.c.y = term.bot;
+			  goto motionFinish;
+		case 'G': applyPosition(&stateVB.initialPosition);
+			  goto motionFinish;
+		case 'l': sign = 1; FALLTHROUGH
+		case 'h': moveLetter(sign * max(stateVB.motion.amount,1));
+			  goto motionFinish;
+		case '0': term.c.x = 0; 
+			  goto motionFinish;
+		case '$': term.c.x = term.col-1;
+			  goto motionFinish;
+		case 'w': FALLTHROUGH
+		case 'W': FALLTHROUGH
+		case 'e': FALLTHROUGH
+		case 'E': sign = 1; FALLTHROUGH
+		case 'B': FALLTHROUGH
+		case 'b':
+		{
+			char const * const wDelim = 
+				cs[0] <= 90 ? wordDelimLarge : wordDelimSmall;
+			uint32_t const wDelimLen = strlen(wDelim);
+
+			bool const startSpaceIsSeparator =
+				!(cs[0] == 'w' || cs[0] == 'W');
+			// Whether to start & end with offset:
+			bool const performOffset = startSpaceIsSeparator;
+			// Max iteration := One complete hist traversal.
+			uint32_t const maxIter = (HISTSIZE+term.row) * term.col;
+			// Doesn't work exactly as in vim: Linebreak is
+			// counted as 'normal' separator, hence a jump can
+			// span multiple lines here.
+			stateVB.motion.amount = max(stateVB.motion.amount, 1);
+			for (;stateVB.motion.amount>0;--stateVB.motion.amount) {
+				uint8_t state = 0;
+				if (performOffset) { moveLetter(sign); }
+				for (uint32_t cIt = 0; cIt ++ < maxIter; moveLetter(sign)) {
+					if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
+						if (state == 1) {
+							if (performOffset) { 
+								moveLetter(-sign);
+							}
+							break;
+						}
+					} else if (state == 0) { state = 1; }
+				}
 			}
+			goto motionFinish;
 		}
-	} else {
-		// Append to the current command
-		if (!ctrl) { // XXX: Currently don't store meta inf
-			char* kCommand = expand(currentCommand);
-			if (kCommand == NULL) {
-				empty(currentCommand);
-				return true;
+		case '/': sign = 1; FALLTHROUGH
+		case '?':
+			  empty(&searchString);
+			  stateVB.motion.search = sign == 1 ? forward : backward;
+			  stateVB.motion.searchPosition.x = term.c.x;
+			  stateVB.motion.searchPosition.y = term.c.y;
+			  stateVB.motion.searchPosition.yScr = term.scr;
+			  stateVB.motion.finished = false;
+			  goto finish;
+		case 'n': sign = 1; FALLTHROUGH
+		case 'N':
+			if (stateVB.motion.search == none) return failed;
+			if (stateVB.motion.search == backward) { sign *= -1; }
+			{
+				bool b = true; int ox = term.c.x; 
+				int oy = term.c.y ; int scr = term.scr;
+				int32_t i = max(stateVB.motion.amount, 1); 
+				for (;i>0 && (b=gotoString(sign)); --i);
+				if (!b) {
+					term.c.x = ox; term.c.y = oy;
+					term.scr = scr;
+				}
+				goto motionFinish;
 			}
-			utf8decode(cs, (Rune*)(kCommand), len);
-		}
+		case 't': // Toggle selection mode and set dirt.
+			  sel.type = sel.type == SEL_REGULAR
+				  ? SEL_RECTANGULAR : SEL_REGULAR;
+			  tsetdirt(sel.nb.y, sel.ne.y);
+			  goto motionFinish;
+	}
 
-		int diff = 0;
-		if (term.c.y > 0) {
-			if (term.c.y > term.bot) {
-				diff = term.bot - term.c.y;
-				term.c.y = term.bot;
-			}
-		} else {
-			if (term.c.y < 0) {
-				diff = -term.c.y;
-				term.c.y = 0;
-			}
+	// Custom commands
+	for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
+		if (cs[0] == normalModeShortcuts[i].key) {
+			return pressKeys(normalModeShortcuts[i].value, 
+					strlen(normalModeShortcuts[i].value)) 
+					? success : failed;
 		}
+	}
 
-		int const _newScr = term.scr + diff;
-		term.c.y = _newScr < 0 ? 0 : (_newScr >= HISTSIZE ? term.bot : term.c.y);
-		term.scr = mod(_newScr, HISTSIZE);
-
-		if (!isEmpty(&highlights)) {
-			empty(&highlights);
-			highlightStringOnScreen();
-		}
+	return failed;
+motionFinish:
+	//if (isMotionFinished() && stateVB.command.op == yank) {
+	if (stateVB.command.op == yank) {
+		selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
+		xsetsel(getsel());
+		xclipcopy();
+		exitCommand();
+	}
+finish:
+	if (len == 1 && !ctrl) { // XXX: for now.
+		EXPAND(kCommand, currentCommand, true)
+		utf8decode(cs, (Rune*)(kCommand), len);
+	}
+finishNoAppend:
+	if (stateVB.command.op == visual) {
+		selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
+	} else if (stateVB.command.op == visualLine) {
+		selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
+	}
 
-		tsetdirt(0, term.row-3);
-		printCommandString();
-		printSearchString();
-
-		if (stateNormalMode.command.op == visual) {
-			selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
-		} else if  (stateNormalMode.command.op == visualLine) {
-			selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
-		} else {
-			if (!isNumber && (stateNormalMode.motion.search == none
-					|| stateNormalMode.motion.finished)) {
-				toggle = !toggle;
-				empty(currentCommand);
-			}
-			if (stateNormalMode.command.op == yank) {
-				if (!isNumber && !discard && stateNormalMode.motion.search == none) {
-					// copy
-					selextend(term.c.x, term.c.y, term.scr, sel.mode, 0);
-					xsetsel(getsel());
-					xclipcopy();
-					applyPosition(&stateNormalMode.command.startPosition);
-					exitCommand();
-				}
-			}
-		}
+	if (!isEmpty(&highlights)) { // XXX only has to be done if shift
+		empty(&highlights);
+		highlightStringOnScreen();
 	}
-	return cmdSuccessful ? success : failed;
+
+	tsetdirt(0, term.row-3); // XXX: can be greately improved
+
+	printCommandString();
+	printSearchString();
+	return success;
 }
 
diff --git a/term.h b/term.h
index 6619255..a373c1e 100644
--- a/term.h
+++ b/term.h
@@ -9,7 +9,7 @@
 
 #include <stdint.h>
 
-#define HISTSIZE      2000
+#define HISTSIZE      100
 
 typedef struct {
 	Glyph attr; /* current char attributes */
-- 
2.25.0


From 0c84c2465ff6d71454c85a56d29c80c5ad9ec165 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Sat, 8 Feb 2020 23:37:29 +0100
Subject: [PATCH 11/23] chore: fix + style

---
 normalMode.c | 46 +++++++++++++++++++++++-----------------------
 1 file changed, 23 insertions(+), 23 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 75c36ad..4adcdf0 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -296,7 +296,7 @@ static bool gotoString(int8_t sign) {
 	uint32_t findIdx = 0;
 	for (uint32_t cIteration = 0; findIdx < searchStrSize
 			&& ++cIteration <= maxIter; moveLetter(sign)) {
-		char const * const SEC(next, sign==1 
+		char const * const SEC(next, sign==1
 				? view(&searchString, findIdx)
 				: viewEnd(&searchString, findIdx), , false)
 		uint32_t const searchChar = *((uint32_t*) next);
@@ -398,7 +398,7 @@ struct {
 /// @param first, second: Dynamic arrays in which the prefix and postfix
 ///                       commands will be returned
 /// @return               whether the command could be extracted successfully.
-static bool expandExpression(char const c, enum Infix expandMode, 
+static bool expandExpression(char const c, enum Infix expandMode,
 		char operation, DynamicArray *cmd) {
 	empty(cmd);
 	bool s = true; //< used in order to detect memory allocation errors.
@@ -417,7 +417,7 @@ static bool expandExpression(char const c, enum Infix expandMode,
 	}
 	// Symmetrical brackets (quotation marks)
 	if (c == '\'' || c == '"') {
-		// Local ambiguity -> do nothing. It cannot be determined if 
+		// Local ambiguity -> do nothing. It cannot be determined if
 		// the current char is the 1st or last char of the selection.
 		//  <---- search here? -- ['] -- or search here? --->
 		if (TLINE(term.c.y)[term.c.x].u == c) {
@@ -429,7 +429,7 @@ static bool expandExpression(char const c, enum Infix expandMode,
 		// infix
 		bool const iffy = expandMode == infix_i;
 		if (iffy) { s = s && checkSetNextV(cmd, 'l'); }
-		s = s && checkSetNextV(cmd, operation); 
+		s = s && checkSetNextV(cmd, operation);
 		if (!iffy) { s = s && checkSetNextV(cmd, 'l'); }
 		// suffix
 		res[0] = '/';
@@ -447,7 +447,7 @@ static bool expandExpression(char const c, enum Infix expandMode,
 			}
 			bool const iffy = expandMode == infix_i;
 			if (iffy) { s = s && checkSetNextV(cmd, 'l'); }
-			s = s && checkSetNextV(cmd, operation); 
+			s = s && checkSetNextV(cmd, operation);
 			if (!iffy) { s = s && checkSetNextV(cmd, 'l'); }
 			s = s && checkSetNextV(cmd, '/');
 			s = s && checkSetNextV(cmd, Brackets[pid].second);
@@ -455,7 +455,7 @@ static bool expandExpression(char const c, enum Infix expandMode,
 			if (iffy) { s = s && checkSetNextV(cmd, 'h'); }
 			return s;
 		}
-	} 
+	}
 	/**/
 	// search string
 	// complicated search operation: <tag>
@@ -516,7 +516,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 	KeySym const * const ksym = (KeySym*) vsym;
 	bool const esc = ksym &&  *ksym == XK_Escape;
 	bool const enter = (ksym && *ksym==XK_Return) || (len==1 &&cs[0]=='\n');
-	bool const quantifier = len == 1 && (BETWEEN(cs[0], 49, 57) 
+	bool const quantifier = len == 1 && (BETWEEN(cs[0], 49, 57)
 			|| (cs[0] == 48 && stateVB.motion.amount));
 	// [ESC] or [ENTER] abort resp. finish the current level of operation.
 	// Typing 'i' if no operation is currently performed behaves like ESC.
@@ -550,7 +550,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 	if (len == 0) { return failed; }
 	// Quantifiers
 	if (quantifier) {
-		stateVB.motion.amount = min(SHRT_MAX, 
+		stateVB.motion.amount = min(SHRT_MAX,
 				stateVB.motion.amount * 10 + cs[0] - 48);
 		goto finish;
 	}
@@ -559,7 +559,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 	if (stateVB.command.infix != infix_none && stateVB.command.op != noop) {
 		DynamicArray cmd = CHAR_ARRAY;
 		char const operation = stateVB.command.op;
-		bool succ = expandExpression(cs[0], 
+		bool succ = expandExpression(cs[0],
 				stateVB.command.infix, visual, &cmd);
 		if (operation == yank) {
 			succ = succ && checkSetNextV(&cmd, operation);
@@ -604,7 +604,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 					selstart(0, term.c.y, term.scr, 0);
 					int const origY = term.c.y;
 					moveLine(max(stateVB.motion.amount, 1));
-					selextend(term.col-1,term.c.y,term.scr, 
+					selextend(term.col-1,term.c.y,term.scr,
 							SEL_RECTANGULAR, 0);
 					term.c.y = origY;
 					FALLTHROUGH
@@ -614,17 +614,17 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 					xclipcopy();
 					exitCommand();
 					goto finish;
-				default: 
+				default:
 					return failed;
 			}
 		case visual:
 		case visualLine:
-			if (stateVB.command.op == cs[0]) { 
-				finishOperation(); 
+			if (stateVB.command.op == cs[0]) {
+				finishOperation();
 				return true;
 			} else {
 				enableOperation(cs[0]);
-				selstart(cs[0] == visualLine ? 0 : term.c.x, 
+				selstart(cs[0] == visualLine ? 0 : term.c.x,
 						term.c.y, term.scr, 0);
 				goto finish;
 			}
@@ -651,7 +651,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 				break;
 			default: return false;
 		}
-	} 
+	}
 	// Motions
 	switch(cs[0]) {
 		case 'j': sign = 1; FALLTHROUGH
@@ -659,7 +659,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			  goto motionFinish;
 		case 'H': term.c.y = 0;
 			  goto motionFinish;
-		case 'M': term.c.y = term.bot / 2; 
+		case 'M': term.c.y = term.bot / 2;
 			  goto motionFinish;
 		case 'L': term.c.y = term.bot;
 			  goto motionFinish;
@@ -668,7 +668,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 		case 'l': sign = 1; FALLTHROUGH
 		case 'h': moveLetter(sign * max(stateVB.motion.amount,1));
 			  goto motionFinish;
-		case '0': term.c.x = 0; 
+		case '0': term.c.x = 0;
 			  goto motionFinish;
 		case '$': term.c.x = term.col-1;
 			  goto motionFinish;
@@ -679,7 +679,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 		case 'B': FALLTHROUGH
 		case 'b':
 		{
-			char const * const wDelim = 
+			char const * const wDelim =
 				cs[0] <= 90 ? wordDelimLarge : wordDelimSmall;
 			uint32_t const wDelimLen = strlen(wDelim);
 
@@ -699,7 +699,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 				for (uint32_t cIt = 0; cIt ++ < maxIter; moveLetter(sign)) {
 					if (startSpaceIsSeparator == contains(TLINE(term.c.y)[term.c.x].u, wDelim, wDelimLen)) {
 						if (state == 1) {
-							if (performOffset) { 
+							if (performOffset) {
 								moveLetter(-sign);
 							}
 							break;
@@ -723,9 +723,9 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			if (stateVB.motion.search == none) return failed;
 			if (stateVB.motion.search == backward) { sign *= -1; }
 			{
-				bool b = true; int ox = term.c.x; 
+				bool b = true; int ox = term.c.x;
 				int oy = term.c.y ; int scr = term.scr;
-				int32_t i = max(stateVB.motion.amount, 1); 
+				int32_t i = max(stateVB.motion.amount, 1);
 				for (;i>0 && (b=gotoString(sign)); --i);
 				if (!b) {
 					term.c.x = ox; term.c.y = oy;
@@ -743,8 +743,8 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 	// Custom commands
 	for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
 		if (cs[0] == normalModeShortcuts[i].key) {
-			return pressKeys(normalModeShortcuts[i].value, 
-					strlen(normalModeShortcuts[i].value)) 
+			return pressKeys(normalModeShortcuts[i].value,
+					strlen(normalModeShortcuts[i].value))
 					? success : failed;
 		}
 	}
-- 
2.25.0


From 1eb17858df417f84413c7fc1dc9d344921e0c236 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 17:54:57 +0100
Subject: [PATCH 12/23] chore,fix,feature: fix invalid read, add color coded
 status bar, history percentage, formatting.

---
 normalMode.c | 264 +++++++++++++++++++++------------------------------
 st.c         |   1 -
 st.h         |   1 +
 x.c          |   6 +-
 4 files changed, 114 insertions(+), 158 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 4adcdf0..0785397 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -5,48 +5,42 @@
 #include "win.h"
 #include "error.h"
 
+#include <X11/keysym.h>
+#include <X11/XKBlib.h>
+
 #include <ctype.h>
 #include <stdio.h>
 #include <limits.h>
 #include <math.h>
 
-#include <X11/keysym.h>
-#include <X11/XKBlib.h>
-
 #define LEN(a)                 (sizeof(a) / sizeof(a)[0])
 #define BETWEEN(x, a, b)       ((a) <= (x) && (x) <= (b))
 #define FALLTHROUGH            __attribute__((fallthrough));
 #define SEC(var,ini,h,r)       var = ini; if (!var) { h; return r; }
 #define EXPAND(v1,v2,r)        char *SEC(v1, expand(v2), empty(v2), true)
-
-static inline int intervalDiff(int v, int a, int b) {
-	return (v < a) ? (v - a) : ((v > b) ? (v - b) : 0);
-}
-
-static inline void swap(DynamicArray *const a, DynamicArray *const b) {
-	DynamicArray tmp = *a;
-	*a = *b;
-	*b = tmp;
-}
-
-static inline int max(int a, int b) { return a > b ? a : b; }
-static inline int min(int a, int b) { return a < b ? a : b; }
+#define currentCommand         (toggle ? &commandHist0 : &commandHist1)
+#define lastCommand            (toggle ? &commandHist1 : &commandHist0)
 
 //
 // Interface to the terminal
-//
-
 extern Glyph const styleCommand;
 extern Glyph const styleSearch;
 extern NormalModeShortcuts normalModeShortcuts[];
 extern size_t const amountNormalModeShortcuts;
 extern char wordDelimSmall[];
 extern char wordDelimLarge[];
+extern unsigned int fgCommandYank;
+extern unsigned int fgCommandVisual;
+extern unsigned int fgCommandVisualLine;
+extern unsigned int bgCommandYank;
+extern unsigned int bgCommandVisual;
+extern unsigned int bgCommandVisualLine;
 
 extern void selclear(void);
 extern void tsetdirt(int, int);
 extern size_t utf8encode(Rune, char *);
 extern size_t utf8decode(const char *, Rune *, size_t);
+extern size_t utf8decodebyte(char c, size_t *i);
 
 extern void selextend(int, int, int, int, int);
 extern void selstart(int, int, int, int);
@@ -55,56 +49,31 @@ extern void tfulldirt(void);
 
 //
 // `Private` structs
-//
-typedef struct {
-	uint32_t x;
-	uint32_t y;
-	uint32_t yScr;
-} Position;
+typedef struct { uint32_t x; uint32_t y; uint32_t yScr; } Position;
 
-/// The entire normal mode state, consisting of an operation
-/// and a motion.
+/// Entire normal mode state, consisting of an operation and a motion.
 typedef struct {
 	Position initialPosition;
-	// Operation:
 	struct OperationState {
 		enum Operation {
-			noop = ' ',
-			visual = 'v',
-			visualLine = 'V',
-			yank = 'y'
-		} op;
+			noop = ' ', visual='v', visualLine='V', yank = 'y' } op;
 		Position startPosition;
-		enum Infix {
-			infix_none = 0,
-			infix_i = 1,
-			infix_a = 2,
-		} infix;
+		enum Infix { infix_none = 0, infix_i = 1, infix_a = 2, } infix;
 	} command;
-	// Motions:
 	struct MotionState {
 		uint32_t amount;
-		enum Search {
-			none,
-			forward,
-			backward,
-		} search;
+		enum Search {none, forward, backward} search;
 		Position searchPosition;
 		bool finished;
 	} motion;
 } NormalModeState;
 
+/// Default state if no operation is performed.
 NormalModeState defaultNormalMode = {
-	{0,0,0},
-	{noop, {0, 0, 0}, false},
-	{0, none, {0, 0, 0}, true}
+	{0,0,0},    {noop, {0, 0, 0}, false},   {0, none, {0, 0, 0}, true}
 };
-
-/// Default state if no operation is performed.
 NormalModeState stateVB = {
-	{0,0,0},
-	{noop, {0, 0, 0}, false},
-	{0, none, {0, 0, 0}, true}
+	{0,0,0},    {noop, {0, 0, 0}, false},   {0, none, {0, 0, 0}, true}
 };
 
 DynamicArray searchString =  UTF8_ARRAY;
@@ -112,44 +81,36 @@ DynamicArray commandHist0 =  UTF8_ARRAY;
 DynamicArray commandHist1 =  UTF8_ARRAY;
 DynamicArray highlights   = QWORD_ARRAY;
 
-
 /// History command toggle
-bool toggle = false;
-#define currentCommand toggle ? &commandHist0 : &commandHist1
-#define lastCommand    toggle ? &commandHist1 : &commandHist0
+static bool toggle = false;
 
 //
 // Utility functions
-//
-
-static inline int
-mod(int a, int b) {
-	for (; a < 0; a += b);
-	return a % b;
+static inline int intervalDiff(int v, int a, int b) {
+	return (v < a) ? (v - a) : ((v > b) ? (v - b) : 0);
 }
-
-static inline bool
-contains (char c, char const * values, uint32_t memSize) {
+static inline void swap(DynamicArray *const a, DynamicArray *const b) {
+	DynamicArray tmp = *a; *a = *b; *b = tmp;
+}
+static inline int max(int a, int b) { return a > b ? a : b; }
+static inline int min(int a, int b) { return a < b ? a : b; }
+static inline int mod(int a, int b) { for (; a < 0; a += b); return a % b; }
+static inline bool contains (char c, char const * values, uint32_t memSize) {
 	ENSURE(values != NULL, return false);
 	for (uint32_t i = 0; i < memSize; ++i) if (c == values[i]) return true;
 	return false;
 }
-
-static inline void
-applyPosition(Position const *pos) {
+static inline void applyPosition(Position const *pos) {
 	ENSURE(pos != NULL, return);
 	term.c.x = pos->x;
 	term.c.y = pos->y;
 	term.scr = pos->yScr;
 }
-
-static inline int
-getSearchDirection(void) {
+static inline int getSearchDirection(void) {
 	return stateVB.motion.search == forward ? 1 : -1;
 }
 
 //  Utilities for working with the current version of the scrollback patch.
-
 static bool moveLine(int32_t const amount) {
 	int32_t const reqShift = intervalDiff(term.c.y+=amount, 0, term.row-1);
 	term.c.y -= reqShift;
@@ -162,24 +123,22 @@ static void moveLetter(int32_t const amount) {
 	int32_t value = (term.c.x += amount) / term.col;
 	if (value -= (term.c.x < 0)) {
 		term.c.x = moveLine(value) ? mod(term.c.x, term.col)
-			: max(min(term.c.x,term.col), 0);
+			: max(min(term.c.x,term.col - 1), 0);
 	}
+	assert(BETWEEN(term.c.x,0,term.col-1)&&BETWEEN(term.c.y,0,term.row-1));
 }
 
 //
 // `Private` functions:
-//
 
-// Fuctions: Temporarily display string on screen.
+// Functions: Temporarily display string on screen.
 
-///
-/// Display string at end of a specified line without writing it into the bufer.
-/// This reserves
-///
+/// Display string at end of a specified line without writing it into the buffer
 /// @param str  string that is to be displayed
 /// @param g    glyph
 /// @param yPos
-static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
+static void
+displayString(DynamicArray const *str, Glyph const *g, int yPos, bool prePos) {
 	ENSURE((str != NULL) && (g != NULL) && (term.row > 0), return);
 	ENSURE(yPos >= 0, yPos = 0);
 	ENSURE(yPos < term.row, yPos = term.row - 1);
@@ -191,53 +150,65 @@ static void displayString(DynamicArray const *str, Glyph *g, int yPos) {
 		term.dirty[yPos] = 1;
 		return;
 	}
+	int32_t const botSz = prePos * 5; //< sz for position indication
 	// Determine the dimensions of used chunk of screen.
-	uint32_t const overrideSize = min(size(str),
-			term.col / maxFractionOverridden);               // (1)
-	uint32_t const overrideEnd = term.col - 1;
+	int32_t const overrideSize = min(size(str) + botSz,
+			term.col / maxFractionOverridden);            // (1)
+	int32_t const overrideEnd = term.col - 2;
 	// Has to follow trivially hence th assert:
 	// overrideSize <(1)= term.col/3  <(0)= term.col = overrideEnd + 1.
 	assert(overrideSize <= overrideEnd + 1);
-	uint32_t const overrideStart = 1 + overrideEnd - overrideSize;
+	int32_t const overrideStart = 1 + overrideEnd - overrideSize;
 
-	Line SEC(line, malloc(sizeof(Glyph) * overrideSize),,)
-
-	for (uint32_t lineIdx = 0; lineIdx < overrideSize; ++lineIdx) {
-		line[lineIdx] = *g;
-		char * SEC(end, viewEnd(str, overrideSize - lineIdx - 1),,)
-		memcpy(&line[lineIdx].u, end, str->itemSize);
+	Glyph *SEC(line, malloc(sizeof(Glyph) * (overrideSize)),,)
+	int32_t offset = (size(str) - overrideSize - 1 + botSz) * str->itemSize;
+	for (uint32_t chr = botSz; chr < overrideSize; ++chr) {
+		line[chr] = *g;
+		line[chr].u = *((Rune*) (str->content+(offset+=str->itemSize)));
+	}
+	if (prePos) {
+		int32_t const pos = min(round((term.scr+1)*100./HISTSIZE),100);
+		ENSURE(term.scr < HISTSIZE, term.scr = HISTSIZE - 1);
+		char prc [6];
+		switch (term.scr) {
+			case HISTSIZE - 1: strcpy(prc, "[TOP]"); break;
+			case 0:            strcpy(prc, "[BOT]"); break;
+			default:           sprintf(prc, "% 3d%c  ", pos, '%');
+		}
+		for (uint32_t chr = 0; chr < botSz; ++chr) {
+			line[chr] = *g;
+			utf8decode(&prc[chr], &line[chr].u, 1);
+		}
 	}
 	xdrawline(TLINE(yPos), 0, yPos, overrideStart);
-	xdrawline(line -overrideStart, overrideStart, yPos, overrideEnd+1);
+	xdrawline(line-overrideStart, overrideStart, yPos, overrideEnd + 1);
 	free(line);
 }
 
 static inline void printCommandString(void) {
 	Glyph g = styleCommand;
+	switch(stateVB.command.op) {
+		case yank: g.fg = fgCommandYank; g.bg = bgCommandYank; break;
+		case visual: g.fg=fgCommandVisual; g.bg=bgCommandVisual; break;
+		case visualLine: g.fg=fgCommandVisualLine;
+				 g.bg=bgCommandVisualLine;
+	}
 	displayString(isEmpty(currentCommand) ? lastCommand : currentCommand,
-			&g, term.row - 1);
+			&g, term.row - 1, true);
 }
 
 static inline void printSearchString(void) {
-	Glyph g = styleSearch;
-	displayString(&searchString, &g, term.row - 2);
+	displayString(&searchString, &styleSearch, term.row - 2, false);
 }
 
-
 // NormalMode Operation / Motion utilies.
 
+static inline bool isMotionFinished(void) { return stateVB.motion.finished; }
 
-static inline bool isMotionFinished(void) {
-	return stateVB.motion.finished;
-}
-
-static inline void finishMotion(void) {
-	stateVB.motion.finished = true;
-}
+static inline void finishMotion(void) { stateVB.motion.finished = true; }
 
 static inline bool isOperationFinished(void) {
-	return stateVB.command.op == noop
-		&& stateVB.command.infix == infix_none;
+	return stateVB.command.op==noop && stateVB.command.infix==infix_none;
 }
 
 /// Register that the current comamnd is finished and a new command is lgoged
@@ -319,43 +290,33 @@ highlightStringOnScreen(void) {
 	bool success = true;
 	for (int y = 0; y < term.row && success; y++) {
 		for (int x = 0; x < term.col && success; x++) {
-			char const* const SEC(next,view(&searchString,findIdx),,)
-
+			char const* const SEC(next,
+					view(&searchString,findIdx),,)
 			if (TLINE(y)[x].u == *((uint32_t*)(next))) {
 				if (++findIdx == 1) {
 					xStart = x;
 					yStart = y;
 				}
 				if (findIdx == searchStringSize) {
-					// mark selected
 					success = success
 						&& append(&highlights, &xStart)
 						&& append(&highlights, &yStart);
-
 					findIdx = 0;
 					term.dirty[yStart] = 1;
 				}
-			} else {
-				findIdx = 0;
-			}
+			} else { findIdx = 0; }
 		}
 	}
-	if (!success) {
-		empty(&highlights);
-	}
+	if (!success) { empty(&highlights); }
 }
 
 static bool gotoStringAndHighlight(int8_t sign) {
       	// Find hte next occurrence of the #searchString in direction #sign
 	bool const found = gotoString(sign);
 	empty(&highlights);
-	if (found) {
-		highlightStringOnScreen();
-	} else {
-		applyPosition(&stateVB.motion.searchPosition);
-	}
-	tsetdirt(0, term.row-3);              //< repaint everything except for the status bar, which
-	                                      //  is painted separately.
+	if (found) { highlightStringOnScreen();
+	} else { applyPosition(&stateVB.motion.searchPosition); }
+	tsetdirt(0, term.row-3); //< everything except for the 'status bar'
 	return found;
 }
 
@@ -380,15 +341,8 @@ static bool executeCommand(DynamicArray const *command) {
 	return succ;
 }
 
-struct {
-	char const first;
-	char const second;
-} const Brackets [] = {
-	{'(', ')'},
-	{'<', '>'},
-	{'{', '}'},
-	{'[', ']'},
-};
+struct { char const first; char const second; } const Brackets [] =
+{ {'(', ')'}, {'<', '>'}, {'{', '}'}, {'[', ']'}, };
 
 
 /// Emits Command prefix and suffix when i motion is performed (e.g. yiw).
@@ -478,16 +432,14 @@ static bool expandExpression(char const c, enum Infix expandMode,
 // Public API
 //
 
-void
-onMove(void) {
+void onMove(void) {
 	stateVB.initialPosition.x = term.c.x;
 	stateVB.initialPosition.y = term.c.y;
 	stateVB.initialPosition.yScr = term.scr;
 }
 
 
-int
-highlighted(int x, int y) {
+int highlighted(int x, int y) {
 	// Compute the legal bounds for a hit:
 	int32_t const stringSize = size(&searchString);
 	int32_t xMin = x - stringSize;
@@ -564,7 +516,6 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 		if (operation == yank) {
 			succ = succ && checkSetNextV(&cmd, operation);
 		}
-
 		NormalModeState const st = stateVB;
 		TCursor         const tc = term.c;
 		stateVB.command.infix    = infix_none;
@@ -577,19 +528,26 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 				stateVB = st;
 				term.c = tc;
 			}
-			swap(&cmd, currentCommand);
+			empty(currentCommand);
+			for (uint32_t i = 0; i < size(&cmd); ++i) {
+				EXPAND(kCommand, currentCommand, true)
+				utf8decode(cmd.content+i, (Rune*)(kCommand),1);
+			}
 		}
 		free(cmd.content);
-		goto finishNoAppend;
+		goto finish;
 	}
 	// Commands (V / v or y)
 	switch(cs[0]) {
 		case '.':
 		{
+			if (isEmpty(currentCommand)) { toggle = !toggle; }
 			DynamicArray cmd = UTF8_ARRAY;
 			swap(&cmd, currentCommand);
 			executeCommand(&cmd) ? success : failed;
 			swap(&cmd, currentCommand);
+			free(cmd.content);
+			toggle = !toggle;
 			goto finishNoAppend;
 		}
 		case 'i': stateVB.command.infix = infix_i; goto finish;
@@ -640,15 +598,15 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 				goto finish;
 			case XK_b:
 				term.scr = min(term.scr + max(term.row - 2, 1),
-						HISTSIZE);
+						HISTSIZE - 1);
 				term.c.y = term.bot;
 				goto finish;
 			case XK_u:
-				term.scr = min(term.scr + term.row/2, HISTSIZE);
+				term.scr = min(term.scr + term.row/2, HISTSIZE - 1);
 				goto finish;
 			case XK_d:
 				term.scr = max(term.scr - term.row / 2, 0);
-				break;
+				goto finish;
 			default: return false;
 		}
 	}
@@ -677,8 +635,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 		case 'e': FALLTHROUGH
 		case 'E': sign = 1; FALLTHROUGH
 		case 'B': FALLTHROUGH
-		case 'b':
-		{
+		case 'b': {
 			char const * const wDelim =
 				cs[0] <= 90 ? wordDelimLarge : wordDelimSmall;
 			uint32_t const wDelimLen = strlen(wDelim);
@@ -719,20 +676,19 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			  stateVB.motion.finished = false;
 			  goto finish;
 		case 'n': sign = 1; FALLTHROUGH
-		case 'N':
+		case 'N': {
 			if (stateVB.motion.search == none) return failed;
 			if (stateVB.motion.search == backward) { sign *= -1; }
-			{
-				bool b = true; int ox = term.c.x;
-				int oy = term.c.y ; int scr = term.scr;
-				int32_t i = max(stateVB.motion.amount, 1);
-				for (;i>0 && (b=gotoString(sign)); --i);
-				if (!b) {
-					term.c.x = ox; term.c.y = oy;
-					term.scr = scr;
-				}
-				goto motionFinish;
+			bool b = true; int ox = term.c.x;
+			int oy = term.c.y ; int scr = term.scr;
+			int32_t i = max(stateVB.motion.amount, 1);
+			for (;i>0 && (b=gotoString(sign)); --i);
+			if (!b) {
+				term.c.x = ox; term.c.y = oy;
+				term.scr = scr;
 			}
+			goto motionFinish;
+		}
 		case 't': // Toggle selection mode and set dirt.
 			  sel.type = sel.type == SEL_REGULAR
 				  ? SEL_RECTANGULAR : SEL_REGULAR;
@@ -751,6 +707,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 
 	return failed;
 motionFinish:
+	stateVB.motion.amount = 0;
 	//if (isMotionFinished() && stateVB.command.op == yank) {
 	if (stateVB.command.op == yank) {
 		selextend(term.c.x, term.c.y, term.scr, sel.type, 0);
@@ -774,9 +731,8 @@ finishNoAppend:
 		empty(&highlights);
 		highlightStringOnScreen();
 	}
-
 	tsetdirt(0, term.row-3); // XXX: can be greately improved
-
+	
 	printCommandString();
 	printSearchString();
 	return success;
diff --git a/st.c b/st.c
index 12e8a37..3321d63 100644
--- a/st.c
+++ b/st.c
@@ -167,7 +167,6 @@ static void selnormalize(void);
 static void selscroll(int, int);
 static void selsnap(int *, int *, int);
 
-static Rune utf8decodebyte(char, size_t *);
 static char utf8encodebyte(Rune, size_t);
 static size_t utf8validate(Rune *, size_t);
 
diff --git a/st.h b/st.h
index c2aa8bb..de2549a 100644
--- a/st.h
+++ b/st.h
@@ -83,6 +83,7 @@ void tnew(int, int);
 void tresize(int, int);
 void tsetdirtattr(int);
 size_t utf8decode(const char *, Rune *, size_t);
+Rune utf8decodebyte(char, size_t *);
 void tsetdirt(int, int);
 void ttyhangup(void);
 int ttynew(char *, char *, char *, char **);
diff --git a/x.c b/x.c
index b61f866..4206d53 100644
--- a/x.c
+++ b/x.c
@@ -1399,7 +1399,7 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 		xclear(winx, winy + win.ch, winx + width, win.h);
 
 	/* Clean up the region we want to draw to. */
-	XftDrawRect(xw.draw, bg, winx, winy, width, win.ch);
+ 	XftDrawRect(xw.draw, bg, winx, winy, width, win.ch);
 
 	/* Set the clip region because Xft is sometimes dirty. */
 	r.x = 0;
@@ -1564,7 +1564,7 @@ xdrawline(Line line, int x1, int y1, int x2)
 
 	numspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);
 	i = ox = 0;
-	for (x = x1; x < x2 && i < numspecs; x++) {
+	for (x = x1; x < x2 && i < numspecs; ++x) {
 		new = line[x];
 		if (new.mode == ATTR_WDUMMY)
 			continue;
@@ -1758,7 +1758,7 @@ kpress(XEvent *ev)
 
 	len = XmbLookupString(xw.xic, e, buf, sizeof buf, &ksym, &status);
 	if (IS_SET(MODE_NORMAL)) {
-		ExitState const es = kpressNormalMode(buf, strlen(buf),
+		ExitState const es = kpressNormalMode(buf, len, // strlen(buf),
 				match(ControlMask, e->state),
 				&ksym);
 		if (es == finished) { normalMode(NULL); }
-- 
2.25.0


From 69b4d986e963b9d7644a797129cf763cb3f3bc83 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 19:05:21 +0100
Subject: [PATCH 13/23] fix: bug and non-intuitive behavior search-highlight

---
 normalMode.c | 37 ++++++++++++++++++++-----------------
 1 file changed, 20 insertions(+), 17 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 0785397..f0d9b92 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -79,7 +79,7 @@ NormalModeState stateVB = {
 DynamicArray searchString =  UTF8_ARRAY;
 DynamicArray commandHist0 =  UTF8_ARRAY;
 DynamicArray commandHist1 =  UTF8_ARRAY;
-DynamicArray highlights   = QWORD_ARRAY;
+DynamicArray highlights   = DWORD_ARRAY;
 
 /// History command toggle
 static bool toggle = false;
@@ -284,15 +284,17 @@ static bool gotoString(int8_t sign) {
 static void
 highlightStringOnScreen(void) {
 	if (isEmpty(&searchString)) { return; }
+	empty(&highlights);
 	uint32_t const searchStringSize = size(&searchString);
 	uint32_t findIdx = 0;
 	uint32_t xStart, yStart;
 	bool success = true;
 	for (int y = 0; y < term.row && success; y++) {
 		for (int x = 0; x < term.col && success; x++) {
+
 			char const* const SEC(next,
 					view(&searchString,findIdx),,)
-			if (TLINE(y)[x].u == *((uint32_t*)(next))) {
+			if (TLINE(y)[x].u == (Rune) *((uint32_t*)(next))) {
 				if (++findIdx == 1) {
 					xStart = x;
 					yStart = y;
@@ -301,8 +303,7 @@ highlightStringOnScreen(void) {
 					success = success
 						&& append(&highlights, &xStart)
 						&& append(&highlights, &yStart);
-					findIdx = 0;
-					term.dirty[yStart] = 1;
+					findIdx = 0; //term.dirty[yStart] = 1;
 				}
 			} else { findIdx = 0; }
 		}
@@ -314,9 +315,9 @@ static bool gotoStringAndHighlight(int8_t sign) {
       	// Find hte next occurrence of the #searchString in direction #sign
 	bool const found = gotoString(sign);
 	empty(&highlights);
-	if (found) { highlightStringOnScreen();
-	} else { applyPosition(&stateVB.motion.searchPosition); }
-	tsetdirt(0, term.row-3); //< everything except for the 'status bar'
+	highlightStringOnScreen();
+	if (!found) {  applyPosition(&stateVB.motion.searchPosition); }
+	//tsetdirt(0, term.row-3); //< everything except for the 'status bar'
 	return found;
 }
 
@@ -451,10 +452,12 @@ int highlighted(int x, int y) {
 	if (xMin < 0) { xMin = 0; }
 
 	uint32_t highSize = size(&highlights);
+	ENSURE(highSize % 2 == 0, empty(&highlights); return false;);
+	highSize /= 2;
 	uint32_t *ptr = (uint32_t*) highlights.content;
 	for (uint32_t i = 0; i < highSize; ++i) {
-		int32_t const sx = *(ptr++);
-		int32_t const sy = *(ptr++);
+		int32_t const sx = (int32_t) *(ptr++);
+		int32_t const sy = (int32_t) *(ptr++);
 		if (BETWEEN(sy, yMin, y) && (sy != yMin || sx > xMin)
 				&& (sy != y || sx <= x)) {
 			return true;
@@ -470,6 +473,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 	bool const enter = (ksym && *ksym==XK_Return) || (len==1 &&cs[0]=='\n');
 	bool const quantifier = len == 1 && (BETWEEN(cs[0], 49, 57)
 			|| (cs[0] == 48 && stateVB.motion.amount));
+	int const previousScroll = term.scr;
 	// [ESC] or [ENTER] abort resp. finish the current level of operation.
 	// Typing 'i' if no operation is currently performed behaves like ESC.
 	if (esc || enter || (len == 1 && cs[0] == 'i' && isMotionFinished()
@@ -682,17 +686,16 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			bool b = true; int ox = term.c.x;
 			int oy = term.c.y ; int scr = term.scr;
 			int32_t i = max(stateVB.motion.amount, 1);
-			for (;i>0 && (b=gotoString(sign)); --i);
-			if (!b) {
-				term.c.x = ox; term.c.y = oy;
-				term.scr = scr;
+			for (;i>0 && (b=gotoString(sign)); --i) {
+                          oy = term.c.y; scr = term.scr;
 			}
+			if (!b) { term.c.x = ox; term.c.y = oy; term.scr = scr;}
 			goto motionFinish;
 		}
 		case 't': // Toggle selection mode and set dirt.
 			  sel.type = sel.type == SEL_REGULAR
 				  ? SEL_RECTANGULAR : SEL_REGULAR;
-			  tsetdirt(sel.nb.y, sel.ne.y);
+			  //tsetdirt(sel.nb.y, sel.ne.y);
 			  goto motionFinish;
 	}
 
@@ -727,12 +730,12 @@ finishNoAppend:
 		selextend(term.col-1, term.c.y, term.scr, sel.type, 0);
 	}
 
-	if (!isEmpty(&highlights)) { // XXX only has to be done if shift
+	if (previousScroll != term.scr && !isEmpty(&searchString)) {
 		empty(&highlights);
 		highlightStringOnScreen();
 	}
-	tsetdirt(0, term.row-3); // XXX: can be greately improved
-	
+	tsetdirt(0, term.row-3); // Required because of the cursor cross.
+
 	printCommandString();
 	printSearchString();
 	return success;
-- 
2.25.0


From 3c18f63e96b573bee88bd4ffc9a66871d5944705 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 19:44:19 +0100
Subject: [PATCH 14/23] chore/fix: move position, add cfg

---
 config.def.h | 17 +++++++++++++++--
 normalMode.c | 25 +++++++++++--------------
 2 files changed, 26 insertions(+), 16 deletions(-)

diff --git a/config.def.h b/config.def.h
index 8f5697e..1b7a9f6 100644
--- a/config.def.h
+++ b/config.def.h
@@ -487,7 +487,20 @@ struct NormalModeShortcuts normalModeShortcuts [] = {
 size_t const amountNormalModeShortcuts = sizeof(normalModeShortcuts) / sizeof(*normalModeShortcuts);
 
 /// Style of the command string visualized in normal mode in the right corner.
-Glyph const styleCommand = {'c', ATTR_ITALIC | ATTR_FAINT, 7, 258};
+//XXX: invalid read if 258 (which is a quickfix for alpha)
+Glyph const styleCommand = {' ', ATTR_ITALIC | ATTR_FAINT, 7, 0*258};
 
 /// Style of the search string visualized in normal mode in the right corner.
-Glyph const styleSearch = {'c', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 258};
+Glyph const styleSearch = {' ', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 0*258};
+
+unsigned int bgCommandYank = 11;
+unsigned int bgCommandVisual = 4;
+unsigned int bgCommandVisualLine = 12;
+
+unsigned int fgCommandYank = 232;
+unsigned int fgCommandVisual = 232;
+unsigned int fgCommandVisualLine = 232;
+
+unsigned int bgPos = 15;
+unsigned int fgPos = 16;
+
diff --git a/normalMode.c b/normalMode.c
index f0d9b92..4bb1d63 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -23,18 +23,13 @@
 
 //
 // Interface to the terminal
-extern Glyph const styleCommand;
-extern Glyph const styleSearch;
+extern Glyph const styleCommand, styleSearch;
 extern NormalModeShortcuts normalModeShortcuts[];
 extern size_t const amountNormalModeShortcuts;
 extern char wordDelimSmall[];
 extern char wordDelimLarge[];
-extern unsigned int fgCommandYank;
-extern unsigned int fgCommandVisual;
-extern unsigned int fgCommandVisualLine;
-extern unsigned int bgCommandYank;
-extern unsigned int bgCommandVisual;
-extern unsigned int bgCommandVisualLine;
+extern unsigned int fgCommandYank, fgCommandVisual, fgCommandVisualLine,
+       bgCommandYank, bgCommandVisual, bgCommandVisualLine, bgPos, fgPos;
 
 extern void selclear(void);
 extern void tsetdirt(int, int);
@@ -146,23 +141,23 @@ displayString(DynamicArray const *str, Glyph const *g, int yPos, bool prePos) {
 	int const maxFractionOverridden = 3;
 	// Threshold: if there is nothing or no space to print, do not print,
 	//            but transfer repsonsibility for printing back to [st].
-	if (term.col < maxFractionOverridden || str->index <= 0) {       // (0)
+	if (term.col < maxFractionOverridden || str->index <= 0) {     // (0)
 		term.dirty[yPos] = 1;
 		return;
 	}
 	int32_t const botSz = prePos * 5; //< sz for position indication
 	// Determine the dimensions of used chunk of screen.
 	int32_t const overrideSize = min(size(str) + botSz,
-			term.col / maxFractionOverridden);            // (1)
+			term.col / maxFractionOverridden);             // (1)
 	int32_t const overrideEnd = term.col - 2;
 	// Has to follow trivially hence th assert:
 	// overrideSize <(1)= term.col/3  <(0)= term.col = overrideEnd + 1.
 	assert(overrideSize <= overrideEnd + 1);
 	int32_t const overrideStart = 1 + overrideEnd - overrideSize;
-
+	// display history[history.size() - (overrideSize - botSz)::-1]
 	Glyph *SEC(line, malloc(sizeof(Glyph) * (overrideSize)),,)
 	int32_t offset = (size(str) - overrideSize - 1 + botSz) * str->itemSize;
-	for (uint32_t chr = botSz; chr < overrideSize; ++chr) {
+	for (uint32_t chr = 0; chr < overrideSize - botSz; ++chr) {
 		line[chr] = *g;
 		line[chr].u = *((Rune*) (str->content+(offset+=str->itemSize)));
 	}
@@ -176,8 +171,10 @@ displayString(DynamicArray const *str, Glyph const *g, int yPos, bool prePos) {
 			default:           sprintf(prc, "% 3d%c  ", pos, '%');
 		}
 		for (uint32_t chr = 0; chr < botSz; ++chr) {
-			line[chr] = *g;
-			utf8decode(&prc[chr], &line[chr].u, 1);
+			line[chr + overrideSize - botSz] =*g;
+			line[chr + overrideSize - botSz].fg = fgPos;
+			line[chr + overrideSize - botSz].bg = bgPos;
+			utf8decode(&prc[chr], &line[chr + overrideSize - botSz].u, 1);
 		}
 	}
 	xdrawline(TLINE(yPos), 0, yPos, overrideStart);
-- 
2.25.0


From ed6ba90b3cc0ed60d84196dfa0e1dee127e4eb4d Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 19:48:11 +0100
Subject: [PATCH 15/23] chore: improve pre-configurations

---
 config.def.h | 5 ++---
 term.h       | 2 +-
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/config.def.h b/config.def.h
index 1b7a9f6..5271a39 100644
--- a/config.def.h
+++ b/config.def.h
@@ -487,11 +487,10 @@ struct NormalModeShortcuts normalModeShortcuts [] = {
 size_t const amountNormalModeShortcuts = sizeof(normalModeShortcuts) / sizeof(*normalModeShortcuts);
 
 /// Style of the command string visualized in normal mode in the right corner.
-//XXX: invalid read if 258 (which is a quickfix for alpha)
-Glyph const styleCommand = {' ', ATTR_ITALIC | ATTR_FAINT, 7, 0*258};
+Glyph const styleCommand = {' ', ATTR_ITALIC | ATTR_FAINT, 7, 16};
 
 /// Style of the search string visualized in normal mode in the right corner.
-Glyph const styleSearch = {' ', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 0*258};
+Glyph const styleSearch = {' ', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 16};
 
 unsigned int bgCommandYank = 11;
 unsigned int bgCommandVisual = 4;
diff --git a/term.h b/term.h
index a373c1e..23adf0e 100644
--- a/term.h
+++ b/term.h
@@ -9,7 +9,7 @@
 
 #include <stdint.h>
 
-#define HISTSIZE      100
+#define HISTSIZE      2500
 
 typedef struct {
 	Glyph attr; /* current char attributes */
-- 
2.25.0


From 3e48f2b501ec3e46084ae400cbe6d9147d9b4bef Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 19:54:55 +0100
Subject: [PATCH 16/23] chore: fix: command history with special chars

---
 normalMode.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/normalMode.c b/normalMode.c
index 4bb1d63..6229337 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -481,6 +481,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			tfulldirt();
 			return finished;
 		}
+		len = 0;
 		goto motionFinish;
 	}
 	// Search: append to search string, then search & highlight
@@ -492,6 +493,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 				exitCommand();
 				return success;
 			}
+			len = 0;
 		} else if (len >= 1) {
 			EXPAND(kSearch, &searchString, true)
 			utf8decode(cs, (Rune*)(kSearch), len);
-- 
2.25.0


From ce14c7dc5ce41439524ee4b6a005fade16b396ee Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 20:12:26 +0100
Subject: [PATCH 17/23] chore: improve config file comments

---
 config.def.h | 17 ++++++++++++-----
 normalMode.c |  2 --
 2 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/config.def.h b/config.def.h
index 5271a39..4eef966 100644
--- a/config.def.h
+++ b/config.def.h
@@ -149,11 +149,13 @@ static unsigned int mousebg = 0;
  * doesn't match the ones requested.
  */
 static unsigned int defaultattr = 11;
-/// Colors for the entities that are highlighted in normal mode.
+/// Colors for the entities that are 'highlighted' in normal mode (search
+/// results currently on screen) [Vim Browse].
 static unsigned int highlightBg = 160;
 static unsigned int highlightFg = 15;
-/// Colors for the line and column that is marked 'current' in normal mode.
-static unsigned int currentBg = 0;
+/// Colors for highlighting the current cursor position (row + col) in normal
+/// mode [Vim Browse].
+static unsigned int currentBg = 8;
 static unsigned int currentFg = 15;
 
 /*
@@ -469,10 +471,12 @@ static char ascii_printable[] =
 
 
 /// word sepearors normal mode
+/// [Vim Browse].
 char wordDelimSmall[] = " \t!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
 char wordDelimLarge[] = " \t"; /// <Word sepearors normal mode (capital W)
 
 /// Shortcusts executed in normal mode (which should not already be in use)
+/// [Vim Browse].
 struct NormalModeShortcuts normalModeShortcuts [] = {
 	{ 'C', "?Building\n" },
 	{ 'c', "/Building\n" },
@@ -486,12 +490,15 @@ struct NormalModeShortcuts normalModeShortcuts [] = {
 
 size_t const amountNormalModeShortcuts = sizeof(normalModeShortcuts) / sizeof(*normalModeShortcuts);
 
-/// Style of the command string visualized in normal mode in the right corner.
+/// Style of the command string visualized in normal mode in the right corner
+/// [Vim Browse].
 Glyph const styleCommand = {' ', ATTR_ITALIC | ATTR_FAINT, 7, 16};
-
 /// Style of the search string visualized in normal mode in the right corner.
+/// [Vim Browse].
 Glyph const styleSearch = {' ', ATTR_ITALIC | ATTR_BOLD_FAINT, 7, 16};
 
+/// Colors used in normal mode in order to highlight different operations and
+/// empathise the current position on screen  in  the status area [Vim Browse].
 unsigned int bgCommandYank = 11;
 unsigned int bgCommandVisual = 4;
 unsigned int bgCommandVisualLine = 12;
diff --git a/normalMode.c b/normalMode.c
index 6229337..0ae092b 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -311,7 +311,6 @@ highlightStringOnScreen(void) {
 static bool gotoStringAndHighlight(int8_t sign) {
       	// Find hte next occurrence of the #searchString in direction #sign
 	bool const found = gotoString(sign);
-	empty(&highlights);
 	highlightStringOnScreen();
 	if (!found) {  applyPosition(&stateVB.motion.searchPosition); }
 	//tsetdirt(0, term.row-3); //< everything except for the 'status bar'
@@ -730,7 +729,6 @@ finishNoAppend:
 	}
 
 	if (previousScroll != term.scr && !isEmpty(&searchString)) {
-		empty(&highlights);
 		highlightStringOnScreen();
 	}
 	tsetdirt(0, term.row-3); // Required because of the cursor cross.
-- 
2.25.0


From 54a34d97f4920e729ab359b84270ddece9bb4542 Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 20:24:46 +0100
Subject: [PATCH 18/23] feat: add command for clearing history (replay)

---
 config.def.h |  4 ++--
 normalMode.c | 13 ++++++-------
 2 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/config.def.h b/config.def.h
index 4eef966..4ba347e 100644
--- a/config.def.h
+++ b/config.def.h
@@ -478,8 +478,8 @@ char wordDelimLarge[] = " \t"; /// <Word sepearors normal mode (capital W)
 /// Shortcusts executed in normal mode (which should not already be in use)
 /// [Vim Browse].
 struct NormalModeShortcuts normalModeShortcuts [] = {
-	{ 'C', "?Building\n" },
-	{ 'c', "/Building\n" },
+	{ 'R', "?Building\n" },
+	{ 'r', "/Building\n" },
 	{ 'F', "?: error:\n" },
 	{ 'f', "/: error:\n" },
 	{ 'Q', "?[Leaving vim, starting execution]\n" },
diff --git a/normalMode.c b/normalMode.c
index 0ae092b..152a5cb 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -139,9 +139,9 @@ displayString(DynamicArray const *str, Glyph const *g, int yPos, bool prePos) {
 	ENSURE(yPos < term.row, yPos = term.row - 1);
 	// Arbritary limit to avoid withhelding too much info from user.
 	int const maxFractionOverridden = 3;
-	// Threshold: if there is nothing or no space to print, do not print,
-	//            but transfer repsonsibility for printing back to [st].
-	if (term.col < maxFractionOverridden || str->index <= 0) {     // (0)
+	// Threshold: if there is no space to print, do not print, but transfer
+	//            repsonsibility for printing back to [st].
+	if (term.col < maxFractionOverridden) {                        // (0)
 		term.dirty[yPos] = 1;
 		return;
 	}
@@ -614,6 +614,8 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 	}
 	// Motions
 	switch(cs[0]) {
+		case 'c': empty(&commandHist0); empty(&commandHist1);
+			  goto finishNoAppend;
 		case 'j': sign = 1; FALLTHROUGH
 		case 'k': moveLine(max(stateVB.motion.amount,1) * sign);
 			  goto motionFinish;
@@ -696,7 +698,6 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			  //tsetdirt(sel.nb.y, sel.ne.y);
 			  goto motionFinish;
 	}
-
 	// Custom commands
 	for (size_t i = 0; i < amountNormalModeShortcuts; ++i) {
 		if (cs[0] == normalModeShortcuts[i].key) {
@@ -705,7 +706,6 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 					? success : failed;
 		}
 	}
-
 	return failed;
 motionFinish:
 	stateVB.motion.amount = 0;
@@ -731,8 +731,7 @@ finishNoAppend:
 	if (previousScroll != term.scr && !isEmpty(&searchString)) {
 		highlightStringOnScreen();
 	}
-	tsetdirt(0, term.row-3); // Required because of the cursor cross.
-
+	tsetdirt(0, term.row-3); //< Required because of the cursor cross.
 	printCommandString();
 	printSearchString();
 	return success;
-- 
2.25.0


From 607838966c8acec57fe6d588d5bcd053f251597c Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Mon, 10 Feb 2020 20:48:52 +0100
Subject: [PATCH 19/23] fix: search-highlight if no occurence in direction

---
 normalMode.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 152a5cb..3156f93 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -278,8 +278,7 @@ static bool gotoString(int8_t sign) {
 }
 
 /// Highlight all found strings on the current screen.
-static void
-highlightStringOnScreen(void) {
+static void highlightStringOnScreen(void) {
 	if (isEmpty(&searchString)) { return; }
 	empty(&highlights);
 	uint32_t const searchStringSize = size(&searchString);
@@ -288,7 +287,6 @@ highlightStringOnScreen(void) {
 	bool success = true;
 	for (int y = 0; y < term.row && success; y++) {
 		for (int x = 0; x < term.col && success; x++) {
-
 			char const* const SEC(next,
 					view(&searchString,findIdx),,)
 			if (TLINE(y)[x].u == (Rune) *((uint32_t*)(next))) {
@@ -311,8 +309,8 @@ highlightStringOnScreen(void) {
 static bool gotoStringAndHighlight(int8_t sign) {
       	// Find hte next occurrence of the #searchString in direction #sign
 	bool const found = gotoString(sign);
-	highlightStringOnScreen();
 	if (!found) {  applyPosition(&stateVB.motion.searchPosition); }
+	highlightStringOnScreen();
 	//tsetdirt(0, term.row-3); //< everything except for the 'status bar'
 	return found;
 }
@@ -435,7 +433,6 @@ void onMove(void) {
 	stateVB.initialPosition.yScr = term.scr;
 }
 
-
 int highlighted(int x, int y) {
 	// Compute the legal bounds for a hit:
 	int32_t const stringSize = size(&searchString);
@@ -736,4 +733,3 @@ finishNoAppend:
 	printSearchString();
 	return success;
 }
-
-- 
2.25.0


From fd72baf02ea0c04266bc2b3d1f5903f4f8803edf Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Tue, 11 Feb 2020 12:29:40 +0100
Subject: [PATCH 20/23] fix: Statusbar: char[] overflow, pos, highlight

In the status bar, the following fixes / improvements ware performed:e
- fix char[] overflow in position report when position = 100 percent.
- add space between the position report and current command.
- do not override color highlighting of status command by the cursor.
---
 normalMode.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 3156f93..2835fca 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -145,7 +145,7 @@ displayString(DynamicArray const *str, Glyph const *g, int yPos, bool prePos) {
 		term.dirty[yPos] = 1;
 		return;
 	}
-	int32_t const botSz = prePos * 5; //< sz for position indication
+	int32_t const botSz = prePos * 6; //< sz for position indication
 	// Determine the dimensions of used chunk of screen.
 	int32_t const overrideSize = min(size(str) + botSz,
 			term.col / maxFractionOverridden);             // (1)
@@ -162,23 +162,26 @@ displayString(DynamicArray const *str, Glyph const *g, int yPos, bool prePos) {
 		line[chr].u = *((Rune*) (str->content+(offset+=str->itemSize)));
 	}
 	if (prePos) {
-		int32_t const pos = min(round((term.scr+1)*100./HISTSIZE),100);
 		ENSURE(term.scr < HISTSIZE, term.scr = HISTSIZE - 1);
-		char prc [6];
+		int32_t const p=round((HISTSIZE-1-term.scr)*100./(HISTSIZE-1));
+		char prc [8];
 		switch (term.scr) {
-			case HISTSIZE - 1: strcpy(prc, "[TOP]"); break;
-			case 0:            strcpy(prc, "[BOT]"); break;
-			default:           sprintf(prc, "% 3d%c  ", pos, '%');
+			case HISTSIZE - 1: strcpy(prc, " [TOP]"); break;
+			case 0:            strcpy(prc, " [BOT]"); break;
+			default:           sprintf(prc, " % 3d%c  ", p, '%');
 		}
 		for (uint32_t chr = 0; chr < botSz; ++chr) {
 			line[chr + overrideSize - botSz] =*g;
 			line[chr + overrideSize - botSz].fg = fgPos;
 			line[chr + overrideSize - botSz].bg = bgPos;
-			utf8decode(&prc[chr], &line[chr + overrideSize - botSz].u, 1);
+			utf8decode(&prc[chr],&line[chr+overrideSize-botSz].u,1);
 		}
+		line[overrideSize - botSz] =*g;
 	}
 	xdrawline(TLINE(yPos), 0, yPos, overrideStart);
+	term.c.y -= term.row; term.c.x -= term.col; // not highlight hack
 	xdrawline(line-overrideStart, overrideStart, yPos, overrideEnd + 1);
+	term.c.y += term.row; term.c.x += term.col;
 	free(line);
 }
 
@@ -534,7 +537,7 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			}
 		}
 		free(cmd.content);
-		goto finish;
+		goto finishNoAppend;
 	}
 	// Commands (V / v or y)
 	switch(cs[0]) {
-- 
2.25.0


From 7c6986223e2065dea14e062a97f7444b71f8ea7e Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Tue, 11 Feb 2020 12:39:23 +0100
Subject: [PATCH 21/23] fix: Improve '.' repetition of command

---
 normalMode.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/normalMode.c b/normalMode.c
index 2835fca..13dbf5c 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -549,7 +549,6 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 			executeCommand(&cmd) ? success : failed;
 			swap(&cmd, currentCommand);
 			free(cmd.content);
-			toggle = !toggle;
 			goto finishNoAppend;
 		}
 		case 'i': stateVB.command.infix = infix_i; goto finish;
-- 
2.25.0


From 05a22b97ca79b34da4bff1fc1f9bc7a9c0230e4d Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Tue, 11 Feb 2020 12:58:04 +0100
Subject: [PATCH 22/23] feat: remove quantifier with [BCKSP]

---
 normalMode.c | 33 ++++++++++++++++++++++-----------
 1 file changed, 22 insertions(+), 11 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 13dbf5c..4e282f2 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -462,9 +462,8 @@ int highlighted(int x, int y) {
 	return false;
 }
 
-ExitState
-kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
-	KeySym const * const ksym = (KeySym*) vsym;
+ExitState kpressNormalMode(char const * cs, int len, bool ctrl, void const *v) {
+	KeySym const * const ksym = (KeySym*) v;
 	bool const esc = ksym &&  *ksym == XK_Escape;
 	bool const enter = (ksym && *ksym==XK_Return) || (len==1 &&cs[0]=='\n');
 	bool const quantifier = len == 1 && (BETWEEN(cs[0], 49, 57)
@@ -483,20 +482,32 @@ kpressNormalMode(char const * cs, int len, bool ctrl, void const * vsym) {
 		len = 0;
 		goto motionFinish;
 	}
-	// Search: append to search string, then search & highlight
-	if (stateVB.motion.search != none && !stateVB.motion.finished) {
-		if (ksym && *ksym == XK_BackSpace) {
-			if (!isEmpty(currentCommand)) { pop(currentCommand); }
+	// Backspace
+	if (ksym && *ksym == XK_BackSpace) {
+		bool s = stateVB.motion.search!=none&&!stateVB.motion.finished;
+		bool q = stateVB.motion.amount != 0;
+		if (!(s || q)) { return failed; }
+		len = 0;
+
+		if (!isEmpty(currentCommand)) { pop(currentCommand); }
+		if (s) {
 			if (!isEmpty(&searchString)) { pop(&searchString); }
-			if (isEmpty(&searchString)) {
+			else if (isEmpty(&searchString)) {
 				exitCommand();
 				return success;
 			}
-			len = 0;
-		} else if (len >= 1) {
+		} else if (q) {
+			stateVB.motion.amount /= 10;
+			goto finishNoAppend;
+		}
+	}
+
+	// Search: append to search string, then search & highlight
+	if (stateVB.motion.search != none && !stateVB.motion.finished) {
+		if (len >= 1) {
 			EXPAND(kSearch, &searchString, true)
 			utf8decode(cs, (Rune*)(kSearch), len);
-		} else { return success; }
+		}
 		applyPosition(&stateVB.motion.searchPosition);
 		gotoStringAndHighlight(getSearchDirection());
 		goto finish;
-- 
2.25.0


From 030f360f7bc31e6975c703dd82914c98780a80eb Mon Sep 17 00:00:00 2001
From: Julius Huelsmann <juliusHuelsmann@gmail.com>
Date: Tue, 11 Feb 2020 13:19:27 +0100
Subject: [PATCH 23/23] fix: reset at correct position

---
 normalMode.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/normalMode.c b/normalMode.c
index 4e282f2..59a5a89 100644
--- a/normalMode.c
+++ b/normalMode.c
@@ -473,9 +473,11 @@ ExitState kpressNormalMode(char const * cs, int len, bool ctrl, void const *v) {
 	// Typing 'i' if no operation is currently performed behaves like ESC.
 	if (esc || enter || (len == 1 && cs[0] == 'i' && isMotionFinished()
 				&& isOperationFinished())) {
-		if (terminateCommand(!enter) ) {
+		if (terminateCommand(!enter)) {
 			applyPosition(&stateVB.initialPosition);
+			Position const pc = stateVB.initialPosition;
 			stateVB = defaultNormalMode;
+			stateVB.initialPosition = pc;
 			tfulldirt();
 			return finished;
 		}
@@ -614,7 +616,7 @@ ExitState kpressNormalMode(char const * cs, int len, bool ctrl, void const *v) {
 				term.c.y = term.bot;
 				goto finish;
 			case XK_u:
-				term.scr = min(term.scr + term.row/2, HISTSIZE - 1);
+				term.scr = min(term.scr+term.row/2, HISTSIZE-1);
 				goto finish;
 			case XK_d:
 				term.scr = max(term.scr - term.row / 2, 0);
-- 
2.25.0

